{"categories":[{"title":"tutorial","uri":"https://fancyelmo.github.io/elmo-wonderland/categories/tutorial/"},{"title":"入门知识","uri":"https://fancyelmo.github.io/elmo-wonderland/categories/%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/"},{"title":"实验楼","uri":"https://fancyelmo.github.io/elmo-wonderland/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"title":"快照","uri":"https://fancyelmo.github.io/elmo-wonderland/categories/%E5%BF%AB%E7%85%A7/"},{"title":"查阅资料","uri":"https://fancyelmo.github.io/elmo-wonderland/categories/%E6%9F%A5%E9%98%85%E8%B5%84%E6%96%99/"}],"posts":[{"content":"防止vultr发疯，还是记录一下\n挑一个服务器 vultr上点兵点将选个国家的服务器，系统选 centos 6 x64 ， ping通看看延迟，太高就换一个\n磨刀霍霍 实例建成后更新一下\nyum update\r方案一 wget -N --no-check-certificate (地址一)https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh\r(地址二)https://softs.fun/Bash/ssr.sh\rchmod +x ssr.sh\rbash ssr.sh\r跟着引导走\n一般加密方式为aes-256-cfb ， 断频繁出现，混淆选择tls1.2_ticket_auth试试看\n方案二 更改内核\nrpm -ivh http://www.aloneray.com/wp-content/uploads/2017/03/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpm\rrpm -ivh http://www.aloneray.com/wp-content/uploads/2017/03/kernel-2.6.32-504.3.3.el6.x86_64.rpm --force\r重启服务器\nreboot\r重启后安装ssr\nwget --no-check-certificate http://www.aloneray.com/wp-content/uploads/2019/01/shadowsocksR_CN.sh \u0026amp;\u0026amp; chmod +x shadowsocksR_CN.sh \u0026amp;\u0026amp; ./shadowsocksR_CN.sh\r冲浪利器 谷歌BBR yum -y install wget\rwget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh\rchmod +x bbr.sh\r./bbr.sh\r锐速 wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh \u0026amp;\u0026amp; bash serverspeeder-all.sh\r可选项 关闭防火墙 service iptables stop\rchkconfig iptables off\r","id":0,"section":"posts","summary":"\u003cp\u003e防止vultr发疯，还是记录一下\u003c/p\u003e","tags":["ssr","科学上网"],"title":"搭梯子备忘录","uri":"https://fancyelmo.github.io/elmo-wonderland/2020/02/%E6%90%AD%E6%A2%AF%E5%AD%90%E5%A4%87%E5%BF%98%E5%BD%95/","year":"2020"},{"content":"RabbitMQ 是高级消息队列协议（AMQP）的开源消息代理软件。\nRabbitMQ 服务器是用 Erlang 语言编写的，消息系统允许软件、应用相互连接和扩展。这些应用可以相互链接起来组成一个更大的应用，或者将用户设备和数据进行连接。消息系统通过将消息的发送和接收分离来实现应用程序的异步和解偶。\n名词介绍 消息队列 消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户\n消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它\nRabbitMQ RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而群集和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库\nAMQP AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制\n为什么要使用消息队列","id":1,"section":"posts","summary":"\u003cp\u003eRabbitMQ 是高级消息队列协议（AMQP）的开源消息代理软件。\u003c/p\u003e\n\u003cp\u003eRabbitMQ 服务器是用 Erlang 语言编写的，消息系统允许软件、应用相互连接和扩展。这些应用可以相互链接起来组成一个更大的应用，或者将用户设备和数据进行连接。消息系统通过将消息的发送和接收分离来实现应用程序的异步和解偶。\u003c/p\u003e","tags":["MessageQueue","菜鸡入门"],"title":"RabbitMQ初体验","uri":"https://fancyelmo.github.io/elmo-wonderland/2020/01/rabbitmq%E5%88%9D%E4%BD%93%E9%AA%8C/","year":"2020"},{"content":"一、实验简介 1.1 实验内容 在互联网时代，人们获取信息的途径多种多样，大量的信息涌入到人们的视线中。如何从浩如烟海的信息中提炼出关键信息，滤除垃圾信息，一直是现代人关注的问题。在这个信息爆炸的时代，我们每时每刻都要更新自己的知识储备，而网络是最好的学习平台。对信息过滤和处理能力强，学习效率就会得到提高。“词云”就是为此而诞生的。“词云”是对网络文本中出现频率较高的“关键词”予以视觉上的突出，形成“关键词云层”或“关键词渲染”，从而过滤掉大量的无意义信息，使浏览者只要一眼扫过词云图片就可以领略文章或者网页内容的主旨。不仅如此，一幅制作精美的词云图片，可以起到一图胜千言的效果，在报告或者PPT中适当的使用词云，会使表达更清晰充分，为演讲者表达的意义加分。本实验将使用Python3的wordcloud扩展包制作词云，生成图片保存。并介绍如何改进wordcloud扩展包使其能显示中文字符，最后介绍如何使用自己喜欢的图片定制词云图片轮廓。\n1.2 实验知识点  制作词云的基本步骤和原理 Python3代码实现词云制作 wordcloud扩展包的使用 使用自定义图片制作词云，分析《三体》I、 II、 III的关键词  1.3 实验环境 该实验在ubuntu14.04下完成，由于Python具有跨平台特性，该实验的代码也可以运行于Windows和Mac系统上，只需要对字体部分做相应处理即可。\n python3.5 numpy 1.14.3 matplotlib 2.2.2 Pillow 5.1 wordcloud 1.4.1 python3-tk 3.5.1  1.4 适合人群 本课程难度为一般，属于初级级别课程，适合具有Python3基础的用户，熟悉python3基础知识加深巩固。\n1.5 代码获取 你可以通过下面命令将代码下载到实验楼环境中，作为参照对比进行学习。\n$ wget http://labfile.oss.aliyuncs.com/courses/756/simple.py\r$ wget http://labfile.oss.aliyuncs.com/courses/756/my_word_cloud.py\r二、实验原理 词云的原理是对输入的文本数据进行词频统计，根据词汇出现频率的不同，按不同比例显示出词汇，生成图片。频率高的词汇显示的大，频率低的词汇显示的小。文本数据可以是本地数据，也可是爬虫动态从网络中获取的。\n三、开发准备 打开Xfce终端，进入 Code 目录，创建 work 文件夹, 将其作为课程的工作目录。下载并安装实验需要的扩展包 。如果大家平时想在自己的电脑上进行实验，无论是Windows还是Linux还是Mac，都强烈推荐安装Anaconda,这是一个Python的科学计算包，里面几乎包含了常用的所有扩展包，不用自己费力安装了，该软件由Python之父带头维护,三个平台同时更新。\n$ cd Code \u0026amp;\u0026amp; mkdir work \u0026amp;\u0026amp; cd work\r$ sudo apt-get update\r$ sudo pip3 install numpy\r$ sudo pip3 install matplotlib\r$ sudo apt-get install libtiff5-dev libjpeg8-dev zlib1g-dev \\\r libfreetype6-dev liblcms2-dev libwebp-dev tcl8.6-dev tk8.6-dev python-tk #安装Pillow依赖包\r$ sudo pip3 install Pillow\r$ sudo apt-get install python3-tk\r下载小说《三体》I、 II、 III。\n$ wget http://labfile.oss.aliyuncs.com/courses/756/santi.txt\r$ wget http://labfile.oss.aliyuncs.com/courses/756/santi2.txt\r$ wget http://labfile.oss.aliyuncs.com/courses/756/santi3.txt\r安装wordcloud扩展包。\n$ sudo apt-get install python3-dev\r$ sudo pip3 install wordcloud\r四、实验步骤 4.1 简单测试 运行一个简单工程，测试扩展包安装是否正常\n在对《三体》进行处理之前，我们先运行一下官方的示例程序，确保扩展包安装正常，程序能够正常工作。在work目录下新建simple.py文件：\n$ cd /home/shiyanlou/Code/work\r$ touch simple.py\r代码如下：\n#!/usr/bin/env python3\r \u0026#34;\u0026#34;\u0026#34;Minimal Example\r===============\rGenerating a square wordcloud from the US constitution using default arguments.\r\u0026#34;\u0026#34;\u0026#34;\rfrom os import path\rfrom wordcloud import WordCloud\rd = path.dirname(__file__)\r# Read the whole text.\r text = open(path.join(d, \u0026#39;constitution.txt\u0026#39;)).read()\r# Generate a word cloud image\r wordcloud = WordCloud().generate(text)\r# Display the generated image:\r # the matplotlib way:\r import matplotlib.pyplot as plt\rplt.imshow(wordcloud)\rplt.axis(\u0026#34;off\u0026#34;)\r# lower max_font_size\r wordcloud = WordCloud(max_font_size=40).generate(text)\rplt.figure()\rplt.imshow(wordcloud)\rplt.axis(\u0026#34;off\u0026#34;)\rplt.show()\r由代码可见，程序运行时会搜寻脚本所在的路径下的文本文件“constitution.txt”，所以我们在运行脚本前需要将这个文本放入work文件夹下面。 通过下面的命令下载文本：\n$ wget http://labfile.oss.aliyuncs.com/courses/756/constitution.txt\r运行脚本：\n$ python3 simple.py\r如果扩展包安装一切正常，程序将输出如下窗口：\n至此，我们得到了一个英文词云。\n4.2 解决中文显示问题 我们已经成功安装了wordcloud扩展包，并成功运行了一个示例文件。但是这个示例文件有很多问题，首先，显示的是英文字符，在面对中国同事或者老板做报告和分享时，使用英文的词云明显不合适，而且很多文本本身就是中文词汇，没法制作成英文词云；词云的外轮廓显示的方方正正中规中矩，比较呆板，没有美感。以上问题，我们一一来解决。\n首先，我们先解决中文显示的问题。 我们先尝试一下，把一本小说输入到simple.py文件中并声明gbk编码，看看输出结果是什么样子的。我们只需要修改源文件成为下面这样，注意在文件头部要声明文件用utf-8编码：\n#!/usr/bin/env python3\r #-*- coding: utf-8 -*-\r \u0026#34;\u0026#34;\u0026#34;Minimal Example\r===============\rGenerating a square wordcloud from the US constitution using default arguments.\r\u0026#34;\u0026#34;\u0026#34;\rfrom os import path\rfrom wordcloud import WordCloud\rd = path.dirname(__file__)\r# Read the whole text.\r #text = open(path.join(d, \u0026#39;constitution.txt\u0026#39;)).read()\r text = open(\u0026#39;santi.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;gbk\u0026#39;).read()\r# Generate a word cloud image\r wordcloud = WordCloud().generate(text)\r# Display the generated image:\r # the matplotlib way:\r import matplotlib.pyplot as plt\rplt.imshow(wordcloud)\rplt.axis(\u0026#34;off\u0026#34;)\r# lower max_font_size\r wordcloud = WordCloud(max_font_size=40).generate(text)\rplt.figure()\rplt.imshow(wordcloud)\rplt.axis(\u0026#34;off\u0026#34;)\rplt.show()\r运行代码得到的输出是这个样子的：\n这怎么回事呢? 仔细看图片中出现的都是框框，说明我们正确识别了汉字，但是汉字怎么显示成这样了呢?这是因为wordcloud没有找到用于显示汉字的字体啊！ 我们都知道Ubuntu是外国人搞出来的系统，所以对中文的支持肯定没有对英文那么好，尤其是字体什么的，更少了。而wordcloud也是个外国人开发的词云库，这俩货都没考虑到显示中文的问题。 但是呢，既然python能显示中文，那么wordcloud就应该也可以的。我们来想想办法解决这个问题。 仔细的看一下我们的代码，我们发现，生成词云的关键环节是这一句：\nwordcloud = WordCloud(max_font_size=40).generate(text)\r我们仔细看看这个类，传给它的参数里有个关键参数：\nfont_path : string\rFont path to the font that will be used (OTF or TTF).\rDefaults to DroidSansMono path on a Linux machine. If you are on\ranother OS or don\u0026#39;t have this font, you need to adjust this path.\r 恩，我们发现可以指定一个字体文件给它，代替默认的字体显示词云。问题转化为我们要找一个linux下支持汉字的字体文件。我这边随手找了一个ubuntu系统中安装的字体DroidSansFallbackFull.ttf，为了防止在别的linux系统中没有这个字体而带来麻烦，干脆直接把字体文件放在work文件夹下让它跟着源文件走，这样就不会出现找不到的情况啦。 通过下面的命令下载字体文件：\n$ wget http://labfile.oss.aliyuncs.com/courses/756/DroidSansFallbackFull.ttf\r将字体文件放在/home/shiyanlou/Code/work目录下，然后修改源代码，首先找到我们自己的字体文件：\nimport os\rfont=os.path.join(os.path.dirname(__file__), \u0026#34;DroidSansFallbackFull.ttf\u0026#34;)\r然后在我们的源程序中，实例化wordcloud类的两个地方，指定wordcloud使用我们自己的字体文件：\nwordcloud = WordCloud(font_path=font).generate(text)\rwordcloud = WordCloud(font_path=font,max_font_size=40).generate(text)\r好的，修改完以后我们再看一下执行效果：\nOK,我们期望的目的达到了！\n4.3 定制词云 我们经常在网上看到别人家的词云都是奇形怪状的，像下面这样：\n所以看着我们自己方方正正的词云，是不是感觉太中规中矩了？都不好意思拿出手了吧？ 没关系，我们也可以做一个不规则边缘的词云！ 为了达到一个定制词云的效果，我们需要一个图片作为mask，这个mask的作用就是为我们的词云提供一个空间，让我们的词云只在这个空间里显示，这就达到了类似上面词云的效果。 我们的mask图片是星球大战的士兵的头盔，长成这个样子：\n做实验时请在这里下载：\n$ wget http://labfile.oss.aliyuncs.com/courses/756/stormtrooper_mask.png\r为此，我们需要修改我们的代码，增加图片mask，修改后的代码如下：\n#!/usr/bin/python3\r #-*- coding: utf-8 -*-\r \u0026#34;\u0026#34;\u0026#34;Using custom colors\r====================\rUsing the recolor method and custom coloring functions.\r\u0026#34;\u0026#34;\u0026#34;\rimport numpy as np\rfrom PIL import Image\rfrom os import path\rimport matplotlib.pyplot as plt\rimport random\rimport os\rfrom wordcloud import WordCloud, STOPWORDS\rfont=os.path.join(os.path.dirname(__file__), \u0026#34;DroidSansFallbackFull.ttf\u0026#34;)\rdef grey_color_func(word, font_size, position, orientation, random_state=None, **kwargs):\rreturn \u0026#34;hsl(0, 0%%, %d%%)\u0026#34; % random.randint(60, 100)\rd = path.dirname(__file__)\rmask = np.array(Image.open(path.join(d, \u0026#34;stormtrooper_mask.png\u0026#34;)))\rtext = open(\u0026#39;santi.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;gbk\u0026#39;).read()\r# preprocessing the text a little bit\r text = text.replace(\u0026#34;程心说\u0026#34;, \u0026#34;程心\u0026#34;)\rtext = text.replace(\u0026#34;程心和\u0026#34;, \u0026#34;程心\u0026#34;)\rtext = text.replace(\u0026#34;程心问\u0026#34;, \u0026#34;程心\u0026#34;)\r# adding movie script specific stopwords\r stopwords = set(STOPWORDS)\rstopwords.add(\u0026#34;int\u0026#34;)\rstopwords.add(\u0026#34;ext\u0026#34;)\rwc = WordCloud(font_path=font,max_words=2000, mask=mask, stopwords=stopwords, margin=10,\rrandom_state=1).generate(text)\r# store default colored image\r default_colors = wc.to_array()\rplt.title(\u0026#34;Custom colors\u0026#34;)\rplt.imshow(wc.recolor(color_func=grey_color_func, random_state=3))\rwc.to_file(\u0026#34;a_new_hope.png\u0026#34;)\rplt.axis(\u0026#34;off\u0026#34;)\rplt.figure()\rplt.title(\u0026#34;三体-词频统计\u0026#34;)\rplt.imshow(default_colors)\rplt.axis(\u0026#34;off\u0026#34;)\rplt.show()\r这段代码对词云的显示结果做了一点点修改，例如，“程心说”应该算是“程心”的词频，而不应该独立计算，所以程序中做了一个简单的替换。 这段代码的运行结果如下： 我们使用了星球大战的武士的头盔作为词云形状，怎么样，看起来还不错吧？\n然而，我们的任务并没有结束。我们说了要自己定制词云，那么就连这个mask图片也可以根据我们自己的喜好进行定制。 为了在ubuntu下将我们喜欢的图片作为mask图片，我们需要安装gimp软件：\n$ sudo apt-get install gimp\r然后我随意上网百度了一个美女图片，就是下面这张：\n请使用下面命令获取该美女图片的jpg格式：\n$ wget http://labfile.oss.aliyuncs.com/courses/756/04.jpg\r图片有什么要求呢？恩，最好背景是纯色的，这样好处理，当然如果有PS高手帮忙的话，背景是什么也无所谓了。我们用gimp软件对这幅图片进行处理，把除了女孩之外的背景改为白色，就可以作为mask图片使用了。好下面我们动手开始制作。\n在命令行中输入gimp就可以进入gimp界面：\n首先，在图层页面下，右键这张图，增加alpha图层：\n然后，使用左侧工具栏中的魔术棒工具，在这个姑娘身上随便画一下，就选中了这个姑娘：\n然后，在空白区域，右键，编辑，使用白色作为背景颜色填充图片：\n搞定之后，我们把图片导出来：\n注意导出的时候选择png格式，如下设置:\n然后我们就得到了这个mask图片。我将其重命名为04.png我们修改代码使用这个图片作为mask图片：\nmask = np.array(Image.open(path.join(d, \u0026#34;04.png\u0026#34;)))\r请使用如下命令获取图片04.png：\n$ wget http://labfile.oss.aliyuncs.com/courses/756/04.png\r再看我们的运行结果：\n好的，至此我们就得到了定制的词云。\n五、实验总结 我们使用wordcloud扩展包实现了定制词云，通过指定字体文件解决了wordcloud默认不能显示中文的问题，进一步，使用gimp软件实现了自定义mask图片的功能。最后，使用自定义的词云分析了小说《三体》的词频，制作了词云。\n","id":2,"section":"posts","summary":"一、实验简介 1.1 实验内容 在互联网时代，人们获取信息的途径多种多样，大量的信息涌入到人们的视线中。如何从浩如烟海的信息中提炼出关键信息，滤除垃圾","tags":["tutorial"],"title":"使用python定制词云","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/12/%E4%BD%BF%E7%94%A8-python-%E5%AE%9A%E5%88%B6%E8%AF%8D%E4%BA%91/","year":"2019"},{"content":"Docker 概念及基本用法 1. 课程说明 课程为纯动手实验教程，为了能说清楚实验中的一些操作会加入理论内容。理论内容我们不会写太多，已经有太多好文章了，会精选最值得读的文章推荐给你，在动手实践的同时扎实理论基础。\n实验环境中可以联网，不受实验楼网络限制。\n2. 学习方法 实验楼的 Docker 课程包含 14 个实验，每个实验都提供详细的步骤和截图。适用于有一定 Linux 系统基础，想快速上手 Docker 的同学。\n学习方法是多实践，多提问。启动实验后按照实验步骤逐步操作，同时理解每一步的详细内容。\n如果实验开始部分有推荐阅读的材料，请务必先阅读后再继续实验，理论知识是实践必要的基础。\n3. 本节内容简介 本实验中我们初步接触 Docker 的概念和基本用法。需要依次完成下面几项任务：\n Docker 基本概念 安装 Docker Docker 运行 Hello World  4. 推荐阅读 本节实验推荐先阅读下述内容：\n 4.1 深入浅出 Docker（一）：Docker 核心技术预览  这篇文章介绍了 Docker 产生的技术发展历程，Docker 中的核心技术以及相关的子项目，非常好的入门资料。\n 4.2 Understand the architecture  这篇 Docker 官方的文章详细介绍了 Docker 的运行机制和必要的组件。不涉及到很底层的技术，可以做为对 Docker 的一个初步了解。\n5. Docker 概念 5.1 容器技术 Linux 容器技术很早就有了，比较有名的是被集成到主流 Linux 内核中的 LXC 项目。容器通过对操作系统的资源访问进行限制，构建成独立的资源池，让应用运行在一个相对隔离的空间里，同时容器间也可以进行通信。\n容器技术对比虚拟机技术，容器比虚拟化更轻量级，对资源的消耗小很多。容器操作也更快捷，启动和停止都要比虚拟机快。但容器需要与主机共享操作系统内核，不能像虚拟机那样运行独立的内核。\nDocker 是一个基于 LXC 技术构建的容器引擎，基于 GO 语言开发，遵循 Apache2.0 协议开源。Docker 的发展得益于为使用者提供了更好的容器操作接口。包括一系列的容器，镜像，网络等管理工具，可以让用户简单的创建和使用容器。\nDocker 支持将应用打包进一个可以移植的容器中，重新定义了应用开发，测试，部署上线的过程，核心理念就是 Build once, Run anywhere。它带来了快速高效的开发生命周期，构建了 Build, Ship and Run 流程，统一了整个开发、测试和部署的环境和流程。\nDocker 容器技术的典型应用场景是开发运维上提供持续集成和持续部署的服务。\n下面我们开始介绍 Docker 中的几个基本概念。\n5.2 镜像 Docker 的镜像概念类似于虚拟机里的镜像，是一个只读的模板，一个独立的文件系统，包括运行容器所需的数据，可以用来创建新的容器。\n镜像可以基于 DockerFile 构建，DockerFile 是一个描述文件，里面包含若干条命令，每条命令都会对基础文件系统创建新的层次结构。\n用户可以通过编写 DockerFile 创建新的镜像，也可以直接从类似 GitHub 的 Docker Hub 上下载镜像使用。\n5.3 容器 Docker 容器是由 Docker 镜像创建的运行实例。Docker 容器类似虚拟机，可以支持的操作包括启动，停止，删除等。每个容器间是相互隔离的，但隔离的效果比不上虚拟机。容器中会运行特定的应用，包含特定应用的代码及所需的依赖文件。\n在 Docker 容器中，每个容器之间的隔离使用 Linux 的 CGroups （Control Groups）和 Namespace 技术实现的。CGroups（控制组）提供了资源控制： CPU、内存、磁盘等资源的访问限制。Namespaces （命名空间）提供了系统资源的隔离：进程、网络、文件系统等。\n5.4 仓库 如果你使用过 Git 和 GitHub 就很容易理解 Docker 的仓库概念。Docker 仓库相当于一个 GitHub 上的代码库。\nDocker 仓库是用来包含镜像的位置，Docker 提供一个注册服务器（Registry）来保存多个仓库，每个仓库又可以包含多个具备不同 tag 的镜像。Docker 运行中使用的默认仓库是 Docker Hub 公共仓库。\n仓库支持的操作类似 Git，创建了新的镜像后，我们可以 push 提交到仓库，也可以从指定仓库 pull 拉取镜像到本地。\n6. 安装 Docker 有两个版本，Community Edition(CE) 和 Enterprise Edition(EE)。即社区版和企业版本。我们将介绍 Ubuntu 中社区版的安装过程。\n 在实验环境中，已经安装了 docker-ce。\n 6.1 设置存储库 首先更新 apt 软件包数据库，以确保软件包列表是最新的：\n$ sudo apt-get update\r 执行 sudo 时可能会出现 “sudo: 无法解析主机: xxxxxx” 这样的提示，这是因为云主机的 hostname 不是 localhost，而在 /etc/hosts 中定义了 127.0.0.1 localhost，这个提示可以忽略。如果不想要终端出现这样的提示，可以执行以下命令 sudo hostname localhost。\n 安装一些软件包，以允许 apt 通过 HTTPS 使用存储库：\n$ sudo apt-get -y install \\\r apt-transport-https \\\r ca-certificates \\\r curl \\\r software-properties-common\r 这里的 \\ 是换行的意思，当我们输入的命令太长，不方便看时，可以用 \\ 将命令分行输入。另外 $ 是提示符，输入命令的时候不需要输入这个符号。\n 这里我们使用阿里云提供的源，先添加相应的密钥：\n$ curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -\r再添加相应源的信息：\n$ sudo add-apt-repository \u0026#34;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs)stable\u0026#34;\r6.2 安装 docker-engine 查看此时 docker 的版本信息:\n# 更新 apt 索引库\r$ sudo apt-get update\r# 查看可用的版本\r$ sudo apt-cache madison docker-engine\r更新版本的 docker 软件包为 docker-ce。我们环境中已经有 docker 了，可以先移除再进行安装。\n$ sudo apt-get remove docker docker-engine docker.io\r最后我们执行安装命令，我们这里是安装的 17.05 版本的：\n$ sudo apt-get install docker-engine=17.05.0~ce-0~ubuntu-trusty  如果要安装最新版，可使用 sudo apt-get install docker-ce。\n 在安装成功后，Docker 的守护进程自动启动，不需要手动启动服务。\n此时，我们可以查看其版本信息，使用如下命令：\n$ docker version\r当前实验环境中的 docker 版本信息如下图所示：\n在上图中，该命令能够正确执行，但是如果是自己搭建的 docker 环境，可能会提示我们没有相应的权限连接到 Docker 守护进行绑定的 Unix 套接字。这是因为，默认情况下，该套接字归属于 root 用户，对于其它用户只能通过 sudo 来进行访问。\n如果要让 shiyanlou 用户可以直接执行 docker 命令而不必在每次执行时都输入 sudo 来获得权限，我们可以将要执行 docker 命令的用户添加到用户组 docker 中。该用户组会在安装后自动创建，我们只需执行添加用户到 docker 用户组的操作（在实验楼的在线实验环境中已完成该设置项）：\n$ sudo gpasswd -a shiyanlou docker\r添加用户到一个用户组中的方式有很多，例如我们还可以使用如下命令：\n$ sudo usermod -aG docker shiyanlou\r在添加成功后，我们还需要重新开始一个 shell 修改才能生效。这时可以尝试打开一个新的终端或者使用如下命令：\n$ sudo su shiyanlou\r6.3 启动 Docker 服务 对于 Docker 的镜像仓库来说，国内访问速度较慢，我们添加一个阿里云提供的 Docker 镜像加速器。\n首先，我们需要编辑 /etc/docker/daemon.json 文件：\n$ sudo vi /etc/docker/daemon.json\r然后加入如下内容：\n{\r\u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://n6syp70m.mirror.aliyuncs.com\u0026#34;]\r}\r修改之后，需要重启 docker 服务，让修改生效。使用如下命令：\n$ sudo service docker restart\r7. Hello world 在安装之后，我们可以通过运行一个 hello-world 的镜像来验证 Docker CE 是否被正确的安装，使用如下命令：\n$ docker container run hello-world\r该命令会下载一个名为 hello-world 的镜像并运行于一个容器中。当这个容器运行时，会输出一些信息并退出:\n如上图中标注出的提示信息所示，提示我们安装正确。\n8. 总结  Docker 基本概念 安装 Docker Docker 运行 Hello World  本节实验主要讲解了 docker 的相关概念以及如何安装 docker。\n容器管理 1. 课程说明 课程为纯动手实验教程，为了能说清楚实验中的一些操作会加入理论内容。理论内容我们不会写太多，已经有太多好文章了，会精选最值得读的文章推荐给你，在动手实践的同时扎实理论基础。\n实验环境中可以联网，不受实验楼网络限制。\n2. 学习方法 实验楼的 Docker 课程包含 14 个实验，每个实验都提供详细的步骤和截图，适用于有一定 Linux 系统基础，想快速上手 Docker 的同学。\n学习方法是多实践，多提问。启动实验后按照实验步骤逐步操作，同时理解每一步的详细内容。\n如果实验开始部分有推荐阅读的材料，请务必先阅读后再继续实验，理论知识是实践必要的基础。\n3. 本节内容简介 容器是 Docker 的一个基本概念，每个容器中都运行一个应用并为该应用提供完整的运行环境。本实验将详细学习 Docker 容器的创建，运行管理操作。需要依次完成下面几项任务：\n 容器命令基础 创建容器 容器的启动与停止 容器中进程的暂停与恢复 查看容器列表 连接到容器中 查看元数据 显示进程信息 查看文件修改 容器中执行命令 删除容器  对于 Docker 的镜像仓库来说，国内访问速度较慢，我们添加一个阿里云提供的 Docker 镜像加速器。\n首先，我们需要编辑 /etc/docker/daemon.json 文件：\n$ sudo vi /etc/docker/daemon.json\r然后加入如下内容：\n{\r\u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://n6syp70m.mirror.aliyuncs.com\u0026#34;]\r}\r修改之后，需要重启 docker 服务，让修改生效。使用如下命令：\n$ sudo service docker restart\r4. docker 命令 4.1 查看系统信息 除了查看版本信息之外，在 docker 的命令组中还有一个较为常用的命令，查看系统的一些相关信息：\n$ docker system info\r# 或者使用命令\r$ docker info\r运行截图如下所示：\n4.2 help 我们可以直接通过 help 或者使用 man 手册的方式查看相关命令的详细说明，例如我们直接使用如下命令:\n$ docker --help\r我们可以看到运行结果如下图所示。如果之前有学习过 docker 相关知识的同学，可能会发现一些不一样的地方。即下图中标出的 Management commands 和 Commands。在 1.13 版本之前，docker 并没有 Mangement commands。\n4.3 Management Commands 在 Docker 1.12 CLI 中大约有四十个左右的顶级命令，这些命令没有经过任何组织，显得十分混乱，对于新手来说，学习它们并不轻松。\n而在 Docker 1.13 中将命令进行分组，就得到如上图中所示的 Management Commands。例如经常使用的容器的一些相关命令：\n# 创建一个新的容器，下面分别为 Commands 和 Management Commands，作用相同\r$ docker create\r$ docker container create\r# 显示容器列表\r$ docker ps\r$ docker container ls\r# 在一个新的容器中运行一个命令\r$ docker run\r$ docker container run\r...\r如上所示，对于新的命令而言相比于旧命令明显更具有可读性。并且在实验环境中的 docker 版本以及最新版本中两者都是有效的命令，所以在这里我们将一些常用的命令，及其对应的 Management Commands 命令都列举出来，方便大家在后续的学习过程中可以进行参考。\n4.4 命令选项 命令的选项有以下几种：长选项、短选项、复合选项、无选项。\n我们以 docker container ls （即 docker ps，它的作用是查看所有）\n可以先输入以下命令，获得提示信息：\n$ docker container ls --help\r命令执行后的结果如下：\n可以看到图中的 -a 和 --all 选项，他们的作用都是显示所有容器（包括未运行的容器）。短选项是以一个 - 开头，其后紧跟上一个字母或数字，比如 -a。长选项是以两个 - 开头，其后紧跟一个单词，比如 --all。\n# 使用短选项\r$ docker container ls -a\r# 使用长选项\r$ docker container ls --all\r# 它们两者的功能是一样的，只是不同的写法\r那什么是复合选项呢？当我们要使用多个短选项时，比如使用 -a 和 -q（从图中可以看到，这个选项只会显示容器的 ID），原本命令应该是 docker container ls -a -q，这时我们可以简写为 docker container ls -aq，这里的选项 -aq 就是复合选项，它是 -a 和 -q 的复合。\n对于 docker container ls 这个命令，我们还可以不使用选项（没有选项时，输出正在运行的容器）。\n关于 docker container ls 在本实验后面的内容中还会详细介绍，我们只需要记住它的简单功能就可以了。\n5. 容器生命周期管理 5.1 创建容器（1） 首先，我们回顾在上一节使用到的 docker container run hello-world 命令，该命令的格式为：\n# Management Commands\r$ docker container run [OPTIONS] IMAGE [COMMAND [ARGS...]]\r# 旧命令格式如下：\r$ docker run [OPTIONS] IMAGE [COMMAND [ARGS...]]\r上述两个命令的作用相同，docker container run 命令会在指定的镜像 IMAGE 上创建一个可写的容器（因为镜像是只读的），然后开始运行指定的命令 [COMMAND [ARGS...]]。\n一些常用的配置项为：\n -i 或 --interactive， 交互模式 -t 或 --tty， 分配一个 pseudo-TTY，即伪终端 --rm 在容器退出后自动移除 -p 将容器的端口映射到主机 -v 或 --volume， 指定数据卷   这些配置项对于上述的两个命令（Management Commands 和旧命令）都是有效的，在后面的内容不会再特殊说明。\n  关于该命令的详细参数较多，并且大多数参数在很多命令中的意义是相同的，将在后面的内容中使用到时进行相应的介绍。\n 我们指定 busybox 镜像，然后运行命令 echo \u0026quot;hello shiyanlou\u0026quot; 命令，如下所示：\n$ docker container run \\\r busybox echo \u0026#34;hello shiyanlou\u0026#34;\r在上图中，我们可以看到该命令执行的过程：\n 对于指定镜像而言，首先会从本地查找，找不到时将会从镜像仓库中下载该镜像 镜像下载完成后，通过镜像启动容器，并运行 echo \u0026quot;hello shiyanlou\u0026quot; 命令，输出运行结果之后退出。  在执行命令之后，容器就会退出，如果我们需要一个保持运行的容器，最简单的方法就是给这个容器一个可以保持运行的命令或者应用，比如 bash，例如我们在 ubunutu 容器中运行 /bin/bash 命令：\n$ docker container run \\\r -i -t \\\r ubuntu /bin/bash\r对于交互式的进程而言（例如这里的 bash），必须将 -i 和 -t 参数一起使用，才能为容器进程分配一个伪终端，通常我们会直接使用 -it。\n如上所示，我们已经进入到分配的终端中了，这时如果我们需要退出 bash，可以使用以下两种方式，它们的效果完全不同：\n 直接使用 exit 命令，这时候 bash 程序终止，容器进入到停止状态。 使用组合键退出，容器仍然保持运行的状态，可以再次连接到这个 bash 中，组合键是 ctrl + p 和 ctrl +q。即先同时按下 ctrl 和 p 键，再同时按 ctrl 和 q 键，就可以让容器在后台运行。  对于刚刚创建创建的容器，我们输入 exit 退出容器，再使用 docker container ls -a 查看容器的状态，结果如下图所示：\n然后我们新建一个容器，使用第二种方式退出，创建的方式和刚刚相同。使用 docker container ls -a 命令查看容器的状态，可以看到该容器仍然处于运行中：\n实际使用中，我们不必创建容器之后使用组合键 ctrl + p 和 ctrl +q 来让容器进入后台运行，通常以 -d 参数指定容器以后台模式运行：\n# 以后台模式创建并运行一个容器\r$ docker container run \\\r -i -t -d \\\r ubuntu /bin/bash\r使用 docker container ls -a 命令查看容器的状态，可以看到这个容器已经在后台运行。\n5.2 创建容器（2） 严格意义上来讲，docker run 命令的作用并不是创建一个容器，而是在一个新的容器中运行一个命令。而用于创建一个新容器的命令为\n# Management Commands\r$ docker container create [OPTIONS] IMAGE [COMMAND] [ARG...]\r# 旧的命令格式如下：\r$ docker create [OPTIONS] IMAGE [COMMAND] [ARG...]\r该命令会在指定的镜像 IMAGE 上创建一个可写容器层，并 准备 运行指定的命令。需要着重强调的是，这里是准备运行，并不是立即运行。即该命令只创建容器，并不会运行容器。\n一些常见的配置项如下所示：\n --name 指定一个容器名称，未指定时，会随机产生一个名字 --hostname 设置容器的主机名 --mac-address 设置 MAC 地址 --ulimit 设置 Ulimit 选项   关于上述提到的 ulimit，我们可以通过其对容器运行时的一些资源进行限制。ulimit 是一种 linux 系统的内建功能，一些简单的描述，可以参考 https://www.ibm.com/developerworks/cn/linux/l-cn-ulimit/ ，而对于在下面我们将要设置的部分值的含义，可以参考 https://access.redhat.com/solutions/61334 。\n 除此之外，关于创建容器，我们还可以设置有关存储和网络的详细内容，将会在下一节的内容中进行介绍。\n如下示例，我们指定容器的名字为 shiyanlou01，主机名为 shiyanlou01，设置相应的 MAC 地址，并通过 ulimit 设置最大进程数（1024:2048 分别代表软硬资源限制，详细内容可以参考上面的链接），使用 ubuntu 的镜像，并运行 bash：\n$ docker container create \\\r --name shiyanlou01 \\\r --hostname shiyanlou01 \\\r --mac-address 00:01:02:03:04:05 \\\r --ulimit nproc=1024:2048 \\\r -it ubuntu /bin/bash\r此时，容器创建成功后，会打印该容器的 ID，这里需要简单说明一下，在 docker 中，容器的标识有三种比较常见的标识方式：\n UUID 长标识符，例如 1f6789f885029dbdd4a6426d7b950996a5bcc1ccec9f8185240313aa1badeaff UUID 短标识符，从长标识符开始，只要不与其它标识符冲突，可以从头开始，任意选用位数，例如针对上面的长标识符，可以使用 1f，1f678 等等 Name 最后一种方式即是使用容器的名字  在容器创建成功后，我们可以查看其运行状态，使用如下命令：\n# 此时该容器并未运行，需要使用 -a 参数\r$ docker container ls -a\r新创建的容器的状态 (STATUS) 为 Created，并且其容器名被设置为对应的值，而之前没有指定名字的容器都是随机生成的名字。\n5.3 容器的启动与停止 启动容器操作 容器的启动命令为：\n# Management Commands\r$ docker container start [OPTIONS] CONTAINER [CONTAINER...]\r# 旧的命令格式如下：\r$ docker start [OPTIONS] CONTAINER [CONTAINER...]\r对于上面我们创建的容器 shiyanlou01 而言，此时处于 Created 状态，需要使用如下命令启动它：\n$ docker container start shiyanlou01\r此时，运行一个容器我们分成了两个步骤，即创建和启动，使用的命令如下：\n# 创建\r$ docker container create \\\r --name shiyanlou01 \\\r --hostname shiyanlou01 \\\r --mac-address 00:01:02:03:04:05 \\\r --ulimit nproc=1024:2048 \\\r -it ubuntu /bin/bash\r# 启动\r$ docker container start shiyanlou01\r上述的两个命令如果我们使用 docker container run 只需要一步即可，即此时 run 命令同时完成了 create 及 start 操作：\n$ docker container run \\\r --name shiyanlou01 \\\r --hostname shiyanlou01 \\\r --mac-address 00:01:02:03:04:05 \\\r --ulimit nproc=1024:2048 \\\r -it ubuntu /bin/bash\r 除此之外，上面的 run 命令还完成一些其它的操作，例如没有镜像时会 pull 镜像，使用 -it 参数时完成了 attach 操作（后面会学习该操作），使用 --rm 参数在容器退出后还会完成 container rm 操作。\n  run 命令是一个综合性的命令，如果能够熟练的使用它可以简化很多步骤，但是其使用方式较为复杂\n 停止容器操作 停止容器可以使用如下命令：\n# Management Commands\r$ docker container stop CONTAINER [CONTAINER...]\r# 旧的命令格式如下：\r$ docker stop CONTAINER [CONTAINER...]\r刚刚我们启动了一个名为 shiyanlou01 的容器，并且进入了交互式界面，这里我们先同时按下 ctrl 和 p 键，再同时按 ctrl 和 q 键，让这个容器进入到后台运行。\n此时我们使用 docker container ls -a 命令查看容器的状态，从下图可以看到，容器正在运行。输入 docker container stop shiyanlou01，docker 返回了容器的 UUID，再次使用 docker container ls -a 命令查看容器的状态，发现容器停止运行了。\n重启容器操作 重启容器可以使用如下命令：\n# Management Commands\r$ docker container restart CONTAINER [CONTAINER...]\r# 旧的命令格式如下：\r$ docker restart CONTAINER [CONTAINER...]\r这里我们重启刚刚停止的容器 shiyanlou01，然后再使用 docker container ls -a 命令查看容器，从下图中可以看到，容器又处于运行状态了。\n5.4 进程的暂停与恢复 暂停进程操作 暂停容器中进程的命令格式如下：\n# Management Commands\r$ docker container pause CONTAINER [CONTAINER...]\r# 旧的命令格式如下：\r$ docker pause [OPTIONS] CONTAINER [CONTAINER...]\r这里还是使用 shiyanlou01 这个容器，执行下述命令。\n$ docker container pause shiyanlou01\r$ docker container ls -a\r如下图所示，容器被暂停后，此时处于 Paused 状态。\n恢复进程操作 恢复容器中进程的命令格式如下：\n# Management Commands\r$ docker container unpause CONTAINER [CONTAINER...]\r# 旧的命令格式如下：\r$ docker unpause [OPTIONS] CONTAINER [CONTAINER...]\r使用 shiyanlou01 这个容器，执行下述命令。\n# 恢复容器中的进程\r$ docker container unpause shiyanlou01\r# 查看容器列表\r$ docker container ls -a\r如下图所示，容器恢复后，此时处于运行状态。\n6. 其他容器操作 6.1 查看容器列表 查看容器列表可以使用如下命令：\n# Management Commands\r$ docker container ls [OPTIONS]\r# 旧的命令格式如下：\r$ docker ps [OPTIONS]\r在使用命令时，我们可以使用一些可选的配置项 [OPTIONS]。\n -a 显示所有的容器 -q 仅显示 ID -s 显示总的文件大小  默认情况下，直接使用该命令仅显示正在运行的容器，如下所示：\n$ docker container ls\r我们可以使用 -a 参数，来显示所有的容器，并加上 -s 选项，显示大小，命令如下：\n$ docker container ls -a -s\r6.2 连接到正在运行中的容器 上述操作我们启动的容器运行于后台，所以，我们需要使用 attach 操作将本地标准输入输出流连接到一个运行中的容器，命令格式为：\n# Management Commands\r$ docker container attach [OPTIONS] CONTAINER\r# 旧的命令格式如下：\r$ docker attach [OPTIONS] CONTAINER\r如下示例，我们启动容器，并使用连接命令：\n$ docker container start shiyanlou01\r$ docker container attach shiyanlou01\r连接到容器后，查看相应的主机名（输入 hostname 命令）和 Mac 地址（输入 ifconfig 命令），可以判断我们连接到了刚刚创建的容器。\n6.3 查看容器的元数据 查看容器的详细信息（即元数据）可以使用如下命令：\n# Management Commands\r$ docker container inspect [OPTIONS] CONTAINER [CONTAINER...]\r# 旧的命令格式如下：\r$ docker inspect [OPTIONS] CONTAINER [CONTAINER...]\r例如我们查看刚刚创建的容器的详细信息就可以使用以下命令：\n# 使用容器名\r$ docker container inspect shiyanlou01\r# 使用 ID ，因生成的 ID 不同，需要修改为相应的 ID\r$ docker container inspect 1f6789\r$ docker container inspect 1f6\r例如，我们查看刚刚创建的名为 shiyanlou01 的容器的 MAC 地址，就可以使用如下命令：\n$ docker container inspect shiyanlou01 | grep \u0026#34;MacAddress\u0026#34;\r6.4 容器的日志管理 获取容器的输出信息可以使用如下命令：\n# Management Commands\r$ docker container logs [OPTIONS] CONTAINER\r# 旧的命令格式如下：\r$ docker logs [OPTIONS] CONTAINER\r常用的配置项有：\n -t 或 --timestamps 显示时间戳 -f 实时输出，类似于 tail -f  这里我们重新运行一个容器，让它在后台执行一个不断输出的脚本，命令如下：\n$ docker container run \\\r --name shiyanlou02 \\\r -i -t -d \\\r ubuntu /bin/sh -c \u0026#34;while true; do echo hello shiyanlou; sleep 2; done\u0026#34;\r \u0026ldquo;while true; do echo hello world; sleep 2; done\u0026rdquo; 是一个脚本，它的功能是每 2 秒输出一次“ hello shiyanlou ”，此处不讲解语法构成，感兴趣的同学可以自己了解相关知识。\n 如下所示，我们查看刚刚创建的容器的日志，使用如下命令：\n$ docker container logs -tf shiyanlou02\r我们可以使用组合键 Ctrl + c 来结束日志跟踪，其结果如下图所示。\n6.5 显示容器中的进程信息 除了获取日志之外，还可以显示运行中的容器的进程信息，命令格式如下：\n# Management Commands\r$ docker container top CONTAINER\r# 旧的命令格式如下：\r$ docker top CONTAINER\r例如查看刚刚创建的容器的进程信息：\n$ docker container top shiyanlou02\r 需要注意的是，该命令对于并未运行的容器是无效的\n 6.6 查看文件修改 查看相对于镜像的文件系统来说，容器中做了哪些改变，可以使用如下命令：\n# Management Commands\r$ docker container diff CONTAINER\r# 旧的命令格式如下：\r$ docker diff CONTAINER\r我们先在 shiyanlou01 中创建一个文件，执行以下命令：\n# 重启容器\r$ docker container restart shiyanlou01\r# 连接到容器中\r$ docker container attach shiyanlou01\r进入容器中后，创建一个文件，并退出：\n# 创建一个文件\r$ touch ~/a.txt\r现在我们在 shiyanlou01 容器中创建一个文件，就可以使用 docker container diff shiyanlou01 命令查看到相应的修改：\n6.7 容器中执行命令 除了使用 docker container run 执行命令之外，我们还可以在一个运行中的容器中执行命令，使用如下格式：\n# Management Commands\r$ docker container exec [OPTIONS] CONTAINER COMMAND [ARG...]\r# 旧的命令格式如下：\r例如，我们在 shiyanlou01 容器中执行 echo \u0026quot;test_exec\u0026quot; 命令，就可以使用如下命令：\n# 重启容器\r$ docker container restart shiyanlou01\r# 执行命令\r$ docker container exec shiyanlou01 echo \u0026#34;test_exec\u0026#34;\r6.8 删除容器 删除容器的命令：\n# Management Commands\r$ docker container rm [OPTIONS] CONTAINER [CONTAINER...]\r# 旧的命令格式如下：\r$ docker rm [OPTIONS] CONTAINER [CONTAINER...]\r 需要注意的是，在删除容器后，在容器中进行的操作并不会持久化到镜像中\n 如果想删除之前创建的所有容器，可以使用以下命令：\n$ docker container rm -f $(docker container ls -aq)\rdocker container ls -aq 会输出所有容器的 UUID ，rm 命令可以根据 UUID 去删除容器。这里用来选项 -f 是因为还有在运行中的容器，所以需要强制删除。ls 列出的 UUID 传递给 rm 进行删除。\n7. 总结 本节实验中我们学习了以下内容：\n 容器命令基础 创建容器 容器的启动与停止 容器中进程的暂停与恢复 查看容器列表 连接到容器中 查看元数据 显示进程信息 查看文件修改 容器中执行命令 删除容器  请务必保证自己能够动手完成整个实验，只看文字很简单，真正操作的时候会遇到各种各样的问题，解决问题的过程才是收获的过程。\n镜像管理 1. 课程说明 课程为纯动手实验教程，为了能说清楚实验中的一些操作会加入理论内容。理论内容我们不会写太多，已经有太多好文章了，会精选最值得读的文章推荐给你，在动手实践的同时扎实理论基础。\n实验环境中可以联网，不受实验楼网络限制。\n2. 学习方法 实验楼的 Docker 课程包含 14 个实验，每个实验都提供详细的步骤和截图，适用于有一定 Linux 系统基础，想快速上手 Docker 的同学。\n学习方法是多实践，多提问。启动实验后按照实验步骤逐步操作，同时理解每一步的详细内容。\n如果实验开始部分有推荐阅读的材料，请务必先阅读后再继续实验，理论知识是实践必要的基础。\n3. 本节内容简介 第一节实验中我们已经接触了一些镜像的概念，简单的说镜像就是一个容器的只读模板，用来创建容器。当运行容器时需要指定镜像，如果本地没有该镜像，则会从 Docker Registry 下载。默认查找的是 Docker Hub。Docker 的镜像是增量的修改，每次创建新的镜像都会在老的镜像上面构建一个增量的层，使用到的技术是Another Union File System(AUFS)，感兴趣的同学可以学习文档 InfoQ:剖析 Docker 文件系统：Aufs 与 Devicemapper。\n本节中，我们需要依次完成下面几项任务：\n 查看镜像列表 查看镜像详细信息 搜索镜像 拉取镜像 构建镜像 删除镜像  对于 Docker 的镜像仓库来说，国内访问速度较慢，我们添加一个阿里云提供的 Docker 镜像加速器。\n首先，我们需要编辑 /etc/docker/daemon.json 文件：\n$ sudo vi /etc/docker/daemon.json\r然后加入如下内容：\n{\r\u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://n6syp70m.mirror.aliyuncs.com\u0026#34;]\r}\r修改之后，需要重启 docker 服务，让修改生效。使用如下命令：\n$ sudo service docker restart\r4. 镜像 如果能够熟练的使用容器管理命令，那么这里关于镜像的部分操作，类比 Management Commands 的特性，可以很容易的学习相应的命令。\n镜像存储中的核心概念仓库（Repository）是镜像存储的位置。Docker 注册服务器（Registry）是仓库存储的位置。每个仓库包含不同的镜像。\n比如一个镜像名称 ubuntu:14.04，冒号前面的 ubuntu 是仓库名，后面的 14.04 是 TAG，不同的 TAG 可以对应相同的镜像，TAG 通常设置为镜像的版本号。在前面的实验中，我们的镜像都没有加 TAG，这时 Docker 会使用默认的 TAG：latest。\nDocker Hub 是 Docker 官方提供的公共仓库，提供大量的常用镜像，由于国内网络原因经常连接 Docker Hub 会比较慢。\n并且 Docker 的镜像是分层存储，每一个镜像都是由很多层组成的。而一些镜像会共享一些相同的层。对于实验环境中的 docker 来说，其使用的存储驱动是 aufs，如下图所示：\n 图片中显示的是 aufs，但是对于如果是在自己的 Linux 环境下安装的 docker，其版本是高于 17.05，显示的有可能是 overlay2，其基本原理和 aufs 类似。\n aufs 是一种联合文件系统(UnionFS)，理解其原理对于我们理解 Docker 镜像有很大的帮助，有兴趣的同学可以尝试学习 Linux 文件系统之 aufs\n4.1 查看镜像列表 我们查看镜像可以使用如下命令：\n# Management Commands\r$ docker image ls\r# 旧的命令格式如下：\r$ docker images\r也可以查看指定仓库的镜像，例如。查看 ubuntu 仓库的镜像：\n$ docker image ls ubuntu\r4.2 查看镜像的详细信息 查看镜像的详细信息使用如下命令：\n# Management Commands\r$ docker image inspect ubuntu\r# 旧的命令格式如下：\r$ docker inspect ubuntu\r 注意：docker inspect 命令可以用来查看容器的信息，也可以用来查看镜像的信息\n 4.3 搜索镜像 $ docker search ubuntu\r这个命令会列出所有包含 ubuntu 关键字的镜像，结果如下图所示：\n4.4 拉取镜像 上面的内容中描述了仓库和注册表的内容，这里，我们学习从注册表中获得镜像或者仓库的命令，使用如下命令：\n# Management Commands\r$ docker image pull [OPTIONS] NAME[:TAG|@DIGEST]\r# 旧的命令格式如下：\r$ docker pull [OPTIONS] NAME[:TAG|@DIGEST]\r比较常用的配置参数为 -a，代表下载仓库中的所有镜像，即下载整个存储库。\n如下所示，我们下载 ubuntu:14.04 镜像，使用如下命令：\n$ docker image pull ubuntu:14.04\r对于 pull 下来的镜像来说，其默认的保存路径为 /var/lib/docker。因为这里的存储驱动为 aufs，所以具体路径为 /var/lib/docker/aufs。\n除了通过标签来拉取具体的镜像， 我们还可以通过摘要来拉取不同标签的镜像。从刚刚下载的结果，我们有一行 Digest 信息，这就是摘要信息。\n接下来我们简单演示一下通过摘要拉取镜像：首先删除刚刚下载的镜像 docker image rm ubuntu:14.04 （关于删除的命令会在本小节后面的部分详细讲述），此处以获取到的 Digest 为例，具体 Digest 参数应参照实际的值。\n4.5 构建镜像 commit 此时，对于我们 pull 的新镜像 ubuntu:14.04 来说，如果我们需要对其进行更新，可以创建一个容器，在容器中进行修改，然后将修改提交到一个新的镜像中。\n提交修改使用如下命令：\n# Management Commands\r$ docker container commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\r# 旧的命令格式如下：\r$ docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\r该命令的解释为从一个容器的修改中创建一个新的镜像。例如，我们运行一个容器，然后在其中创建一个文件，最后使用 commit 命令：\n# 使用 run 创建运行一个新命令\r$ docker container run \\\r --name shiyanlou001 \\\r -it busybox /bin/sh\r# 在运行的容器中创建两个文件，test1 和 test2\rtouch test1 test2\r# 使用 ctrl + p 及 ctrl+q 键退出\r# 使用提交命令，提交容器 shiyanlou001 的修改到镜像 busybox:test 中\r$ docker container commit shiyanlou001 busybox:test\r# 查看通过提交创建的镜像\r$ docker image ls busybox\r 通过上述操作我们创建了一个新的镜像，但是本方法不推荐用在生产系统中，未来会很难维护镜像。最好的创建镜像的方法是 Dockerfile，修改镜像的方法是修改 Dockerfile，然后重新从 Dockerfile 中构建新的镜像。\n BUILD docker 可以从一个 Dockerfile 文件中自动读取指令构建一个新的镜像。 Dockerfile 是一个包含用户构建镜像命令的文本文件。在 创建该文件后，我们可以使用如下命令构建镜像：\ndocker image build [OPTIONS] PATH | URL\r 构建镜像时，该过程的第一件事是将 Dockerfile 文件所在目录下的所有内容递归的发送到守护进程。所以在大多数情况下，最好是创建一个新的目录，在其中保存 Dockerfile，并在其中添加构建 Dockerfile 所需的文件。\n 对于一个 Dockerfile 文件内容来说，基本语法格式如下所示：\n# Comment\rINSTRUCTION arguments\r使用 # 号作为注释，指令（INSTRUCTION）不区分大小写，但是为了可读性，一般将其大写。而 Dockerfile 的指令一般包含下面几个部分：\n 基础镜像：以哪个镜像为基础进行制作，使用 FROM 指令来指定基础镜像，一个 Dockerfile 必须以 FROM 指令启动。 维护者信息：可以指定该 Dockerfile 编写人的姓名及邮箱，使用 MAINTAINER 指令。 镜像操作命令：对基础镜像要进行的改造命令，比如安装新的软件，进行哪些特殊配置等，常见的是 RUN 命令。 容器启动命令：基于该镜像的容器启动时需要执行哪些命令，常见的是 CMD 命令或 ENTRYPOINT  例如一个最基本的 Dockerfile：\n# 指定基础镜像\rFROM ubuntu:14.04\r# 维护者信息\rMAINTAINER shiyanlou/shiyanlou001@simplecloud.cn\r# 镜像操作命令\rRUN \\\rapt-get -yqq update \u0026amp;\u0026amp; \\\rapt-get install -yqq apache2\r# 容器启动命令\rCMD [\u0026quot;/usr/sbin/apache2ctl\u0026quot;, \u0026quot;-D\u0026quot;, \u0026quot;FOREGROUND\u0026quot;]\r通过阅读上述内容中我们熟悉的一些 linux 指令，可以很容易的得出该命令创建了一个 apache 的镜像。包含了最基本的四项信息。\n其中 FROM 指定基础镜像。RUN 命令默认使用 /bin/sh，并使用 root 权限执行。CMD 命令也是默认在 /bin/sh 中执行，但是只能有一条 CMD 指令，如果有多条则只有最后一条会被执行。\n下面我们创建一个空目录，并在其中编辑 Dockerfile 文件，并基于此构建一个新的镜像，使用如下操作：\n# 首先创建目录并切换目录\r$ mkdir /home/shiyanlou/test1 \u0026amp;\u0026amp; cd /home/shiyanlou/test1\r# 编辑 Dockerfile 文件，默认文件名为 `Dockerfile`，也可以使用其它值，使用其它值需要在构建时通过 `-f` 参数指定，这里我们使用默认值。并在其中添加上述示例的内容\r$ vim Dockerfile\r# 使用 build 命令，`-t` 参数指定新的镜像\r$ docker image build -t shiyanlou:1.0 .\r在执行构建命令后，需要花费一些时间来完成构建。在运行结束后，最后查看新创建的镜像：\n在构建完成后，我们可以使用该镜像启动一个容器来运行 apache 服务，运行如下命令：\n# 使用 -p 参数将本机的 8000 端口映射到容器中的 80 端口上。\r$ docker container run \\\r -d -p 8000:80 \\\r --restart=always \\\r --name shiyanlou002 shiyanlou:1.0\r 其中 --restart=always 选项保证容器始终不关闭，在本实验中如果不加此参数无法运行时，可以加上这个参数保证容器一直在运行。\n 此时，容器启动成功后，并且配置了端口映射，我们就可以通过本机的 8000 端口访问容器 shiyanlou002 中的 apache 服务了。我们打开浏览器，输入 localhost:8000，显示结果如下图：\n 如果 localhost:8000 无法访问，那么可以输入 127.0.0.1:8000。\n  更多有关于 Dockerfile 文件格式的信息可以参考官方文档 https://docs.docker.com/engine/reference/builder/\n 4.6 删除镜像 我们删除 ubuntu:latest 镜像就可以使用如下命令：\n# Management Commands\r$ docker image rm ubuntu:latest\r# 旧的命令格式如下：\r$ docker rmi ubuntu:latest\r需要注意的是，如果该镜像正在被一个容器所使用，需要将容器删除才能成功的删除镜像。\n5. 总结 本节实验中我们学习了以下内容：\n 查看镜像列表 查看镜像详细信息 搜索镜像 拉取镜像 构建镜像 删除镜像  请务必保证自己能够动手完成整个实验，只看文字很简单，真正操作的时候会遇到各种各样的问题，解决问题的过程才是收获的过程。\n存储管理 1. 课程说明 课程为纯动手实验教程，为了能说清楚实验中的一些操作会加入理论内容。理论内容我们不会写太多，已经有太多好文章了，会精选最值得读的文章推荐给你，在动手实践的同时扎实理论基础。\n实验环境中可以联网，不受实验楼网络限制。\n2. 学习方法 实验楼的 Docker 课程包含 14 个实验，每个实验都提供详细的步骤和截图，适用于有一定 Linux 系统基础，想快速上手 Docker 的同学。\n学习方法是多实践，多提问。启动实验后按照实验步骤逐步操作，同时理解每一步的详细内容。\n如果实验开始部分有推荐阅读的材料，请务必先阅读后再继续实验，理论知识是实践必要的基础。\n3. 本节内容简介 在本节内容中，我们将讨论 Docker 中管理数据的几种方式。\n本节中，我们需要依次完成下面几项任务：\n 使用 volumes 使用 bind mounts 使用 tmpfs 数据卷容器 数据卷的备份与恢复  对于 Docker 的镜像仓库来说，国内访问速度较慢，我们添加一个阿里云提供的 Docker 镜像加速器。\n首先，我们需要编辑 /etc/docker/daemon.json 文件：\n$ sudo vi /etc/docker/daemon.json\r然后加入如下内容：\n{\r\u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://n6syp70m.mirror.aliyuncs.com\u0026#34;]\r}\r修改之后，需要重启 docker 服务，让修改生效。使用如下命令：\n$ sudo service docker restart\r4. 存储 4.1 概述 通过之前的学习，我们学习了有关于容器和镜像的一些知识。对于数据来说，我们可以将其保存在容器中，但是会存在一些缺点：\n 当容器不再运行时，我们无法使用数据，并且容器被删除时，数据并不会被保存。 数据保存在容器中的可写层中，我们无法轻松的将数据移动到其他地方。  针对上述的缺点而言，有些数据信息，例如我们的数据库文件，我们不应该将其保存在镜像或者容器的可写层中。Docker 提供三种不同的方式将数据从 Docker 主机挂载到容器中，分别为卷（volumes），绑定挂载（bind mounts），临时文件系统（tmpfs）。很多时候，volumes 总是正确的选择。\n volumes， 卷存储在 Docker 管理的主机文件系统的一部分中（/var/lib/docker/volumes/） 中。完全由 Docker 管理 bind mounts， 绑定挂载，可以将主机上的文件或目录挂载到容器中 tmpfs， 仅存储在主机系统的内存中，而不会写入主机的文件系统  无论使用上述的哪一种方式，数据在容器内看上去都是一样的。它被认为容器文件系统中的目录或单个文件。\n4.2 卷列表 对于三种不同的存储数据的方式来说，卷是唯一完全由 Docker 管理的。它更容易备份或迁移，并且我们可以使用 Docker CLI 命令来管理卷。\n列出本地可用的卷列表可以使用如下命令：\n$ docker volume ls\r由于此时我们并未创建有相应的卷，所以显示为空。\n创建卷 创建卷我们可以直接使用如下命令：\n$ docker volume create\r上述命令会创建一个数据卷，并且会随机生成一个名称。创建之后我们可以查看卷列表：\n$ docker volume ls\r这种由系统随机生成名称的创建卷的方式被称为匿名卷，直接使用该卷需要指定卷名，即自动生成的 ID，所以创建卷时一般手动指定其 name，例如我们创建一个名为 volume1 的卷。\n$ docker volume create volume1\r用卷启动一个容器 创建卷之后，我们可以用卷来启动一个容器，这里首先需要学习 docker container run 命令的两个参数：\n -v 或 --volume  由三个由冒号（:）分隔的字段组成，[HOST-DIR:]CONTAINER-DIR[:OPTIONS]。 HOST-DIR 代表主机上的目录或数据卷的名字。省略该部分时，会自动创建一个匿名卷。如果是指定主机上的目录，需要使用绝对路径。 CONTAINER-DIR 代表将要挂载到容器中的目录或文件，即表现为容器中的某个目录或文件 OPTIONS 代表配置，例如设置为只读权限(ro)，此卷仅能被该容器使用（Z），或者可以被多个容器使用 （z）。多个配置项由逗号分隔。 例如，我们使用 -v volume1:/volume1:ro,z。代表的是意思是将卷 volume1 挂载到容器中的 /volume1 目录。ro,z 代表该卷被设置为只读（ro），并且可以多个容器使用该卷（z）   --mount  由多个键值对组成，键值对之间由逗号分隔。例如： type=volume,source=volume1,destination=/volume1,ro=true。 type，指定类型，可以指定为 bind，volume，tmpfs。 source，当类型为 volume 时，指定卷名称，匿名卷时省略该字段。当类型为 bind，指定路径。可以使用缩写 src。 destination，挂载到容器中的路径。可以使用缩写 dst 或 target。 ro 为配置项，多个配置项直接由逗号分隔一般使用 true 或 false。    针对上述创建的卷 volume1，用其来运行一个容器就可以使用如下命令：\n$ docker container run \\\r -it \\\r --name shiyanlou001 \\\r -v volume1:/volume1 \\\r --rm ubuntu /bin/bash\r或者我们也可以使用 --mount，其语法格式如下：\n$ docker container run \\\r -it --name shiyanlou002 \\\r --mount type=volume,src=volume1,target=/volume1 \\\r --rm ubuntu /bin/bash\r 从命令中，可以很明显的得出，--mount 的可读性更好。所以，推荐大家使用 --mount。\n  在 docker container run 中我们使用了参数 --rm，它的作用在容器退出时删除容器。这里我们创建的镜像只是希望它短期运行，其用户数据并无保留的必要，因而可以在容器启动时设置 \u0026ndash;rm 选项，这样在容器退出时就能够自动清理容器内部的文件系统。但自己使用时要注意：后台运行的容器无法使用此选项，即 -d 与 --rm 无法同时使用。\n 上述操作，我们分别运行了两个容器，并分别挂载了一个卷，还可多次使用该参数挂载多个卷或目录。并且对于这两个容器来说，由于我们使用的是同一个卷，所以他们将共享该数据卷，但是对于多个容器共享数据卷时，需要注意并发性。大家可以分别连接到两个容器中，操作数据，验证其是同步的，这里就不再详细演示了。\n4.3 bind-mounts 对于数据卷来说，其优点在于方便管理。而对于绑定挂载（bind-mounts）来说，通过将主机上的目录绑定到容器中，容器就可以操作和修改主机上该目录的内容。这既是其优点也是其缺点。\n例如，我们将 /home/shiyanlou 目录挂载到容器中的 /home/shiyanlou 目录下，使用的命令如下：\n$ docker container run \\\r -it \\\r -v /home/shiyanlou:/home/shiyanlou \\\r --name shiyanlou003 \\\r --rm ubuntu /bin/bash\r而如果使用的是 --mount，相应的语句如下：\n$ docker container run \\\r -it \\\r --mount type=bind,src=/home/shiyanlou,target=/home/shiyanlou \\\r --name shiyanlou004 \\\r --rm ubuntu /bin/bash\r 如果绑定挂载时指定的容器目录是非空的，则该目录中的内容将会被覆盖。并且如果主机上的目录不存在，会自动创建该目录。\n 上述两个操作针对的是目录，而对于挂载文件来说，可能会出现一些特殊情况，涉及到绑定挂载和使用卷的区别。下面我们重现这一操作：\n(1) 首先在当前目录，即 /home/shiyanlou 目录下，创建一个 test.txt 文件。并向其中写入文本内容 \u0026ldquo;test1\u0026rdquo;：\n$ echo \u0026#34;test1\u0026#34; \u0026gt; test.txt\r(2) 接着创建一个容器 shiyanlou005，将 test.txt 文件挂载到容器中的 /test.txt 文件，并查看容器中 /test.txt 文件的内容：\n$ docker container run \\\r -it \\\r -v /home/shiyanlou/test.txt:/test.txt \\\r --name shiyanlou005 ubuntu /bin/bash\r(3) 这时新打开一个终端，通过 echo 命令向 /home/shiyanlou/test.txt 文件追加内容 \u0026ldquo;test2\u0026rdquo;，并在容器中查看 /test.txt 文件的内容:\n$ echo \u0026#34;test2\u0026#34; \u0026gt;\u0026gt; test.txt\r(4) 这时无论是在容器中还是主机上都能查看到该文件的内容。接下来在主机上查看 test.txt 的 inode 号，并使用 vim 编辑该文件，添加 \u0026ldquo;test3\u0026rdquo;，并查看该文件的内容：\n如上图所示，在主机上使用 vim 编辑后，通过 vim 做出的修改不能在容器中查看到。这是因为 vim 编辑保存文件的时候，会将文件内容写入到一个新的文件中，保存好后，删除掉原来的文件，并将新文件重命名，从而完成保存的操作。但是我们标识文件是通过 inode，这在第一周的内容中有讲解到，因此 Docker 绑定的主机文件，依旧是 vim 编辑之前的 inode，即旧文件。所以容器中看到的，依然是旧的内容。\n对于数据卷来说，由 docker 完全管理，而绑定挂载，则需要我们自己去维护。我们需要自己手动去处理这些问题，这些问题并不仅仅是上面演示的内容，还可能有用户权限，SELINUX 等问题。\n4.4 tmpfs tmpfs 只存储在主机的内存中。当容器停止时，相应的数据就会被移除。\n$ docker run \\\r -it \\\r --mount type=tmpfs,target=/test \\\r --name shiyanlou008 \\\r --rm ubuntu bash\r5. 数据卷容器 如果容器之间需要共享一些持续更新的数据，最简单的方式就是使用用户数据卷容器。其他容器通过挂载这个容器实现数据共享，这个挂载数据卷的容器就叫做数据卷容器。数据卷容器就是一种普通容器，它专门提供数据卷供其它容器挂载使用。\n5.1 创建数据卷容器 首先，我们创建一个数据卷和数据卷容器，执行的命令如下：\n# 创建一个名为 vdata 的数据卷\r$ docker volume create vdata\r# 创建一个挂载了 vdata 的容器，这个容器就是数据卷容器\r$ docker container run \\\r -it \\\r -v vdata:/vdata --name ShiyanlouVolume ubuntu /bin/bash\r# 在 /vdata 目录下创建一个文本文件\r$ echo \u0026#34;I am ShiyanlouVolume\u0026#34; \u0026gt; /vdata/f.txt\r接下来我们分别打开新的终端输入以下命令，创建两个容器，在执行 docker container run 时，我们添加参数 --volumes-from 继承数据卷容器 ShiyanlouVolume 挂载的数据卷。进入容器后分别创建文件\n# 创建容器 test1\r$ docker container run \\\r -it \\\r --volumes-from ShiyanlouVolume \\\r --name test1 ubuntu /bin/bash\r# 查看 vdata 目录是否存在\r$ ls -dl /vdata/\r# 创建一个文件，并写入内容\r$ echo \u0026#34;I am test1\u0026#34; \u0026gt; /vdata/test1.txt\r同样的，我们执行上述操作，创建容器 test2。\n# 创建容器 test2\r$ docker container run \\\r -it \\\r --volumes-from ShiyanlouVolume \\\r --name test2 ubuntu /bin/bash\r# 查看 vdata 目录是否存在\r$ ls -dl /vdata/\r# 创建一个文件，并写入内容\r$ echo \u0026#34;I am test2\u0026#34; \u0026gt; /vdata/test2.txt\r我们进入到 ShiyanlouVolume 容器所在的终端，在挂载的数据中查看文件的内容：\n# 查看数据卷中的内容\r$ ls -al /vdata/\r从上图的结果中我们可以看到，数据卷在三个容器之间是共享的。\n5.2 数据备份 数据存在于数据卷中，如果我们想要备份它，可以采用创建备份容器的方式。\n$ docker container run \\\r --volumes-from ShiyanlouVolume \\\r -v /home/shiyanlou/backup:/backup \\\r ubuntu tar cvf /backup/backup.tar /vdata/\r--volumes-from ShiyanlouVolume 使得备份容器继承容器 ShiyanlouVolume 的数据卷。\n-v /home/shiyanlou/backup:/backup 把 /home/shiyanlou/backup 目录采用绑定挂载的方式，挂载到容器的 /backup 目录上。\ntar cvf /backup/backup.tar /vdata 容器中执行了这么一条压缩归档命令，将 /vdata 中的全部数据打包到了 /backup/backup.tar，而刚刚的数据绑定，使得整个压缩包存在于主机中，从而达到了数据备份的效果。\n如上图所示，数据卷中的所有数据都被打包到了 /home/shiyanlou/backup 目录中。\n5.3 数据恢复 与数据备份相同的方式，我们可以使用如下命令创建恢复容器，来还原数据卷中的数据。\n$ docker container run \\\r --volumes-from ShiyanlouVolume \\\r -v /home/shiyanlou/backup:/backup \\\r ubuntu tar xvf /backup/backup.tar -C /\r 这里解压的路径为 / 即 /vdata 的上一级目录。\n 由于与数据备份非常相似，这里不再给出结果分析。\n6. 总结 本节实验主要使用三种不同的方式将数据从 Docker 主机挂载到容器中，分别为卷（volumes），绑定挂载（bind mounts），临时文件系统（tmpfs）。还介绍了数据卷容器、数据卷的备份与恢复。\n请务必保证自己能够动手完成整个实验，只看文字很简单，真正操作的时候会遇到各种各样的问题，解决问题的过程才是收获的过程。\n网络管理 1. 课程说明 课程为纯动手实验教程，为了能说清楚实验中的一些操作会加入理论内容。理论内容我们不会写太多，已经有太多好文章了，会精选最值得读的文章推荐给你，在动手实践的同时扎实理论基础。\n实验环境中可以联网，不受实验楼网络限制。\n2. 学习方法 实验楼的 Docker 课程包含 14 个实验，每个实验都提供详细的步骤和截图，适用于有一定 Linux 系统基础，想快速上手 Docker 的同学。\n学习方法是多实践，多提问。启动实验后按照实验步骤逐步操作，同时理解每一步的详细内容。\n如果实验开始部分有推荐阅读的材料，请务必先阅读后再继续实验，理论知识是实践必要的基础。\n3. 本节内容简介 本节中，我们需要依次完成下面几项任务：\n docker 容器端口映射 自定义网络实现容器互联 host 和 none 网络的使用  对于 Docker 的镜像仓库来说，国内访问速度较慢，我们添加一个阿里云提供的 Docker 镜像加速器。\n首先，我们需要编辑 /etc/docker/daemon.json 文件：\n$ sudo vi /etc/docker/daemon.json\r然后加入如下内容：\n{\r\u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://n6syp70m.mirror.aliyuncs.com\u0026#34;]\r}\r修改之后，需要重启 docker 服务，让修改生效。使用如下命令：\n$ sudo service docker restart\r4. 网络  在开始下面的内容之前，为了不出现命名上的冲突，也为了显示更为直观并且方便演示示例，首先需要将前面创建或启动的容器全部删除。可以使用下面两条命令达到这一效果：\n # 暂停所有运行中的容器\r$ docker container ls -q | xargs docker container stop\r# 删除所有的容器\r$ docker container ls -aq | xargs docker container rm\r在我们安装 Docker 后，会自动创建三个网络。我们可以使用下面的命令来查看这些网络：\n$ docker network ls\r如上图所示，三种默认的网络，分别为 bridge，host，none。\n4.1 bridge bridge，即桥接网络，在安装 docker 后会创建一个桥接网络，该桥接网络的名称为 docker0。我们可以通过下面两条命令去查看该值。\n# 查看 bridge 网络的详细信息，并通过 grep 获取名称项\r$ docker network inspect bridge | grep name\r# 使用 ifconfig 查看 docker0 网络\r$ ifconfig\r在上图中，我们可以查看到对应的值。默认情况下，我们创建一个新的容器都会自动连接到 bridge 网络。使用 docker network inspect bridge 查看网桥网络的详细信息，结果如下所示：\n可以看到 docker0 的默认网段是 192.168.0.0/20。\n我们可以尝试创建一个容器，该容器会自动连接到 bridge 网络，例如我们创建一个名为 shiyanlou001 的容器：\n$ docker container run \\\r --name shiyanlou001 \\\r -itd ubuntu /bin/bash\r# 上述命令中默认使用 --network bridge ，即指定 bridge 网络\r# 与下面的命令等同\r$ docker container run \\\r --name shiyanlou001 \\\r --network bridge \\\r -itd ubuntu /bin/bash\r创建后，再次查看 bridge 的信息：\n这时可以查看到相应的容器的网络信息，该容器在连接到 bridge 网络后，会从子网的地址池中获得一个 IP 地址，即上图中的 192.168.0.2。\n使用 docker container attach shiyanlou001 命令，也可查看相应的地址信息：\n 如果提示没有找到 ifconifg 命令，可以通过如下命令安装：\n$ sudo apt update\r$ sudo apt install net-tools\r 并且对于连接到默认的 bridge 之间的容器可以通过 IP 地址互相通信。例如我们启动一个 shiyanlou002 的容器，它可以与 shiyanlou001 通过 IP 地址进行通信。\n 如果提示没有找到 ping 命令，可使用如下命令安装：\n$ sudo apt update $ sudo apt install iputils-ping\r其具体的实现原理可以参考链接 Linux 上的基础网络设备，以及涉及到网桥的工作原理\n 上述的操作我们通过 ping 命令演示了 IP 相关的内容。但是对于应用程序来讲，如果需要在外部进行访问，我们还会涉及到端口的使用，而 Docker 对于 bridge 网络使用端口的方式为设置端口映射，通过 iptables 实现。\n下面我们通过 iptables 来为大家演示 docker 实现端口映射的方式，主要针对 nat 表和 filter 表：\n(1) 首先删除掉上面创建的两个容器。这里不再给出具体的命令\n(2) 这时，我们查看 nat 表的转发规则，使用如下命令：\n$ sudo iptables -t nat -nvL\r(3) 由于此时并未创建 docker 容器，nat 表中没有什么特殊的规则。接下来，我们使用实验 03 - Docker 镜像管理中构建的 shiyanlou:1.0 镜像创建一个容器 shiyanlou001，并将本机的端口 10001 映射到容器中的 80 端口上，在浏览器中可以通过 localhost:10001 访问容器 shiyanlou001 的 apache 服务，命令如下：\n$ docker run -d -p 10001:80 --name shiyanlou001 shiyanlou:1.0\r 其中 docker container run 命令的 -p 参数是通过端口映射的方式，将容器的端口发布到主机的端口上。其使用格式为 -p ip:hostPort:containerPort。并且还可以指定范围，例如 -p 10001-10100:1-100，代表将容器 1-100 的端口映射到主机上的 10001-10100端口上，两者一一对应。\n 构建镜像 shiyanlou:1.0 的 DockerFile 如下，具体的构建过程请参考实验 03 的文档：\n# 指定基础镜像\rFROMubuntu:14.04\r\r# 维护者信息\rMAINTAINERshiyanlou/shiyanlou001@simplecloud.cn\r\r# 镜像操作命令\rRUN \\\r apt-get -yqq update \u0026amp;\u0026amp; \\\r apt-get install -yqq apache2\r\r# 容器启动命令\rCMD [\u0026#34;/usr/sbin/apache2ctl\u0026#34;, \u0026#34;-D\u0026#34;, \u0026#34;FOREGROUND\u0026#34;]\r\r(4) 创建成功后，我们可以在浏览器中输入 localhost:10001 访问到容器 shiyanlou001 的 apache 服务，并查看此时 iptables 中 nat 表和 filter 表的规则，其中分别新增了一条比较重要的内容，如下图所示：\n(5) 接下来，再次使用镜像 shiyanlou:1.0 来启动一个容器 shiyanlou002，这次我们不指定端口映射，通过手动修改 nat 表的方式来模拟实现：\n$ docker run -d --name shiyanlou002 shiyanlou:1.0\r(6) 获取容器 shiyanlou002 的 ip 地址，如果按步骤操作此 ip 为 192.168.0.3。此时我们想通过主机的 10002 端口访问容器 shiyanlou002 的 80 端口，就可以添加一条规则：\n# 添加一条规则，大致解释为将从非 docker0 接口上，目的端口为 10002 的 tcp 报文，修改其目的地址为 192.168.0.3:80\r$ sudo iptables -t nat -A DOCKER ! -i docker0 -p tcp --dport 10002 -j DNAT --to-destination 192.168.0.3:80\r(7) 添加成功后我们在主机发出的本地公网或内网 ip 加端口号 10002 的请求会被定位到 192.168.0.3:80 上，但是在将请求转发到 docker0 网桥上时，对于默认的 filter 表中的 FORWARD 链的规则是 DROP，因此我们还需要在 filter 表中设置相应的规则：\n$ sudo iptables -t filter -A FORWARD ! -i docker0 -o docker0 -p tcp -d 192.168.0.3 -j ACCEPT --dport 80\r# 或者你也可以选择将其加到由 docker 定义的 DOCKER 链中，上面的命令和下面的命令选择其中的一个即可\r$ sudo iptables -t filter -A DOCKER ! -i docker0 -o docker0 -p tcp -d 192.168.0.3 -j ACCEPT --dport 80\r(8) 此时我们就能够通过 localhost:10002 访问容器 shiyanlou002 中的 apache 服务了。 即通过 iptables 的方式实现了容器 shiyanlou002 上 80 端口到主机 10002 端口的映射。\n(9) 最后，为了不影响后面实验的进行，这里我们删除掉手动添加的规则，并删除容器。\n删除手动添加的规则可使用如下方法：\n#查看 nat 规则\r$ sudo iptables -t nat -nvL --line-numbers\r#比如删除 DOCKER 链的第 2 条规则\r$ sudo iptables -t nat -D DOCKER 2\r#查看 filter 规则\r$ sudo iptables -nvL --line-numbers\r#比如删除 DOCKER 链第 1 条规则\r$ sudo iptables -D DOCKER 1\r因为每个环境都不同，具体删除第几条规则，应查看规则后再删除。\n4.2 自定义网络 对于默认的 bridge 网络来说，使用端口可以通过端口映射的方式来实现，并且在上面的内容中我们也演示了容器之间通过 IP 地址互相进行通信。但是对于默认的 bridge 网络来说，每次重启容器，容器的 IP 地址都是会发生变化的，因为对于默认的 bridge 网络来说，并不能在启动容器的时候指定 ip 地址，在启动单个容器时并不容易看到这一区别。\n旧版的容器互联 容器间都是通过在 /etc/hosts 文件中添加相应的解析，通过容器名，别名，服务名等来识别需要通信的容器。\n这里，我们启动两个容器，来演示旧的容器互联：\n(1) 首先启动一个名为 shiyanlou001 的容器，使用镜像 busybox：\n$ docker run -it --rm --name shiyanlou001 busybox /bin/sh\r(2) 这时打开一个新的终端，启动一个名为 shiyanlou002 的容器，并使用 --link 参数与容器 shiyanlou001 互联。\n$ docker run -it --rm --name shiyanlou002 --link shiyanlou001 busybox /bin/sh\r docker run 命令的 --link 参数的格式为 --link :alias。格式中的 name 为容器名，alias 为别名。即可以通过 alias 访问到该容器。\n 如下图所示，左侧为 shiyanlou001，右侧为 shiyanlou002：\n(3) 如果此时 shiyanlou001 容器退出，这时我们启动一个 shiyanlou003，再次启动一个 shiyanlou001：\n$ docker run -itd --name shiyanlou003 --rm busybox /bin/sh\r$ docker run -it --name shiyanlou001 --rm busybox /bin/sh\r按照顺序分配的原则，此时 shiyanlou003 的 IP 地址为 192.168.0.2，容器 shiyanlou001 的 IP 地址为 192.168.0.4。并且此时容器 shiyanlou002 中 /etc/hosts 文件的解析依旧不变，所以不能获取到正确的解析：\n如上所示，旧的容器 shiyanlou002 通过 --link 连接到 shiyanlou001。而在 shiyanlou001 重启后，由于 IP 地址的变化，此时 shiyanlou002 并不能正确的访问到 shiyanlou001。\n除了使用 --link 链接的方式来达到容器间互联的效果，在 docker 中，容器间的通信更应该使用的是自定义网络。\n自定义网络 docker 在安装时会默认创建一个桥接网络，除了使用默认网络之外，我们还可以创建自己的 bridge 或 overlay 网络。\n如下所示，我们创建一个名为 network1 的桥接网络，简单命令如下：\n$ docker network create network1\r$ docker network ls\r创建成功后，可以使用 ifconfig 或者 ip addr show 命令查看该桥接网络的网络接口信息，如下所示：\n而对于该网络的详细信息可以通过 docker network inspect network1 命令来查看，如下图所示：\n其相应的网络接口名称和子网都是由 docker 随机生成，当然，我们也可以手动指定：\n# 首先删除掉刚刚创建的 network1 $ docker network rm network1\r# 再次创建 network1，指定子网\r$ docker network create -d bridge --subnet=192.168.16.0/24 --gateway=192.168.16.1 network1\r此时，我们可以运行一个容器 shiyanlou001，指定其网络为 network1，使用 --network network1：\n$ docker run -it --name shiyanlou001 --network network1 --rm busybox /bin/sh\r使用 exit 退出该容器使其自动删除，这时我们再次创建该容器，但是不指定其 --network：\n$ docker run -it --name shiyanlou001 --rm busybox /bin/sh\r此时，该容器连接到默认的 bridge 网络，这时，可以新打开一个终端，在其中运行如下命令，将 shiyanlou001 连接到 network1 网络中：\n# 在新打开的终端中运行，将容器 shiyanlou001 连接到 network1 网络中\r$ docker network connect network1 shiyanlou001\r# 这时再次在容器 `shiyanlou001` 中使用 `ifconfig` 命令\r如上图中所示，出现了一个 eth1 接口，此时，eth0 连接到默认的 bridge 网络，eth1 连接到 network1 网络。\n对于自定义的网络来说，docker 嵌入的 DNS 服务支持连接到该网络的容器名的解析。这意味着连接到同一个网络的容器都可以通过容器名去 ping 另一个容器。\n如下所示，启动两个容器，连接到 network1：\n$ docker run -itd --name shiyanlou_1 --network network1 --rm busybox /bin/sh\r$ docker run -it --name shiyanlou_2 --network network1 --rm busybox /bin/sh\r启动之后，由于上述的两个容器都是连接到 network1 网络，所以可以通过容器名 ping 通：\n除此之外，在用户自定义的网络中，是可以通过 --ip 指定 IP 地址的，而在默认的 bridge 网络不能指定 IP 地址：\n# 连接到 network1 网络，运行成功\r$ docker run -it --network network1 --ip 192.168.16.100 --rm busybox /bin/sh\r# 连接到默认的 bridge 网络，下面的命令运行失败\r$ docker run -it --rm busybox --ip 192.168.0.100 --rm busybox /bin/sh\r4.3 host 和 none host 网络，容器可以直接访问主机上的网络。\n例如，我们启动一个容器，指定网络为 host：\n$ docker run -it --network host --rm busybox /bin/sh\r如下所示，该容器可以直接访问主机上的网络：\nnone 网络，容器中不提供其它网络接口。none 网络的容器创建之后还可以自己 connect 一个网络，比如使用 docker network connet bridge 容器名 可以将这个容器添加到 bridge 网络中。\n$ docker run -it --nerwork none --rm busybox /bin/sh\r5. 总结 本节实验中我们学习了以下内容：\n docker 容器端口映射 自定义网络实现容器互联 host 和 none 网络的使用  请务必保证自己能够动手完成整个实验，只看文字很简单，真正操作的时候会遇到各种各样的问题，解决问题的过程才是收获的过程。\n编写 Dockerfile 1. 课程说明 课程为纯动手实验教程，为了能说清楚实验中的一些操作会加入理论内容。理论内容我们不会写太多，已经有太多好文章了，会精选最值得读的文章推荐给你，在动手实践的同时扎实理论基础。\n实验环境中可以联网，不受实验楼网络限制。\n2. 学习方法 实验楼的 Docker 课程包含 14 个实验，每个实验都提供详细的步骤和截图，适用于有一定 Linux 系统基础，想快速上手 Docker 的同学。\n学习方法是多实践，多提问。启动实验后按照实验步骤逐步操作，同时理解每一步的详细内容。\n如果实验开始部分有推荐阅读的材料，请务必先阅读后再继续实验，理论知识是实践必要的基础。\n3. 本节内容简介 在前面的实验中我们多次用到的 Dockerfile，在本实验里我们将通过完成一个实例来学习 Dockerfile 的编写。\n本节中，我们需要依次完成下面几项任务：\n Dockerfile 基本语法 Dockerfile 创建镜像流程  对于 Docker 的镜像仓库来说，国内访问速度较慢，我们添加一个阿里云提供的 Docker 镜像加速器。\n首先，我们需要编辑 /etc/docker/daemon.json 文件：\n$ sudo vi /etc/docker/daemon.json\r然后加入如下内容：\n{\r\u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://n6syp70m.mirror.aliyuncs.com\u0026#34;]\r}\r修改之后，需要重启 docker 服务，让修改生效。使用如下命令：\n$ sudo service docker restart\r4. Dockerfile Dockerfile 是一个文本文件，其中包含我们为了构建 Docker 镜像而手动执行的所有命令。Docker 可以从 Dockerfile 中读取指令来自动构建镜像。我们可以使用 docker build 命令来创建一个自动构建。\n4.1 上下文 在 Docker 容器及镜像管理一节中我们有提到构建镜像的一些知识。\n构建镜像时，该过程的第一件事是将 Dockerfile 文件所在目录下的所有内容递归的发送到守护进程。所以在大多数情况下，最好是创建一个新的目录，在其中保存 Dockerfile，并在其中添加构建 Dockerfile 所需的文件。而 Dockerfile 文件所在的路径也被称为上下文（context）。\n首先创建一个目录，以便开始后面的实验过程：\n$ mkdir dir1 \u0026amp;\u0026amp; cd dir1\r下面我们简单介绍 Dockerfile 中常用的指令。\n4.2 FROM 使用 FROM 指令指定一个基础镜像，后续指令将在此镜像的基础上运行：\nFROM ubuntu:14.04\r4.3 USER 在 Dockerfile 中可以指定一个用户，后续的 RUN，CMD 以及 ENTRYPOINT 指令都会使用该用户去执行，但是该用户必须提前存在。\nUSER shiyanlou\r4.4 WORKDIR 除了指定用户之外，还可以使用 WORKDIR 指定工作目录，对于 RUN，CMD，COPY，ADD 指令将会在指定的工作目录中去执行。也可以理解为命令执行时的当前目录。\nWORKDIR /\r4.5 RUN，CMD，ENTRYPOINT RUN 指令用于执行命令，该指令有两种形式：\n RUN ，使用 shell 去执行指定的命令 command，一般默认的 shell 为 /bin/sh -c。 RUN [\u0026quot;executable\u0026quot;, \u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;, ...]，使用可执行的文件或程序 executable，给予相应的参数 param。  例如我们执行更新命令：\nRUN apt-get update\rCMD 的使用方式跟 RUN 类似，不过在一个 Dockerfile 文件中只能有一个 CMD 指令，如果有多个 CMD 指令，则只有最后一个会生效。该指令为我们运行容器时提供默认的命令，例如：\nCMD echo \u0026quot;hello shiyanlou\u0026quot;\r在构建镜像时使用了上面的 CMD 指令，则可以直接使用 docker run image，该命令等同于 docker run image echo \u0026quot;hello shiyanlou\u0026quot;。即作为默认执行容器时默认使用的命令，也可在 docker run 中指定需要运行的命令来覆盖默认的 CMD 指令。\n除此之外，该指令还有一种特殊的用法，在 Dockerfile 中，如果使用了 ENTRYPOINT 指令，则 CMD 指令的值会作为 ENTRYPOINT 指令的参数：\nCMD [\u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;]\rENTRYPOINT 指令会覆盖 CMD 指令作为容器运行时的默认指令，并且不会在 docker run 时被覆盖，如下示例：\nFROM ubuntu:latest\rENTRYPOINT [\u0026quot;ls\u0026quot;, \u0026quot;-a\u0026quot;]\rCMD [\u0026quot;-l\u0026quot;]\r上述构建的镜像，在我们使用 docker run  时等同于 docker run ls -a -l 命令。使用 docker run -i -s 命令等同于 docker run ls -a -i -s 指令。即 CMD 指令的值会被当作 ENTRYPOINT 指令的参数附加到 ENTRYPOINT 指令的后面，并且如果 docker run 中指定了参数，会覆盖 CMD 中给出的参数。\n4.6 COPY 和 ADD COPY 和 ADD 都用于将文件，目录等复制到镜像中。使用方式如下：\nADD \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt;\rADD [\u0026quot;\u0026lt;SRC\u0026gt;\u0026quot;,... \u0026quot;\u0026lt;dest\u0026gt;\u0026quot;]\rCOPY \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt;\rCOPY [\u0026quot;\u0026lt;src\u0026gt;\u0026quot;,... \u0026quot;\u0026lt;dest\u0026gt;\u0026quot;]\r`` 可以指定多个，但是其路径不能超出上下文的路径，即必须在跟 Dockerfile 同级或子目录中。\n不需要预先存在，不存在路径时会自动创建，如果没有使用绝对路径，则 为相对于工作目录的相对路径。\nCOPY 和 ADD 的不同之处在于，ADD 可以添加远程路径的文件，并且 `` 为可识别的压缩格式，如 gzip 或 tar 归档文件等，ADD 会自动将其解压缩为目录。\n4.7 ENV ENV 指令用于设置环境变量：\nENV \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;\rENV \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt;...\r4.8 VOLUME VOLUME 指令将会创建指定的挂载目录，在容器运行时，将创建相应的匿名卷：\nVOLUME /data1 /data2\r上述指令将会在容器运行时，创建两个匿名卷，并挂载到容器中的 /data1 和 /data2 目录上。\n4.9 EXPOSE EXPOSE 指定在容器运行时监听指定的网络端口，它与 docker run 命令的 -p 参数不一样，并不实际映射端口，只是将该端口暴露出来，允许外部或其它的容器进行访问。\n要将容器端口暴露出来，需要在 dcoker run 命令中使用 -p 或者 --publish 参数。如果采用 -P 随机映射端口的方式，Docker 会将在 DockerFile 中声明的所有 EXPOSE 的端口随机映射。\nEXPOSE port\r5. 从 Dockerfile 创建镜像 了解了上面一些常用于构建 Dockerfile 的指令之后，可以通过这些指令来构建一个镜像，如下所示，搭建一个 ssh 服务:\n# 指定基础镜像\rFROM ubuntu:14.04\r# 安装软件\rRUN apt-get update \u0026amp;\u0026amp; apt-get install -y openssh-server \u0026amp;\u0026amp; mkdir /var/run/sshd\r# 添加用户 shiyanlou 及设定密码\rRUN useradd -g root -G sudo shiyanlou \u0026amp;\u0026amp; echo \u0026quot;shiyanlou:123456\u0026quot; | chpasswd shiyanlou\rEXPOSE 22\rCMD [\u0026quot;/usr/sbin/sshd\u0026quot;, \u0026quot;-D\u0026quot;]\r首先，我们在之前创建的一个空目录 dir1 中编辑 Dockerfile 文件，并将上面的内容复制到该文件中，相关的命令如下所示：\n# 创建目录\r$ mkdir dir1 \u0026amp;\u0026amp; cd dir1\r# 编辑 Dockerfile，将上面的内容写入\r$ vim Dockerfile\r# 最后执行构建命令\r$ docker build -t sshd:test .\r在上面的命令执行完成之后，该镜像就构建成功了，直接使用该镜像启动一个容器就可以运行一个 ssh 的服务，如下所示：\n$ docker run -itd -p 10001:22 sshd:test\r这时就可以通过公网的 IP 地址，以及端口 10001，并且使用用户 shiyanlou，密码 123456，远程通过 ssh 连接到该容器中了。\n这里我们使用回环地址来进行测试，即自己请求自己的 ssh 连接。\n首先安装 openssh 客户端，对应的命令为 apt-get install openssh-client。然后连接本机的 ssh-server，使用的命令为 ssh -p 10001 shiyanlou@127.0.0.1，这里的 -p 10001 即使用端口 10001，也就是我们刚刚映射的端口。\n实验的结果如下图，可以看到，我们成功连接到了容器。\n6. 总结 本节实验中我们学习了以下内容：\n Dockerfile 基本语法 Dockerfile 创建镜像流程  请务必保证自己能够动手完成整个实验，只看文字很简单，真正操作的时候会遇到各种各样的问题，解决问题的过程才是收获的过程。\n使用 Docker 运行 MongoDB 和 Redis 1. 课程说明 课程为纯动手实验教程，为了能说清楚实验中的一些操作会加入理论内容。理论内容我们不会写太多，已经有太多好文章了，会精选最值得读的文章推荐给你，在动手实践的同时扎实理论基础。\n实验环境中可以联网，不受实验楼网络限制。\n2. 学习方法 实验楼的 Docker 课程包含 14 个实验，每个实验都提供详细的步骤和截图，适用于有一定 Linux 系统基础，想快速上手 Docker 的同学。\n学习方法是多实践，多提问。启动实验后按照实验步骤逐步操作，同时理解每一步的详细内容。\n如果实验开始部分有推荐阅读的材料，请务必先阅读后再继续实验，理论知识是实践必要的基础。\n3. 本节内容简介 在本实验里我们将通过完成 MongoDB 和 Redis 两个容器来学习 Dockerfile 及 Docker 的运行机制。\n本节中，我们需要依次完成下面几项任务：\n MongoDB 的安装及配置 Redis 的安装及配置 Dockerfile 的编写 从 Dockerfile 构建镜像  本次实验的需求是完成 Dockerfile，通过 Dockerfile 创建 MongoDB 或 Redis 应用。Dockerhub 上已经提供了官方的 MongoDB 和 Redis 镜像，本实验仅仅用于学习 Dockerfile 及 Docker 机制。\n MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。特点是高性能、易部署、易使用，存储数据非常方便。 -来自百度百科\n  Redis 是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。 -来自百度百科\n 对于 Docker 的镜像仓库来说，国内访问速度较慢，我们添加一个阿里云提供的 Docker 镜像加速器。\n首先，我们需要编辑 /etc/docker/daemon.json 文件：\n$ sudo vi /etc/docker/daemon.json\r然后加入如下内容：\n{\r\u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://n6syp70m.mirror.aliyuncs.com\u0026#34;]\r}\r修改之后，需要重启 docker 服务，让修改生效。使用如下命令：\n$ sudo service docker restart\r4. 实验准备 4.1 实验分析 在本实验中，我们除了安装所需的核心服务外，还安装一个 ssh 服务提供便捷的管理。\n为了提高 docker build 速度，我们直接使用阿里云的 Ubuntu 源。因此要在 Dockerfile 开始位置增加下面一句命令：\nRUN echo \u0026quot;deb http://mirrors.cloud.aliyuncs.com/ubuntu/ trusty main universe\u0026quot; \u0026gt; /etc/apt/sources.list\r4.2 创建 Dockerfile 文件 首先，需要创建一个目录来存放 Dockerfile 文件，目录名称可以任意，在目录里创建 Dockerfile 文件：\n$ cd /home/shiyanlou\r$ mkdir shiyanloumongodb shiyanlouredis\r$ touch shiyanloumongodb/Dockerfile shiyanlouredis/Dockerfile\r使用 vim/gedit 编辑 Dockerfile 文件，根据我们的需求输入内容。\n5. Dockerfile 基本框架 5.1 基本框架 按照上一节学习的内容，我们先完成 Dockerfile 基本框架。\n依次输入下面的基本框架内容：\n# Version 0.1\r\r# 基础镜像\rFROMubuntu:14.04\r\r# 维护者信息\rMAINTAINERshiyanlou@shiyanlou.com\r\r# 镜像操作命令\rRUN echo \u0026#34;deb http://mirrors.cloud.aliyuncs.com/ubuntu/ trusty main universe\u0026#34; \u0026gt; /etc/apt/sources.list\rRUN apt-get update \u0026amp;\u0026amp; apt-get install -yqq supervisor \u0026amp;\u0026amp; apt-get clean\r\r# 容器启动命令\rCMD [\u0026#34;supervisord\u0026#34;]\r\r上面的 Dockerfile 创建了一个简单的镜像，并使用 Supervisord 启动服务。\n5.2 安装 SSH 服务 首先安装所需要的软件包：\nRUN apt-get install -yqq openssh-server openssh-client\r\r创建运行目录：\nRUN mkdir -p /var/run/sshd\r\r设置 root 密码及允许 root 通过 ssh 登录：\nRUN echo \u0026#39;root:shiyanlou\u0026#39; | chpasswd\rRUN sed -i \u0026#39;s/PermitRootLogin without-password/PermitRootLogin yes/\u0026#39; /etc/ssh/sshd_config\r\r6. 完成 MongoDB Dockerfile 在上述基本的架构下，我们根据需求可以增加新的内容到 Dockerfile 中，完成 MongoDB Dockerfile。\n进入到 shiyanloumongodb 的目录编辑 Dockerfile：\n$ cd /home/shiyanlou/shiyanloumongodb/\r$ vim Dockerfile\r6.1 安装最新的 MongoDB 在 Ubuntu 最新版本下安装 MongoDB 非常简单，参考 MongoDB 安装文档 。有两种方法：\n方法一是添加 mongodb 的源，执行 apt-get install mongodb-org 就可以安装下面的所有软件包：\n mongodb-org-server：mongod 服务和配置文件 mongodb-org-mongos：mongos 服务 mongodb-org-shell：mongo shell 工具 mongodb-org-tools：mongodump，mongoexport 等工具  方法二是下载二进制包，然后解压出来就可以。\n由于 MongoDB 的官网连接网速问题，我们使用第二种方案，并把最新的 MongoDB 的包放到阿里云上。\nMongoDB 的下载链接如下：\nhttp://labfile.oss-cn-hangzhou-internal.aliyuncs.com/courses/498/mongodb-linux-x86_64-ubuntu1404-3.2.3.tgz\r 下载链接较长，建议保存到工具栏中的剪切板，在云主机中复制即可。\n 我们完善 Dockerfile，使用 ADD 命令添加压缩包到镜像：\nRUN mkdir -p /opt\rADD http://labfile.oss-cn-hangzhou-internal.aliyuncs.com/courses/498/mongodb-linux-x86_64-ubuntu1404-3.2.3.tgz /opt/mongodb.tar.gz\rRUN cd /opt \u0026amp;\u0026amp; tar zxvf mongodb.tar.gz \u0026amp;\u0026amp; rm -rf mongodb.tar.gz\rRUN mv /opt/mongodb-linux-x86_64-ubuntu1404-3.2.3 /opt/mongodb\r\r创建 MongoDB 的数据存储目录：\nRUN mkdir -p /data/db\r\r将 MongoDB 的执行路径添加到环境变量里：\nENV PATH=/opt/mongodb/bin:$PATH\r\rMongoDB 和 SSH 对外的端口：\nEXPOSE27017 22\r\r6.2 编写Supervisord配置文件 添加 Supervisord 配置文件来启动 mongodb 和 ssh，创建文件/home/shiyanlou/shiyanloumongodb/supervisord.conf，添加以下内容：\n[supervisord]\rnodaemon=true\r[program:mongodb]\rcommand=/opt/mongodb/bin/mongod\r[program:ssh]\rcommand=/usr/sbin/sshd -D\rDockerfile 中增加向镜像内拷贝该文件的命令：\nCOPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf\r\r6.3 完整的 Dockerfile # Version 0.1\r\r# 基础镜像\rFROMubuntu:14.04\r\r# 维护者信息\rMAINTAINERshiyanlou@shiyanlou.com\r\r# 镜像操作命令\rRUN echo \u0026#34;deb http://mirrors.cloud.aliyuncs.com/ubuntu/ trusty main universe\u0026#34; \u0026gt; /etc/apt/sources.list\rRUN apt-get -yqq update \u0026amp;\u0026amp; apt-get install -yqq supervisor\rRUN apt-get install -yqq openssh-server openssh-client\r\rRUN mkdir /var/run/sshd\rRUN echo \u0026#39;root:shiyanlou\u0026#39; | chpasswd\rRUN sed -i \u0026#39;s/PermitRootLogin without-password/PermitRootLogin yes/\u0026#39; /etc/ssh/sshd_config\r\rRUN mkdir -p /opt\rADD http://labfile.oss-cn-hangzhou-internal.aliyuncs.com/courses/498/mongodb-linux-x86_64-ubuntu1404-3.2.3.tgz /opt/mongodb.tar.gz\rRUN cd /opt \u0026amp;\u0026amp; tar zxvf mongodb.tar.gz \u0026amp;\u0026amp; rm -rf mongodb.tar.gz\rRUN mv /opt/mongodb-linux-x86_64-ubuntu1404-3.2.3 /opt/mongodb\r\rRUN mkdir -p /data/db\r\rENV PATH=/opt/mongodb/bin:$PATH\r\rCOPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf\r\rEXPOSE27017 22\r\r# 容器启动命令\rCMD [\u0026#34;supervisord\u0026#34;]\r\r7. 完成 Redis Dockerfile 在上述基本的架构下，我们根据需求可以增加新的内容到 Dockerfile 中，完成 Redis Dockerfile。\n进入到 shiyanlouredis 的目录编辑 Dockerfile：\n$ cd /home/shiyanlou/shiyanlouredis/\r$ vim Dockerfile\r7.1 安装 Redis 由于 MongoDB 中我们已经学习了如何通过二进制压缩包安装最新版本 MongoDB 的过程，在此安装 Redis 我们直接使用 Ubuntu 源中默认的 Redis 版本。\n安装方法非常简单：\nRUN apt-get install redis-server\r\r添加对外的端口号：\nEXPOSE6379 22\r\r7.2 编写Supervisord配置文件 添加Supervisord配置文件来启动 redis-server 和 ssh，创建文件/home/shiyanlou/shiyanlouredis/supervisord.conf，添加以下内容：\n[supervisord]\rnodaemon=true\r[program:redis]\rcommand=/usr/bin/redis-server\r[program:ssh]\rcommand=/usr/sbin/sshd -D\rDockerfile 中增加向镜像内拷贝该文件的命令：\nCOPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf\r\r7.3 完整的 Dockerfile # Version 0.1\r\r# 基础镜像\rFROMubuntu:14.04\r\r# 维护者信息\rMAINTAINERshiyanlou@shiyanlou.com\r\r# 镜像操作命令\rRUN echo \u0026#34;deb http://mirrors.cloud.aliyuncs.com/ubuntu/ trusty main universe\u0026#34; \u0026gt; /etc/apt/sources.list\rRUN apt-get -yqq update \u0026amp;\u0026amp; apt-get install -yqq supervisor redis-server\rRUN apt-get install -yqq openssh-server openssh-client\r\rRUN mkdir /var/run/sshd\rRUN echo \u0026#39;root:shiyanlou\u0026#39; | chpasswd\rRUN sed -i \u0026#39;s/PermitRootLogin without-password/PermitRootLogin yes/\u0026#39; /etc/ssh/sshd_config\r\rCOPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf\r\rEXPOSE6379 22\r\r# 容器启动命令\rCMD [\u0026#34;supervisord\u0026#34;]\r\r8. 从 Dockerfile 创建镜像 8.1 创建 MongoDB 镜像 进入到/home/shiyanlou/shiyanloumongodb/目录，执行创建命令。\ndocker build 执行创建，-t参数指定镜像名称：\n$ docker build -t shiyanloumongodb:0.1 /home/shiyanlou/shiyanloumongodb/\rdocker images 查看创建的新镜像已经出现在了镜像列表中：\n由该镜像创建新的容器 mongodb：\n$ docker run -P -d --name mongodb shiyanloumongodb:0.1\r 这里的 -P 参数将容器 EXPOSE 的端口随机映射到主机的端口。查看映射到那个端口的方式是输入 docker ps 或者 docker container ls，在最后一项 STATUS 中有映射的端口信息。\n 上述 docker ps 命令的输出可以看到 MongoDB 的端口号已经被自动映射到了本地的 32768 端口，后续步骤我们对 MongoDB 是否启动进行测试。\n打开 Xfce 终端中输入下面的命令连接 mongodb 容器中的服务：\n$ mongo --host 127.0.0.1 --port 32768\r 如果提示 command not found mongo ，可使用 sudo apt-get install -y mongodb 安装。\n 8.2 创建 Redis 镜像 进入到/home/shiyanlou/shiyanlouredis/目录，执行创建命令。\ndocker build 执行创建，-t参数指定镜像名称：\ndocker images 查看创建的新镜像已经出现在了镜像列表中：\n由该镜像创建新的容器 redis：\n上述docker ps命令的输出可以看到 redis 的端口号已经被自动映射到了本地的 32769 端口，SSH 服务的端口号也映射到了 32770 端口。\n打开 Xfce 终端中输入下面的命令连接 redis 容器中的 ssh 和 redis 服务：\n$ ssh root@127.0.0.1 -p 32770\r$ redis-cli -h 127.0.0.1 -p 32769\r 如果提示 command not found redis-cli ，就使用 sudo apt-get install -y redis-server 安装。\n 9. 总结 本节实验中我们学习了以下内容：\n MongoDB 的安装 Redis 的安装 Dockerfile 的编写 从 Dockerfile 构建镜像  请务必保证自己能够动手完成整个实验，只看文字很简单，真正操作的时候会遇到各种各样的问题，解决问题的过程才是收获的过程。\n使用 Docker 运行 Wordpress 1. 课程说明 课程为纯动手实验教程，为了能说清楚实验中的一些操作会加入理论内容。理论内容我们不会写太多，已经有太多好文章了，会精选最值得读的文章推荐给你，在动手实践的同时扎实理论基础。\n实验环境中可以联网，不受实验楼网络限制。\n2. 学习方法 实验楼的 Docker 课程包含 14 个实验，每个实验都提供详细的步骤和截图，适用于有一定 Linux 系统基础，想快速上手 Docker 的同学。\n学习方法是多实践，多提问。启动实验后按照实验步骤逐步操作，同时理解每一步的详细内容。\n如果实验开始部分有推荐阅读的材料，请务必先阅读后再继续实验，理论知识是实践必要的基础。\n3. 本节内容简介 在本实验里我们将通过完成一个 Wordpress 的容器来学习 Dockerfile 及 Docker 的运行机制。\n本节中，我们需要依次完成下面几项任务：\n Wordpress 的安装及配置 Dockerfile 的编写 从 Dockerfile 构建镜像  本次实验的需求是完成一个 Dockerfile，通过该 Dockerfile 创建一个 Wordpress 应用。尽管 Dockerhub 上已经提供了官方的 Wordpress 镜像，本实验仅仅用于学习 Dockerfile 及 Docker 机制。\n 扩展;WordPress 是一种使用PHP 语言开发的博客平台，用户可以在支持 PHP 和 MySQL 数据库的服务器上架设属于自己的网站。也可以把 WordPress 当作一个内容管理系统（CMS）来使用。\n 百度百科   对于 Docker 的镜像仓库来说，国内访问速度较慢，我们添加一个阿里云提供的 Docker 镜像加速器。\n首先，我们需要编辑 /etc/docker/daemon.json 文件：\n$ sudo vi /etc/docker/daemon.json\r然后加入如下内容：\n{\r\u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://n6syp70m.mirror.aliyuncs.com\u0026#34;]\r}\r修改之后，需要重启 docker 服务，让修改生效。使用如下命令：\n$ sudo service docker restart\r4. 实验准备 4.1 实验分析 在本实验中，除了部署 Wordpress 之外，我们需要安装 Nginx 提供对外的外部服务，同时安装一个 ssh 服务提供便捷的管理。\nWordpress 依赖的包比较多，至少需要安装 php，mysql 等依赖软件。所以为了提高 docker build 速度，我们直接使用阿里云的 Ubuntu 源。因此要在 Dockerfile 开始位置增加下面一句命令：\nRUN echo \u0026#34;deb http://mirrors.cloud.aliyuncs.com/ubuntu/ trusty main universe\u0026#34; \u0026gt; /etc/apt/sources.list\r\r 注意：如果在自己的电脑操作，请将 mirrors.cloud.aliyuncs.com 改为 mirrors.aliyun.com。\n 4.2 创建 Dockerfile 文件 首先，需要创建一个目录来存放 Dockerfile 文件，目录名称可以任意，在目录里创建 Dockerfile 文件：\n$ cd /home/shiyanlou\r$ mkdir shiyanlouwordpress\r$ cd shiyanlouwordpress\r$ touch Dockerfile\r使用 vim/gedit 编辑 Dockerfile 文件，根据我们的需求输入内容。\n5. Dockerfile 基本框架 按照上一节学习的内容，我们先完成 Dockerfile 基本框架。\n依次输入下面的基本框架内容：\n# Version 0.1\r\r# 基础镜像\rFROMubuntu:14.04\r\r# 维护者信息\rMAINTAINERshiyanlou@shiyanlou.com\r\r# 镜像操作命令\rRUN echo \u0026#34;deb http://mirrors.cloud.aliyuncs.com/ubuntu/ trusty main universe\u0026#34; \u0026gt; /etc/apt/sources.list\rRUN apt-get -yqq update \u0026amp;\u0026amp; apt-get install -yqq supervisor \u0026amp;\u0026amp; apt-get clean\r\r# 容器启动命令\rCMD [\u0026#34;supervisord\u0026#34;]\r\r上面的 Dockerfile 创建了一个简单的镜像，使用Supervisord启动服务。\n6. 完善 Dockerfile 在上述基本的架构下，我们根据需求可以增加新的内容到 Dockerfile 中。\n6.1 安装依赖包 安装的依赖包分为两类，一类是系统需要的服务，比如 nginx 等，一类是 Wordpress 依赖的 php 组件。\n增加下面的内容到 Dockerfile：\nRUN apt-get -yqq install nginx supervisor wget php5-fpm php5-mysql\r\r6.2 安装 Wordpress 首先创建安装目录：\nRUN mkdir -p /var/www\r\r然后下载 Wordpress 4.4.2 版本压缩包并解压：\nADD http://labfile.oss-cn-hangzhou-internal.aliyuncs.com/courses/498/wordpress-4.4.2.tar.gz /var/www/wordpress-4.4.2.tar.gz\rRUN cd /var/www \u0026amp;\u0026amp; tar zxvf wordpress-4.4.2.tar.gz \u0026amp;\u0026amp; rm -rf wordpress-4.4.2.tar.gz\rRUN chown -R www-data:www-data /var/www/wordpress\r\r6.2 安装 SSH 服务 首先安装所需要的软件包：\nRUN apt-get install -y openssh-server openssh-client\r\r创建运行目录：\nRUN mkdir /var/run/sshd\r\r设置 root 密码及允许 root 通过 ssh 登录：\nRUN echo \u0026#39;root:shiyanlou\u0026#39; | chpasswd\rRUN sed -i \u0026#39;s/PermitRootLogin without-password/PermitRootLogin yes/\u0026#39; /etc/ssh/sshd_config\r\r6.3 安装 Mysql 首先通过 debconf-set-selections 设置安装过程中需要的 root 密码为 shiyanlou，然后再执行 apt-get 安装 mysql：\nRUN echo \u0026#34;mysql-server mysql-server/root_password password shiyanlou\u0026#34; | debconf-set-selections\rRUN echo \u0026#34;mysql-server mysql-server/root_password_again password shiyanlou\u0026#34; | debconf-set-selections\rRUN apt-get install -y mysql-server mysql-client\r\r安装后需要创建安装 Wordpress 所需的wordpress数据库：\nRUN service mysql start \u0026amp;\u0026amp; mysql -uroot -pshiyanlou -e \u0026#34;create database wordpress;\u0026#34;\r\r6.4 开放端口 开放 80（Web 服务）和 22（SSH 服务）端口：\nEXPOSE80 22\r\r6.5 配置 Supervisord 添加Supervisord配置文件来启动 php5-fpm，nginx，mysql 和 ssh，创建文件/home/shiyanlou/shiyanlouwordpress/supervisord.conf，添加以下内容：\n[supervisord]\rnodaemon=true\r[program:php5-fpm]\rcommand=/usr/sbin/php5-fpm -c /etc/php5/fpm\rautorstart=true\r[program:mysqld]\rcommand=/usr/bin/mysqld_safe\r[program:nginx]\rcommand=/usr/sbin/nginx\rautorstart=true\r[program:ssh]\rcommand=/usr/sbin/sshd -D\rDockerfile 中增加向镜像内拷贝该文件的命令：\nCOPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf\r\r6.6 添加启动命令 启动Supervisord：\nCMD [\u0026#34;/usr/bin/supervisord\u0026#34;]\r\r7. 配置文件 7.1 Nginx 配置文件 为了能让 Nginx 顺利支持 /var/www/wordpress 目录下的 Wordpress，我们需要添加文件到 /etc/nginx/sites-available/default 。\n在 Dockerfile 所在的 /home/shiyanlou/shiyanlouwordpress 目录下创建文件 nginx-config，并输入以下内容：\nserver {\rlisten *:80;\rserver_name localhost;\rroot /var/www/wordpress;\rindex index.php;\rlocation / {\rtry_files $uri $uri/ /index.php?$args;\r}\rlocation ~ \\.php$ {\rtry_files $uri =404;\rinclude fastcgi_params;\rfastcgi_pass unix:/var/run/php5-fpm.sock;\r}\r}\r这是一个基本的 Nginx 配置，包含的核心配置信息：\n 指定 Wordpress 的目录：/var/www/wordpress 设置对 PHP 页面的支持，包括设置默认 index 页面为 index.php 等  7.2 Wordpress 配置文件 Wordpress 配置文件为 /var/www/wordpress/wp-config.php ，有两种方法修改这个文件：\n 使用 sed 更改文件中需要配置的项目 预先配置好该文件，在 docker build 过程中拷贝到镜像中替换原文件  我们这里介绍第一种方法：\nRUN sed -i \u0026#39;s/database_name_here/wordpress/g\u0026#39; /var/www/wordpress/wp-config-sample.php\rRUN sed -i \u0026#39;s/username_here/root/g\u0026#39; /var/www/wordpress/wp-config-sample.php\rRUN sed -i \u0026#39;s/password_here/shiyanlou/g\u0026#39; /var/www/wordpress/wp-config-sample.php\rRUN mv /var/www/wordpress/wp-config-sample.php /var/www/wordpress/wp-config.php\r\r可以看到，其中配置了数据库连接的用户名和密码，还记得前面步骤中安装 mysql 时设置的内容吗？\n修改完成后的 wp-config.php 文件节选：\ndefine(\u0026#39;DB_NAME\u0026#39;, \u0026#39;wordpress\u0026#39;);\r/** MySQL database username */\rdefine(\u0026#39;DB_USER\u0026#39;, \u0026#39;root\u0026#39;);\r/** MySQL database password */\rdefine(\u0026#39;DB_PASSWORD\u0026#39;, \u0026#39;shiyanlou\u0026#39;);\r7.3 Dockerfile 更新 在 Dockerfile 中 CMD 前面的添加 COPY 命令，用来更新镜像中的配置文件：\nCOPY nginx-config /etc/nginx/sites-available/default\r\rRUN sed -i \u0026#39;s/database_name_here/wordpress/g\u0026#39; /var/www/wordpress/wp-config-sample.php\rRUN sed -i \u0026#39;s/username_here/root/g\u0026#39; /var/www/wordpress/wp-config-sample.php\rRUN sed -i \u0026#39;s/password_here/shiyanlou/g\u0026#39; /var/www/wordpress/wp-config-sample.php\rRUN mv /var/www/wordpress/wp-config-sample.php /var/www/wordpress/wp-config.php\r\r8. 从 Dockerfile 创建镜像 将上述内容完成后放入到 /home/shiyanlou/shiyanlouwordpress/Dockerfile 文件中，最终得到的 Dockerfile 文件如下：\n# Version 0.1\rFROMubuntu:14.04\r\rMAINTAINERshiyanlou@shiyanlou.com\r\rRUN echo \u0026#34;deb http://mirrors.cloud.aliyuncs.com/ubuntu/ trusty main universe\u0026#34; \u0026gt; /etc/apt/sources.list\rRUN apt-get -yqq update\rRUN apt-get -yqq install nginx supervisor wget php5-fpm php5-mysql\rRUN echo \u0026#34;daemon off;\u0026#34; \u0026gt;\u0026gt; /etc/nginx/nginx.conf\r\rRUN mkdir -p /var/www\rADD http://labfile.oss-cn-hangzhou-internal.aliyuncs.com/courses/498/wordpress-4.4.2.tar.gz /var/www/wordpress-4.4.2.tar.gz\rRUN cd /var/www \u0026amp;\u0026amp; tar zxvf wordpress-4.4.2.tar.gz \u0026amp;\u0026amp; rm -rf wordpress-4.4.2.tar.gz\rRUN chown -R www-data:www-data /var/www/wordpress\r\rRUN mkdir /var/run/sshd\rRUN apt-get install -yqq openssh-server openssh-client\rRUN echo \u0026#39;root:shiyanlou\u0026#39; | chpasswd\rRUN sed -i \u0026#39;s/PermitRootLogin without-password/PermitRootLogin yes/\u0026#39; /etc/ssh/sshd_config\r\rRUN echo \u0026#34;mysql-server mysql-server/root_password password shiyanlou\u0026#34; | debconf-set-selections\rRUN echo \u0026#34;mysql-server mysql-server/root_password_again password shiyanlou\u0026#34; | debconf-set-selections\rRUN apt-get install -yqq mysql-server mysql-client\r\rEXPOSE80 22\r\rCOPY nginx-config /etc/nginx/sites-available/default\rCOPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf\rRUN service mysql start \u0026amp;\u0026amp; mysql -uroot -pshiyanlou -e \u0026#34;create database wordpress;\u0026#34;\rRUN sed -i \u0026#39;s/database_name_here/wordpress/g\u0026#39; /var/www/wordpress/wp-config-sample.php\rRUN sed -i \u0026#39;s/username_here/root/g\u0026#39; /var/www/wordpress/wp-config-sample.php\rRUN sed -i \u0026#39;s/password_here/shiyanlou/g\u0026#39; /var/www/wordpress/wp-config-sample.php\rRUN mv /var/www/wordpress/wp-config-sample.php /var/www/wordpress/wp-config.php\r\rCMD [\u0026#34;/usr/bin/supervisord\u0026#34;]\r\r完成后查看目录文件：\ndocker build 执行创建，-t 参数指定镜像名称：\n$ docker build -t shiyanlouwordpress:0.2 /home/shiyanlou/shiyanlouwordpress/\rdocker images 查看创建的新镜像已经出现在了镜像列表中：\n由该镜像创建新的容器 wordpress，并映射本地的 80 端口到容器的 80 端口：\n$ docker run -d -p 80:80 --name wordpress shiyanlouwordpress:0.2\r 注意：一般出现问题都是配置的问题，注意检查配置是否有拼写错误。如果提示是 80 端口被占用，可能是我们本地的 nginx 占用了端口，使用 sudo service nginx stop 关闭即可。\n使用 docker container ls 可以看到创建出来的容器。\n 最后打开桌面上的 firefox 浏览器，输入本地地址访问 127.0.0.1/wp-admin/install.php ，看到我们的 Wordpress 网站安装配置界面，由于默认会连接 google 的文件，所以打开会比较慢：\n9. 总结 本节实验中我们学习了以下内容：\n Wordpress 的安装及配置 Dockerfile 的编写 从 Dockerfile 构建镜像  请务必保证自己能够动手完成整个实验，只看文字很简单，真正操作的时候会遇到各种各样的问题，解决问题的过程才是收获的过程。\n搭建自己的 Docker Registry 1. 课程说明 课程为纯动手实验教程，为了能说清楚实验中的一些操作会加入理论内容。理论内容我们不会写太多，已经有太多好文章了，会精选最值得读的文章推荐给你，在动手实践的同时扎实理论基础。\n实验环境中可以联网，不受实验楼网络限制。\n2. 学习方法 实验楼的 Docker 课程包含 14 个实验，每个实验都提供详细的步骤和截图，适用于有一定 Linux 系统基础，想快速上手 Docker 的同学。\n学习方法是多实践，多提问。启动实验后按照实验步骤逐步操作，同时理解每一步的详细内容。\n如果实验开始部分有推荐阅读的材料，请务必先阅读后再继续实验，理论知识是实践必要的基础。\n3. 本节内容简介 在本实验里我们将自己动手搭建一个类似 Docker Hub 的 Docker Registry。\n本节中，我们需要依次完成下面几项任务：\n Docker Registry 的部署和配置 使用 Registry 管理仓库和镜像 Docker Registry 的配置  本次实验的需求是搭建一个 Docker Registry，通过该 Registry 管理仓库和镜像。\nDocker Registry 是一个用来管理 Docker 镜像的服务，本身也是一个 Docker 容器。大部分情况下都可以使用 Docker Hub，私有的 Docker Registry 使用场景主要在当需要对容器镜像存储进行完全控制或需要把镜像管理进行集成的情况。\n对于 Docker 的镜像仓库来说，国内访问速度较慢，我们添加一个阿里云提供的 Docker 镜像加速器。\n首先，我们需要编辑 /etc/docker/daemon.json 文件：\n$ sudo vi /etc/docker/daemon.json\r然后加入如下内容：\n{\r\u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://n6syp70m.mirror.aliyuncs.com\u0026#34;]\r}\r修改之后，需要重启 docker 服务，让修改生效。使用如下命令：\n$ sudo service docker restart\r4. Docker Registry 部署 由于 Docker Registry 已经被制作成一个 Docker 镜像，所以安装部署非常简单，只需要按照我们通常的docker run就可以，如果本地没有 registry 的镜像，则会自动从 Docker Hub 上获取。\n需要注意的是 Registry 默认的对外服务端口是 5000，如果我们宿主机上运行的 Registry 需要对外提供服务，可以通过映射端口的方式提供。\n本节实验中我们使用 registry:2 镜像，这个镜像为 2.0 版本的 Registry。\n部署 Docker Registry 的命令：\n$ docker run -d -p 5000:5000 --restart=always --name registry registry:2\r停止和删除 Registry 只需要用容器管理实验中学到的 docker container stop 和 docker container rm 命令。\n5. 使用 Registry 管理仓库和镜像 以下示例从 Docker Hub 中拉取 redis 镜像，并将其重新标记为 my-redis ，然后将其推送到本地 Registry 。\n5.1 推送镜像 运行后我们进行简单的测试，可以先将本地的一个 redis 镜像推送到 Registry 上：\n# 拉取镜像 redis:latest\r$ docker pull redis\r使用 docker tag 对 redis 镜像进行操作，会发现 docker image ls 列表中多了一个localhost:5000/my-redis:latest 的镜像。\n$ docker tag redis:latest localhost:5000/my-redis\r将 localhost:5000/my-redis 镜像推送到 localhost:5000 的 Docker Registry 上。\n注意 Docker 镜像的命名规则 localhost:5000/my-redis 中，localhost:5000 表示 Registry 的地址和端口。\n$ docker push localhost:5000/my-redis\r5.2 获取镜像 如果我们需要从 localhost:5000 的 Registry 上下载镜像，只需要简单的 docker pull 命令就可以完成。\n首先删除本地的 localhost:5000/redis:latest 和 redis:latest 镜像，以便从 Registry 下载镜像：\n$ docker image remove redis:latest $ docker image remove localhost:5000/my-redis\r然后从 Registry 中下载我们刚才上传的镜像。\n$ docker pull localost:5000/my-redis\rdocker pull 命令执行的过程中发现所有的数据层都已经存在本地。再次检查 docker image ls 就会看到新的localhost:5000/redis:latest 镜像。\n6. Docker Registry 的配置 6.1 镜像存储 如果我们希望将 Registry 里的镜像都存储在一个数据卷中，这样做的好处是我们可以在宿主机上对该数据卷进行备份和监控。请回忆我们的数据卷参数 -v，此外，Registry 中存储镜像的目录是 /var/lib/registry。\n为了避免端口及命名冲突，将先前实验创建的 Registry 删除，然后在本机创建一个存储路径 /home/shiyanlou/data ：\n$ docker container rm -f registry\r$ mkdir /home/shiyanlou/data\r创建一个 Registry，使用宿主机上的 /home/shiyanlou/data 目录作为存储镜像的数据卷：\n$ docker run -d \\\r -p 5000:5000 \\\r --restart=always \\\r --name registry \\\r -v /home/shiyanlou/data:/var/lib/registry \\\r registry:2\r将本地的 localhost:5000/my-redis 镜像推送到 Registry，然后查看 /home/shiyanlou/data 目录的变化：\n$ docker push localhost:5000/my-redis\r$ ls /home/shiyanlou/data\r会看到/home/shiyanlou/data 目录多了一个 docker 文件夹。在 /home/shiyanlou/data/docker/registry/v2/repositories 中可以看到刚刚上传的镜像。\n除了使用数据卷做镜像存储之外，Registry 还支持将镜像存储到 亚马逊的 S3，OpenStack 的 Swift/Glance 等存储后端。\n详细的配置方式可以见文档 Registry 存储配置选项 。\n6.2 认证机制 Registry 支持多种认证方式，这里仅仅介绍基本的认证方式，如果我们为 Registry 配置一个域名对外提供服务，需要首先配置 TLS ，可参考运行可从外部访问的 Registry 。在本实验中，我们暂时不适用域名的方式。\n(1) 首先我们需要创建一个保存用户名和密码的认证文件夹，并使用 htpasswd 创建一个认证信息：\n$ mkdir /home/shiyanlou/auth\r$ docker run --entrypoint htpasswd registry:2 -Bbn shiyanlouuser shiyanloupass \u0026gt; auth/htpasswd\r认证信息中，用户名为 shiyanlouuser，密码是 shiyanloupass。\n(2) 删除 Registry\n因为我们一会要创建一个 registry 容器，所以先删除我们之前创建的 registry 容器。\n$ docker container rm -f registry\r(3) 启动 Registry，使用该认证信息，需要将 /home/shiyanlou/auth 挂载到 Registry 的 /auth 目录：\n$ docker run -d \\\r -p 5000:5000 \\\r --restart=always \\\r --name registry \\\r -v $(pwd)/auth:/auth \\\r -e \u0026#34;REGISTRY_AUTH=htpasswd\u0026#34; \\\r -e \u0026#34;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm\u0026#34; \\\r -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \\\r registry:2\r接下来使用如下命令推送 my-redis 到本地 Registry，你会发现推送失败。为了可以通过认证向 Registry 推送本地的镜像，我们需要首先使用 docker login 配置认证信息，登录时会提示输入用户名和密码，我们输入之前配置的 shiyanlouuser 和 shiyanloupass 即可。\n# 登录方式\r$ docker login localhost:5000\r 注意：Linux 上的密码输入默认不显示，不是实验楼的系统卡住了。\n 其他认证方式的配置参数，可以参考文档 Registry 认证配置 。\n6.3 详细配置 注意：本部分没有实验操作，仅仅是简单介绍 Registry 更详细的配置方法。\nRegistry 的配置信息都存储在 Registry 中的/etc/docker/registry/config.yml文件。最简单的配置方法是直接将修改好的 YAML 配置文件挂载到 Registry 容器中。\n如果只修改少数几个配置信息，可以通过设置环境变量来改变，比如修改 storage/filesystem/rootdirectory，只需要使用 docker run 的 -e 参数设置相应的REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY变量。\n本节简单介绍下最常用的配置信息，详细信息可见 Docker Registry 配置。\n日志级别 设置 REGISTRY_LOG_LEVEL，REGISTRY_LOG_FORMATTER 来设置日志输出级别和格式，级别可以设置为 error，warn，info，debug，默认为 info级别。输出格式可以为 json，text，logstash。\nHook Hook 设置可以配置根据日志信息发送邮件。配置范例如下表所示，该例子来自 Docker 官方文档：\nhooks:\r- type: mail\rlevels:\r- panic\roptions:\rsmtp:\raddr: smtp.sendhost.com:25\rusername: sendername\rpassword: password\rinsecure: true\rfrom: name@sendhost.com\rto:\r- name@receivehost.com\r存储设置 前面的实验中，我们已经简单接触了本地数据卷存储的设置方式。此外，还可以设置多种存储后端。\n每种配置的参数列表（来自 Docker 官方文档）:\nstorage:\rfilesystem:\rrootdirectory: /var/lib/registry\razure:\raccountname: accountname\raccountkey: base64encodedaccountkey\rcontainer: containername\rgcs:\rbucket: bucketname\rkeyfile: /path/to/keyfile\rrootdirectory: /gcs/object/name/prefix\rs3:\raccesskey: awsaccesskey\rsecretkey: awssecretkey\rregion: us-west-1\rbucket: bucketname\rencrypt: true\rsecure: true\rv4auth: true\rchunksize: 5242880\rrootdirectory: /s3/object/name/prefix\rrados:\rpoolname: radospool\rusername: radosuser\rchunksize: 4194304\rswift:\rusername: username\rpassword: password\rauthurl: https://storage.myprovider.com/auth/v1.0 or https://storage.myprovider.com/v2.0 or https://storage.myprovider.com/v3/auth\rtenant: tenantname\rtenantid: tenantid\rdomain: domain name for Openstack Identity v3 API\rdomainid: domain id for Openstack Identity v3 API\rinsecureskipverify: true\rregion: fr\rcontainer: containername\rrootdirectory: /swift/object/name/prefix\ross:\raccesskeyid: accesskeyid\raccesskeysecret: accesskeysecret\rregion: OSS region name\rendpoint: optional endpoints\rinternal: optional internal endpoint\rbucket: OSS bucket\rencrypt: optional data encryption setting\rsecure: optional ssl setting\rchunksize: optional size valye\rrootdirectory: optional root directory\rinmemory:\rdelete:\renabled: false\rcache:\rblobdescriptor: inmemory\rmaintenance:\ruploadpurging:\renabled: true\rage: 168h\rinterval: 24h\rdryrun: false\rredirect:\rdisable: false\r认证设置 前面的实验已经学习过基本的 htpasswd 认证方式，除此之外，还支持 Token 方式的认证，Token 方式可以使用独立的认证服务器。配置实例：\nauth:\rtoken:\rrealm: token-realm\rservice: token-service\rissuer: registry-token-issuer\rrootcertbundle: /root/certs/bundle\rHTTP 设置 此处包含一些 Registry 提供的 HTTP 服务与协议的基本配置，包括监听地址与端口，TLS 等配置路径：\nhttp:\raddr: localhost:5000\rnet: tcp\rprefix: /my/nested/registry/\rhost: https://myregistryaddress.org:5000\rsecret: asecretforlocaldevelopment\rtls:\rcertificate: /path/to/x509/public\rkey: /path/to/x509/private\rclientcas:\r- /path/to/ca.pem\r- /path/to/another/ca.pem\rdebug:\raddr: localhost:5001\rheaders:\rX-Content-Type-Options: [nosniff]\r7. 总结 本节实验中我们学习了以下内容：\n Docker Registry 的部署和配置 使用 Registry 管理仓库和镜像 Docker Registry 的配置  请务必保证自己能够动手完成整个实验，只看文字很简单，真正操作的时候会遇到各种各样的问题，解决问题的过程才是收获的过程。\nDocker 安全 1. 课程说明 课程为纯动手实验教程，为了能说清楚实验中的一些操作会加入理论内容。理论内容我们不会写太多，已经有太多好文章了，会精选最值得读的文章推荐给你，在动手实践的同时扎实理论基础。\n实验环境中可以联网，不受实验楼网络限制。\n2. 学习方法 实验楼的 Docker 课程包含 14 个实验，每个实验都提供详细的步骤和截图，适用于有一定 Linux 系统基础，想快速上手 Docker 的同学。\n学习方法是多实践，多提问。启动实验后按照实验步骤逐步操作，同时理解每一步的详细内容。\n如果实验开始部分有推荐阅读的材料，请务必先阅读后再继续实验，理论知识是实践必要的基础。\n3. 本节内容简介 在本实验里我们将通过实验体会几个Docker中的安全设置。\n本节中，我们需要依次完成下面几项任务：\n 使用证书加固 Docker Daemon安 全 设置特权级运行的容器：--privileged=true 设置容器权限白名单：--cap-add Docker Bench Security  Docker 的安全已经随着容器技术的推广受到越来越多的关注，本节实验中我们将体会几个最常用的Docker安全相关的配置。在开始实验之前，推荐阅读关于Docker 安全性的文章：\n Flux7 Docker系列教程（五）：Docker 安全 Docker安全性探讨与实践：实践篇  对于 Docker 的镜像仓库来说，国内访问速度较慢，我们添加一个阿里云提供的 Docker 镜像加速器。\n对于 Docker 的镜像仓库来说，国内访问速度较慢，我们添加一个阿里云提供的 Docker 镜像加速器。\n首先，我们需要编辑 /etc/docker/daemon.json 文件：\n$ sudo vi /etc/docker/daemon.json\r然后加入如下内容：\n{\r\u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://n6syp70m.mirror.aliyuncs.com\u0026#34;]\r}\r修改之后，需要重启 docker 服务，让修改生效。使用如下命令：\n$ sudo service docker restart\r4. 使用证书加固Docker Daemon安全 Docker Daemon 启动的服务对外提供的是 HTTP 接口，为了增强 HTTP 连接的安全性，我们通过设置 TLS 来认证客户端是可信的，只有通过证书验证的客户端才可以连接 Docker Daemon。\n通常情况下服务器和客户端证书都需要通过第三方 CA 签发，在本实验中为了操作方便，我们使用的是自签名的证书。\n设置环境变量 有时候在创建 CA 密钥的时候可能会产生一个 unable to write 'random state' 的报错，我们需要先设置一个 RANDFILE 的环境变量：\n$ export RANDFILE=.rnd\r4.1 创建 CA 证书 首先创建一组 CA 私钥和公钥，先创建 CA 私钥，注意需要输入密码，这个密码是不会显示的，请务必记住，下面每次使用 CA 签名时都需要输入：\n$ sudo openssl genrsa -aes256 -out ca-key.pem 4096\rGenerating RSA private key, 4096 bit long modulus\r................................................++\r...................................++\re is 65537 (0x10001)\rEnter pass phrase for ca-key.pem: #此处输入你想设置的密码\rVerifying - Enter pass phrase for ca-key.pem: #再次输入\r然后使用 ca-key.pem 创建用来签名的公钥 ca.pem ，输入必要的信息：\n$ sudo openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem Enter pass phrase for ca-key.pem: #输入之前设置的密码\rYou are about to be asked to enter information that will be incorporated\rinto your certificate request.\rWhat you are about to enter is what is called a Distinguished Name or a DN.\rThere are quite a few fields but you can leave some blank\rFor some fields there will be a default value,\rIf you enter \u0026#39;.\u0026#39;, the field will be left blank.\r-----\rCountry Name (2 letter code) [AU]:CN # 输入国家代码\rState or Province Name (full name) [Some-State]:Beijing\rLocality Name (eg, city) []:Beijing\rOrganization Name (eg, company) [Internet Widgits Pty Ltd]:Shiyanlou # 输入组织名\rOrganizational Unit Name (eg, section) []:CourseTeam\rCommon Name (e.g. server FQDN or YOUR name) []:localhost # 输入服务器域名\rEmail Address []:shiyanlou@shiyanlou.com\r4.2 服务端证书配置 创建服务器的 key 和证书 server.csr，然后使用 CA 证书签发服务器证书：\n$ sudo openssl genrsa -out server-key.pem 4096\rGenerating RSA private key, 4096 bit long modulus\r............................................................++\r................++\re is 65537 (0x10001)\r$ sudo openssl req -subj \u0026#34;/CN=localhost\u0026#34; -sha256 -new -key server-key.pem -out server.csr\r$ sudo echo subjectAltName = IP:127.0.0.1 \u0026gt;\u0026gt; extfile.cnf\r#设置仅用于服务器身份验证\r$ sudo echo extendedKeyUsage = serverAuth \u0026gt;\u0026gt; extfile.cnf\r$ sudo openssl x509 -req -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out server-cert.pem -extfile extfile.cnf Signature ok\rsubject=/CN=localhost\rGetting CA Private Key\rEnter pass phrase for ca-key.pem: #输入之前设置的密码\r上面的步骤中 extfile.cnf 文件的作用是添加允许连接的 IP 地址，注意服务器证书创建时需要输入服务器的域名，在本实验中我们是用的是 localhost。\n4.3 客户端证书配置 客户端的证书用来连接Docker Daemon服务，同服务器端证书的操作类似，先创建 key 和 csr 证书，然后使用 CA签发：\n$ sudo openssl genrsa -out client-key.pem 4096\rGenerating RSA private key, 4096 bit long modulus\r.......................................++\r...................++\re is 65537 (0x10001)\r$ sudo openssl req -subj \u0026#39;/CN=client\u0026#39; -new -key client-key.pem -out client.csr $ sudo echo extendedKeyUsage = clientAuth \u0026gt; client-extfile.cnf\r$ sudo openssl x509 -req -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out cert.pem -extfile client-extfile.cnf\rSignature ok\rsubject=/CN=client\rGetting CA Private Key\rEnter pass phrase for ca-key.pem: #输入之前设置的密码\r现在查看 /home/shiyanlou 目录下所有创建的证书和key文件：\n已经生成了 cert.pem 和 server-cert.pem ，我们就可以删除两个证书签名请求了：\n$ rm -v client.csr server.csr\r为防止意外损坏密钥，可以删除其写入权限：\n$ sudo chmod -v 0400 ca-key.pem server-key.pem client-key.pem\r$ sudo chmod -v 0444 ca.pem server-cert.pem cert.pem\r4.4 配置服务端 在配置之前我们需要先停止 docker 服务：\n$ sudo service docker stop\r在服务器端运行如下命令让 Docker 守护进程只接受提供 CA 信任的证书的客户端连接：\n$ sudo dockerd --tlsverify --tlscacert=ca.pem --tlscert=server-cert.pem --tlskey=server-key.pem \\\r -H=0.0.0.0:2376\r注意： 保持运行状态，不要关掉此命令窗口或者使用 ctrl + c 中断。\n4.5 客户端连接 Docker 直接使用不增加证书参数的方式连接并执行 docker image ls ，系统会返回不能连接。而使用客户端连接则可以正确执行。新开一个终端命令窗口执行如下命令：\n$ sudo docker --tlsverify --tlscacert=ca.pem --tlscert=cert.pem --tlskey=client-key.pem -H=127.0.0.1:2376 image ls\r为了后续实验的方便，我们创建一个alias，来避免输入 docker 命令的 TLS 参数：\n$ alias docker=\u0026#39;sudo docker --tlsverify --tlscacert=ca.pem --tlscert=cert.pem --tlskey=client-key.pem -H=127.0.0.1:2376\u0026#39;\r$ docker image ls\r5. 设置特权级运行的容器：--privileged=true 有的时候我们需要容器具备更多的权限，比如操作内核模块，控制swap交换分区，挂载USB磁盘，修改MAC地址等。本实验中我们给予容器这些权限，仅仅通过一个简单的--privileged=true 的参数。\n为了对比，我们先后创建两台容器shiyanlou和prishiyanlou，后者具备--privileged=true参数和特权。\n首先创建一个不具备特权参数的容器shiyanlou，并查看容器的IP地址和MAC地址信息：\n尝试修改 MAC 地址，会收到 Operation not permitted 报错信息：\n尝试创建并挂载一个 iso 文件，同样，也会收到错误信息：\n从 shiyanlou 容器中退出，我们创建一个具备 --privileged=true 参数的 prishiyanlou 容器，看是否有不同：\n在这个容器中，我们首先尝试修改 MAC 地址，修改成功后使用 ifconfig 命令查看验证：\n再次创建一个 iso 文件，并 mkfs.ext3 格式化分区后，mount 命令挂载到 /mnt，验证发现可以成功挂载：\nCtrl-P Ctrl-Q 退出容器后查看两个容器中的配置信息：\n6. 设置容器权限白名单：--cap-add --privileged=true 的权限非常大，接近于宿主机的权限，为了防止用户的滥用，需要增加限制，只提供给容器必须的权限。此时 Docker 提供了权限白名单的机制，使用 --cap-add 添加必要的权限。\n为了能够修改 MAC 地址，我们给予新的容器 capshiyanlou 一个 NET_ADMIN 的权限。创建该容器，注意命令中的参数：\n尝试修改MAC地址，验证 --cap-add 是否起到作用：\n退出容器后，可以在 docker container inspect 命令中查看容器的必要配置：\n$ docker container inspect -f {{.HostConfig.Privileged}} capshiyanlou\rfalse\r$ docker container inspect -f {{.HostConfig.CapAdd}} capshiyanlou\r{[NET_ADMIN]}\r7. Docker Bench Security Docker Benchmark Security 是一个用于 docker 安全检查的应用程序，它会去检查下面的这些项目，并提供警告信息。它是一个开源工具，参见 GitHub-Docker Bench Security 。\n 主机配置 Docker 守护进程配置 Docker 守护进程配置文件 容器镜像和构建文件 容器运行时间 Docker 安全操作  接下来我们就来安装 Docker Bench Security：\n$ docker run -it --net host --pid host --userns host --cap-add audit_control \\\r -e DOCKER_CONTENT_TRUST=$DOCKER_CONTENT_TRUST \\\r -v /var/lib:/var/lib \\\r -v /var/run/docker.sock:/var/run/docker.sock \\\r -v /usr/lib/systemd:/usr/lib/systemd \\\r -v /etc:/etc --label docker_bench_security \\\r docker/docker-bench-security\r会显示出很多的提示信息：\n PASS ：这些项目都是很稳固的，不需要关注，pass 越多越好。\nWARN ：需要修复的项目。\nINFO ：如果这些项目和你的设置和安全需要相关，建议检查和修复这些项目。\nNOTE ：一些建议。\n 8. 总结 本节实验中我们学习了以下内容：\n 使用证书加固 Docker Daemon安 全 设置特权级运行的容器：--privileged=true 设置容器权限白名单：--cap-add Docker Bench Security  请务必保证自己能够动手完成整个实验，只看文字很简单，真正操作的时候会遇到各种各样的问题，解决问题的过程才是收获的过程。\nDocker Compose 项目 1. 课程说明 课程为纯动手实验教程，为了能说清楚实验中的一些操作会加入理论内容。理论内容我们不会写太多，已经有太多好文章了，会精选最值得读的文章推荐给你，在动手实践的同时扎实理论基础。\n实验环境中可以联网，不受实验楼网络限制。\n2. 学习方法 实验楼的 Docker 课程包含 15 个实验，每个实验都提供详细的步骤和截图，适用于有一定 Linux 系统基础，想快速上手 Docker 的同学。\n学习方法是多实践，多提问。启动实验后按照实验步骤逐步操作，同时理解每一步的详细内容。\n如果实验开始部分有推荐阅读的材料，请务必先阅读后再继续实验，理论知识是实践必要的基础。\n3. 本节内容简介 在本实验里我们将通过实验学习 Docker Compose 项目。Docker Compose 是一个用来创建和运行多容器应用的工具。使用 Compose 首先需要编写 Compose 文件来描述多个容器服务以及之间的关联，然后通过命令根据配置启动所有的容器。\nDockerfile 可以定义一个容器，而一个 Compose 的模板文件（YAML 格式）可以定义一个包含多个相互关联容器的应用。Compose 项目使用 python 编写，基于后面的实验中我们将学习的 Docker API 实现。\nDocker Compose 项目地址：https://github.com/docker/compose 感兴趣的同学可以关注。\n本节中，我们需要依次完成下面几项任务：\n 安装 Docker Compose 创建 Docker Compose 服务 - Web+redis 网站  对于 Docker 的镜像仓库来说，国内访问速度较慢，我们添加一个阿里云提供的 Docker 镜像加速器。\n首先，我们需要添加编辑 /etc/docker/daemon.json 文件，加入如下内容：\n{\r\u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://n6syp70m.mirror.aliyuncs.com\u0026#34;]\r}\r修改之后，需要重启 docker 服务，让修改生效。使用如下命令：\n$ sudo service docker restart\r4. Docker Compose 4.1 概述 Compose Compose 是定义和运行多容器 Docker 应用程序的工具。使用 Compose，可以通过编辑 YAML 文件来配置应用程序的服务。它可以用来管理应用程序的生命周期，例如启动，停止以及重构服务。\nservice 在分布式应用程序中，应用程序的不同部分被称为服务（service），例如常见的提供数据库存储的服务。服务实际上只是生产中的镜像。一个服务仅仅运行一个镜像，但它定义了服务运行的方式，例如使用哪个端口，该容器应该运行多少个副本等。\n使用过程 使用 Compose 的三个过程如下：\n 定义应用程序的环境，即 Dockerfile 定义组成应用程序的服务，一般为定义 docker-compose.yml 文件 启动整个应用程序   关于 docker-compose.yml 文件的详细编写格式可以参考：https://docs.docker.com/compose/compose-file/#reference-and-guidelines\n 目前有三种版本的 Compose 文件格式：\n version 1: 最早的版本使用传统格式，将在未来的 Compose 版本中被弃用 version 2: 现在使用最多的文件格式 version 3: 最新的版本，旨在 Compose 和被集成到 Docker Engine 中的 swarm mode 之间互相兼容（swarm 在下一节的内容会学习相关的知识）。  4.2 安装 在 Linux 中，Compose 需要单独安装，我们需要从 github 上下载 Docker Compose 二进制文件。但是官网提供的从 github 上下载的链接速度十分缓慢，在实验环境中，我们已提供该文件，直接使用以下命令进行下载：\n$ wget http://labfile.oss-cn-hangzhou.aliyuncs.com/courses/980/software/docker-compose-Linux-x86_64\r下载成功后，为了能够直接使用该可执行文件执行命令，一般将其放入 $PATH 的环境变量支持的路径中，并添加可执行权限，使用的命令如下：\n$ sudo mv docker-compose-Linux-x86_64 /usr/local/bin/docker-compose\r$ sudo chmod +x /usr/local/bin/docker-compose\r执行完成后，就能够在终端下直接使用 docker-compose 命令了：\n4.3 实例 在这里，我们将创建一个 web 应用程序，该实例参考 Docker Compose 官方文档，有两个服务，并做了一些改变。\n在本实验中，我们需要两个容器：\n(1) web 容器：提供 web 服务，并连接后端的 redis 服务\n(2) redis 容器：提供 redis 服务，接收 web 容器的连接\n其文件目录结构如下所示：\napp\r|----web\r| |----web.py\r| |----requirements.txt\r| |----Dockerfile\r|\r|----docker-compose.yml\r 注意，这里 app 目录是在 /home/shiyanlou 目录下\n (3) 首先编辑 app/web/web.py 文件，写入下面的内容：\nfrom flask import Flask\rfrom redis import Redis\rapp = Flask(__name__)\rredis = Redis(host=\u0026#39;redis\u0026#39;, port=6379)\r@app.route(\u0026#39;/\u0026#39;)\rdef hello():\rredis.incr(\u0026#39;number\u0026#39;)\rreturn \u0026#39;Hello Shiyanlou! # %s\u0026#39; % redis.get(\u0026#39;number\u0026#39;)\rif __name__ == \u0026#34;__main__\u0026#34;:\rapp.run(host=\u0026#34;0.0.0.0\u0026#34;, port=80, debug=True)\r上述代码创建一个十分简单的 web 应用程序。该程序会连接 redis 服务，在访问 / 页面时，会自动将变量 number 加一。\n(4) 编辑 app/web/requirements.txt 文件，输入如下内容\nflask==0.10\rredis==2.10.3\r创建 requirements.txt 文件，输入需要使用的 python 依赖包，方便安装。\n(5) 编辑 app/web/Dockerfile 文件，添加如下内容：\nFROMpython:2.7\rCOPY ./ /web/\rWORKDIR/web\rRUN pip install -r requirements.txt\rCMD python web.py\r\r上述 Dockerfile 定义了一个镜像，该镜像基于 python:2.7 镜像制作，在其基础上安装相应的 python 包，并执行 CMD 命令来启动该应用程序。\n(6) 编辑 app/docker-compose.yml 文件：\nservices:\rredis:\rimage: redis:3.2\rweb:\rbuild:\rcontext: /home/shiyanlou/app/web\rdepends_on:\r- redis\rports:\r- 8001:80/tcp\rvolumes:\r- /home/shiyanlou/app/web:/web:rw\rversion: '3.0'\r该 docker-compose.yml 文件定义了两个服务，分别为 web 和 redis 服务。并且我们配置 web 服务的端口映射，以及挂载相应的目录。 depends_on 定义了依赖关系，被依赖服务的容器需要先创建。\n(7) 进入 app 目录下，执行 docker-compose up 命令来启动服务：\n$ cd app\r$ docker-compose up\r由于此时 web 服务的镜像还未构建，所以此时会自动根据 build指示，使用 /home/shiyanlou/app/web/Dockerfile 文件构建镜像。\n运行成功后，此时我们可以打开浏览器，输入 127.0.0.1:8001，获取到正确的结果：\n(8) 除此之外，也可以使用 -d 参数，即 docker-compose up -d 在其在后台运行：\n(9) 如果需要暂停以及删除容器，可以直接运行 docker-compose down 命令即可\n5. 总结 本节实验中我们学习了以下内容：\n 安装 Docker Compose 创建 Docker Compose 服务 - Web+redis 网站  请务必保证自己能够动手完成整个实验，只看文字很简单，真正操作的时候会遇到各种各样的问题，解决问题的过程才是收获的过程。\nDocker Swarm 项目 1. 课程说明 课程为纯动手实验教程，为了能说清楚实验中的一些操作会加入理论内容。理论内容我们不会写太多，已经有太多好文章了，会精选最值得读的文章推荐给你，在动手实践的同时扎实理论基础。\n实验环境中可以联网，不受实验楼网络限制。\n2. 学习方法 实验楼的 Docker 课程包含 14 个实验，每个实验都提供详细的步骤和截图，适用于有一定 Linux 系统基础，想快速上手 Docker 的同学。\n学习方法是多实践，多提问。启动实验后按照实验步骤逐步操作，同时理解每一步的详细内容。\n如果实验开始部分有推荐阅读的材料，请务必先阅读后再继续实验，理论知识是实践必要的基础。\n3. 本节内容简介 在本实验里我们将通过实验学习 Docker Swarm 项目。Docker Swarm 是一个 Docker 集群部署和管理工具，可以把一组 Docker 服务器虚拟成一台容器服务器，并提供标准的 Docker API。所有可以直接连接 Docker 服务器的工具都可以连接 Docker Swarm。\n由于实验楼只提供了一台实验机，所以无法搭建集群，有部分实验操作只能以单台服务器作为演示，请见谅。\n本节中，我们需要依次完成下面几项任务：\n 下载 Docker Swarm 部署和管理 Swarm 集群  在开始实验之前，推荐先阅读下面的文章，了解 Swarm 的架构特点和概念：\n 孙宏亮 - 深入浅出 Docker Swarm  对于 Docker 的镜像仓库来说，国内访问速度较慢，我们添加一个阿里云提供的 Docker 镜像加速器。\n首先，我们需要添加编辑 /etc/docker/daemon.json 文件，加入如下内容：\n{\r\u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://n6syp70m.mirror.aliyuncs.com\u0026#34;]\r}\r修改之后，需要重启 docker 服务，让修改生效。使用如下命令：\n$ sudo service docker restart\r4. 概述 4.1 Swarm Swarm 是 Docker 发布的管理集群的工具，一个集群由多个运行 Docker 的主机组成。下面我们简单介绍 Swarm 中的一些关键概念。\nSwarm 在 Docker 1.12 之后被集成到 Docker Engine 中，又被称为 swarm mode，后面我们所说的 swarm 都是指 swarm mode。\n4.2 关键概念 Role 一个集群由多个运行 Docker 的主机组成，分别作为管理者（Manager）和工作者（Worker）两个角色。管理者管理集群中的成员，而工作者运行集群服务。给定的 Docker 主机可以是一个管理员，也可以是一个工作者，或者同时具备这两个角色。\nNode 一个节点（Node）是参与到 Swarm 集群中的一个实例。一般表现为运行 Docker 的主机。\n服务与任务 一个服务是任务在管理节点或工作节点执行的定义，服务中运行的单个容器被称为任务。\n使用集群模式运行服务时，一般有两种选项：\n replicated services，复制服务，根据设定的值，swarm 调度在节点之间运行指定的副本任务。 global services，全局服务，集群在每个可用节点上运行一项任务。  一个服务的多个任务之间没有什么不同，但是对于一些特殊的服务而言，例如涉及到端口映射的服务，即便设定了多个任务，也只能启动一个。\n堆栈 堆栈（stack）是一组相互关联的服务，即一个堆栈能够定义和协调整个应用程序的功能（但是一些非常复杂的应用程序可能需要使用多个堆栈）。\n对于在上一节我们学习的 Docker Compose 定义的应用程序来说，从技术角度来讲，就可以说我们一直在使用堆栈。但是 Docker Compose 是运行在单个主机上，而这里我们所说的堆栈可以运行在一个集群中，即是一个分布式的应用程序。\n5. Docker Swarm 5.1 环境搭建 注意：由于实验室环境限制，实验楼的在线实验环境不再配备具有公网 IP 的网卡。\n下面的实验过程可以替换为以下方式：本地两台安装有 Docker 且在同一局域网的主机。\n创建一个 swarm 在 Docker 1.12 版本之后，Swarm 被集成到 Docker Engine 中（即 Swarm mode）。我们可以直接运行以下命令来创建一个集群：\n$ docker swarm init --advertise-addr \u0026lt;IP\u0026gt;\r 如果我们使用本地局域网内的两台机器来搭建集群，那么这里要将 替换为局域网网卡。\n 对于单网卡，单 IP 来说，我们可以直接使用 docker swarm init 命令，实验环境中只有一张网卡，用于访问外部网络的网卡为 eth0，这里可以指定 `` 为 eth0 上的地址，因为其它节点必须能够访问管理者的 IP 地址。其运行结果中包含将新节点加入到集群中的命令：\n这时，我们可以使用 docker info 命令查看 swarm 的状态：\n除此之外，还可以使用 docker node ls 命令查看有关节点的信息：\n$ docker node ls\r向 swarm 中添加节点 在运行 docker swarm init 时会输出向 swarm 中添加节点的命令。除此之外，我们也可以使用如下两个命令分别获取向 swarm 中添加管理节点和工作节点的命令，获取到的命令需要在被添加的节点上运行：\n# 管理节点\r$ docker swarm join-token manager\r# 工作节点\r$ docker swarm join-token worker\r由于实验环境中，我们只有一台服务器，如果自己本地搭建的有 docker 环境，可以尝试在自己的机器上运行上图中的命令，如下所示，为作者在本机 windows 安装的 docker ，将其加入到 swarm 中：\n这时，再次使用 docker node ls 命令，就可以看到新增加的 worker 节点了，如下图所示：\n移除节点 如果需要在集群中移除一个节点，首先该节点的状态必须为 down，即该节点不可用，之后就可以正常的删除该节点了，在管理节点使用如下命令：\n# NODE 为该节点的 ID\r$ docker node rm NODE\r提权或撤销权限 对于一个 worker 节点来说，我们可以将其提升为一个 manager 节点，也可以将一个管理节点变为 worker 节点。在管理节点使用下面的命令即可：\n# 提权\rdocker node promote NODE\r# 撤权\rdocker node demote NODE\r5.2 Docker Compose 与 Docker Swarm 对于 Docker Compose 来说，即使我们可以定义多容器的应用程序，但是多个容器依然只能在单个主机上工作。\n这里我们以上一节定义的应用程序为例。进入 app 目录下，执行 docker-compose up -d 命令来启动服务。\ndocker-compose up 命令的运行结果如下图所示，图中标注的提示信息提示我们 Compose 并没有使用集群模式去部署服务，并将所有的容器调度到当前节点：\n此时运行成功后打开浏览器，输入 127.0.0.1:8001，依旧可以获取到正确的结果：\n但是如果需要使用集群模式部署服务，需要使用 docker stack deploy 命令，并且服务所需的镜像需要提前构建好。所以需要修改 app/docker-compose.yml 文件，修改后如下所示：\nservices:\rredis:\rimage: redis:3.2\rweb:\rimage: app_web:latest\rdepends_on:\r- redis\rports:\r- 8001:80/tcp\rvolumes:\r- /home/shiyanlou/app/web:/web:rw\rversion: \u0026#39;3.0\u0026#39;\r swarm 只支持 version: \u0026lsquo;3.0\u0026rsquo; 版本的 docker-compose.yml 文件\n 这时首先使用 docker-compose down 命令暂停之前使用 docker-compose 启动的容器，然后使用 docker stack deploy 命令部署该应用程序，使用的命令如下：\n$ docker stack deploy -c docker-compose.yml app\r上述命令会创建两个服务，不过与直接使用 docker-compose 不同的是，该命令部署的是一个堆栈（stack），即一组相互关联的服务，服务会被部署在集群中，而不是单个节点。并且此时我们创建的是服务，而不是单个容器，即便我们暂停或删除运行副本任务的容器，该容器也会再次启动。\n 如果你添加了自己运行 docker 的主机到 swarm 中，就有可能发现上述部署的服务的部分容器运行在 swarm 中的不同节点上，即分布式应用程序。\n 如果有添加自己运行 docker 的主机到集群中，就会发现上述两个服务，其中某一个服务运行在自己的节点上，如下所示，app_redis 服务运行在作者的 windows 节点上：\n而实验环境中运行的则是 app_web 服务，如下图所示：\n5.3 管理堆栈和服务 在创建一个集群之后，docker stack 和 docker service 两个命令集就变得可用了，他们分别用于管理堆栈和管理服务。\n在上面部署了一个堆栈到集群中，我们可以使用下面的命令来查看所有的堆栈：\n$ docker stack ls\r如图所示，该 app 堆栈有两个服务，具体的服务可以使用下面的命令来查看：\n$ docker stack services app\r查看所有的服务则可以使用 docker service ls 命令，由于总共只有两个服务，所以下面两个命令的运行结果是一样的：\n除此之外，对于我们之前引入的任务的概念，我们也可以查看相应的任务，来确定该任务的状态以及具体运行于某个节点，如下所示：\n# 查看 app 堆栈的任务\r$ docker stack ps app\r# 查看服务 app_redis 的任务\r$ docker service ps app_redis\r由于会显示启动失败的任务，并且集群中是否有添加自己的节点，所以显示结果可能并不一致，这里没有给出具体的命令截图。\n并且由于此时实在集群中部署的服务，所以手动暂停或删除容器之后，还会自动启动新的容器，如下所示：\n因此对于服务的管理，我们需要直接操作该堆栈或者操作服务，而不是容器。\n例如，我们停止服务可以使用如下的命令：\n# 移除一个堆栈，将会移除堆栈中的所有服务\r$ docker stack rm app\r# 移除一个或多个服务\r$ docker service rm app_redis app_web\r在移除了一个堆栈里的所有服务之后，该堆栈也被自动移除了，如下图所示，移除掉 app 堆栈里的所有服务后，该堆栈也被自动移除了：\n6. 总结 本节实验中我们学习了以下内容：\n 安装 Docker Swarm 部署和管理 Swarm 集群  请务必保证自己能够动手完成整个实验，只看文字很简单，真正操作的时候会遇到各种各样的问题，解决问题的过程才是收获的过程。\nDocker API 1. 课程说明 课程为纯动手实验教程，为了能说清楚实验中的一些操作会加入理论内容。理论内容我们不会写太多，已经有太多好文章了，会精选最值得读的文章推荐给你，在动手实践的同时扎实理论基础。\n实验环境中可以联网，不受实验楼网络限制。\n2. 学习方法 实验楼的 Docker 课程包含 14 个实验，每个实验都提供详细的步骤和截图，适用于有一定 Linux 系统基础，想快速上手 Docker 的同学。\n学习方法是多实践，多提问。启动实验后按照实验步骤逐步操作，同时理解每一步的详细内容。\n如果实验开始部分有推荐阅读的材料，请务必先阅读后再继续实验，理论知识是实践必要的基础。\n3. 本节内容简介 Docker 提供的 API 非常丰富，包括 Registry API，Docker Hub API，Docker OAuth API，Docker Remote API，在本节实验中，我们将通过实验学习 Docker Remote API。Docker Remote API 可以提供 docker 命令的全部功能，实验中我们使用 curl 命令来进行测试和学习。\n本节中，我们需要依次完成下面几项任务：\n Docker API 基本概念与认证 使用 API 管理容器：创建，查看，删除等操作 使用 API 管理镜像：创建，查看，删除等操作 使用 API 管理数据卷：创建，查看，删除等操作 使用 API 管理网络：创建，查看，删除等操作  对于 Docker 的镜像仓库来说，国内访问速度较慢，我们添加一个阿里云提供的 Docker 镜像加速器。\n首先，我们需要添加编辑 /etc/docker/daemon.json 文件，加入如下内容：\n{\r\u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://n6syp70m.mirror.aliyuncs.com\u0026#34;]\r}\r修改之后，需要重启 docker 服务，让修改生效。使用如下命令：\n$ sudo service docker restart\r查看 Docker API 的版本：\n4. Docker Remote API 基本概念与认证 4.1 监听地址 Docker Remote API 是由 Docker 守护进程提供的，默认情况下 Docker 守护进程可以由本地连接访问 Remote API，如果要提供远程访问，则需要绑定到网络接口上。例如，我们通常会添加下面的配置：\n-H=tcp://0.0.0.0:2375\r这句表示将 Docker 守护进程监听到所有的网络接口的 2375 端口上。\n修改配置文件 /etc/default/docker ：\n$ sudo vi /etc/default/docker\r在末尾添加以下配置：\nDOCKER_OPTS=\u0026quot;-H=tcp://0.0.0.0:2375 -H=unix:///var/run/docker.sock\u0026quot;\r 配置选项 -H=unix:///var/run/docker.sock 是允许本地访问连接。\n不要忘记重启 Docker 服务让配置文件起作用： sudo service docker restart\n 重启后我们可以进行测试：\n$ docker -H localhost:2375 info\r为了避免每次docker 命令都输入-H参数，我们设置环境变量DOCKER_HOST：\n$ export DOCKER_HOST=tcp://localhost:2375\r现在 docker 命令连接的就是 Docker Remote API 的接口。\n4.2 使用 TLS 认证 在前面的 Docker安全 实验中，我们学习了如何用 TLS 保护 Docker 守护进程，过程与此处完全相同，经过 TLS 服务器端证书保护的 Docker Remote API，需要客户端采用同样 CA 签发的证书才可以连接。\n4.3 Remote API 使用方法 后续的实验中，我们将学习最常用的 API 接口，我们将使用 curl 命令进行实验。\n例如 GET /info API，需要在 Xfce 终端中输入下面的命令：\n$ curl http://127.0.0.1:2375/info\r输出的结果如下，类似 docker info 命令的输出，不过是个 JSON 格式的内容，可以使用 python -mjson.tool 命令对输出信息进行美化：\n也可以打开 firefox 浏览器，输入如下地址然后回车查看到返回的 json 数据：\n对于 POST 操作，仍然可以用 curl 进行测试：\n$ curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; \\\r http://127.0.0.1:2375/containers/create \\\r -d \u0026#39;{\r\u0026#34;Image\u0026#34;: \u0026#34;redis\u0026#34;\r}\u0026#39;\r 如果提示没有镜像的话，可以先使用 docker pull redis 拉取镜像。\n 执行过程如下，我们会创建一个 redis 容器，并得到 JSON 格式的输出结果：\n5. 使用 API 管理容器：创建，查看，删除等操作 5.1 查看所有容器 GET /containers/json\r实验需求是查找所有的容器（包含关机状态的容器），显示最后创建的一个，同时返回容器的大小。\n针对这个需求我们将用到这个接口的三个参数：\n all=1 所有的容器（包含关机状态的容器） limit=1 显示最后创建的一个 size=1 返回容器的大小  执行的命令：\n$ curl http://127.0.0.1:2375/containers/json\\?all\\=1\\\u0026amp;limit\\=1\\\u0026amp;size\\=1\r注意：这里不加 \\ 会报错\n类比命令：\n$ docker container ls -a -n 1 -s\r操作过程截图：\n5.2 创建容器 POST /containers/create\r创建容器的参数非常多，可以回忆下 docker run 的参数。\n实验需求创建一个 nginx 容器，将容器的 80 端口映射到宿主机 80 端口，挂载宿主机的 /home/shiyanlou/data 目录作为数据卷到容器中的 /data 目录。\n该接口的所有参数都使用 JSON 格式。\n定义输入的参数：\n$ curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; \\\r http://127.0.0.1:2375/containers/create?name=test_nginx \\\r -d \u0026#39;{\r\u0026#34;Image\u0026#34;: \u0026#34;nginx\u0026#34;,\r\u0026#34;HostConfig\u0026#34;: {\r\u0026#34;Binds\u0026#34;: [\u0026#34;/home/shiyanlou/data:/data\u0026#34;],\r\u0026#34;PortBindings\u0026#34;: {\u0026#34;80/tcp\u0026#34;: [{\u0026#34;HostPort\u0026#34;: \u0026#34;81\u0026#34;}]}\r}\r}\u0026#39;\r操作过程：\n创建后使用 docker container inspect 验证。\n此时用浏览器访问地址 localhost:81 可以看到 nginx 的页面：\n5.3 删除指定的容器 DELETE /containers/(id)\r如果尝试删除一个运行中的容器，需要使用参数force=1。\n操作过程首先查找容器 ID，然后使用 curl 执行 DELETE 操作：\n5.4 其他接口 其他常用的接口使用方法，主要参数都是容器的 ID，下面列出常用 docker 命令对应的 API：\n docker container inspect：GET /containers/(id)/json docker container top：GET /containers/(id)/top docker container logs：GET /containers/(id)/logs docker container export：GET /containers/(id)/export docker container start：POST /containers/(id)/start docker container attach：POST /containers/(id)/attach  可以参照上面三个操作进行实验。\n6. 使用 API 管理镜像：创建，查看，删除等操作 6.1 查看所有镜像 GET /images/json\r查看当前系统中的所有镜像：\n$ curl http://127.0.0.1:2375/images/json | python -mjson.tool 6.2 拉取镜像 POST /images/create\r从 Docker Hub 拉取 busybox 镜像：\n$ curl -X POST http://127.0.0.1:2375/images/create\\?fromImage\\=busybox:ubuntu-14.04\r该接口执行的过程中，镜像下载的进度也会输出到屏幕上。\n6.3 删除镜像 DELETE /images/(name)\r删除刚刚拉取的 busybox 镜像：\ncurl -X DELETE http://127.0.0.1:2375/images/busybox\r6.4 其他接口 其他常用的接口使用方法，主要参数都是容器的 ID，下面列出常用 docker 命令对应的 API：\n docker image inspect：GET /images/(name)/json docker image tag：POST /images/(name)/tag docker image push: POST /images/(name)/push docker image build：POST /build docker search：GET /images/search  7. 使用 API 管理数据卷：创建，查看，删除等操作 7.2 创建数据卷 POST /volumes/create\r创建一个名字为 shiyanlou 的数据卷，可以在返回信息中看到数据卷的挂载点\n7.1 查看数据卷 GET /volumes\r查看系统中的所有数据卷：\n7.3 删除数据卷 DELETE /volumes/(name)\r删除刚刚创建的数据卷 shiyanlou：\n8. 使用 API 管理网络：创建，查看，删除等操作 8.1 列出系统中所有的网络 GET /networks\r列出系统中所有的网络:\n8.2 创建新的网络 POST /networks/create\r创建一个新的网络，名字为 shiyanlou，驱动类型为bridge，配置网段为172.10.0.0/16。\n创建过程：\n$ curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; \\\r http://127.0.0.1:2375/networks/create \\\r -d \u0026#39;{\r\u0026#34;Name\u0026#34;: \u0026#34;shiyanlou\u0026#34;,\r\u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;,\r\u0026#34;IPAM\u0026#34;: {\u0026#34;Config\u0026#34;: [{\u0026#34;Subnet\u0026#34;: \u0026#34;172.10.0.0/16\u0026#34;}]}\r}\u0026#39;\r8.3 连接容器到网络 POST /networks/(id)/connect\r创建一个 redis 容器：\n连接容器到新创建的 shiyanlou 网络：\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; http://127.0.0.1:2375/networks/shiyanlou/connect -d \u0026#39;{\u0026#34;Container\u0026#34;: \u0026#34;e132d\u0026#34;}\u0026#39;\r e132d 为 容器 id。\n 8.4 删除网络 DELETE /networks/(id)\r首先把关联的容器断开，然后删除网络：\n$ curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; http://127.0.0.1:2375/networks/shiyanlou/disconnect -d \u0026#39;{\u0026#34;Container\u0026#34;: \u0026#34;e132d\u0026#34;}\u0026#39;\r$ curl -X DELETE http://127.0.0.1:2375/networks/shiyanlou\r$ curl http://127.0.0.1:2375/networks/shiyanlou\r9. 总结 本节实验中我们学习了以下内容：\n Docker API 基本概念与认证 使用 API 管理容器：创建，查看，删除等操作 使用 API 管理镜像：创建，查看，删除等操作 使用 API 管理数据卷：创建，查看，删除等操作 使用 API 管理网络：创建，查看，删除等操作  请务必保证自己能够动手完成整个实验，只看文字很简单，真正操作的时候会遇到各种各样的问题，解决问题的过程才是收获的过程。\n基于 Docker API 开发应用 1. 课程说明 课程为纯动手实验教程，为了能说清楚实验中的一些操作会加入理论内容。理论内容我们不会写太多，已经有太多好文章了，会精选最值得读的文章推荐给你，在动手实践的同时扎实理论基础。\n实验环境中可以联网，不受实验楼网络限制。\n2. 学习方法 实验楼的 Docker 课程包含 14 个实验，每个实验都提供详细的步骤和截图，适用于有一定 Linux 系统基础，想快速上手 Docker 的同学。\n学习方法是多实践，多提问。启动实验后按照实验步骤逐步操作，同时理解每一步的详细内容。\n如果实验开始部分有推荐阅读的材料，请务必先阅读后再继续实验，理论知识是实践必要的基础。\n3. 本节内容简介 在本实验里我们将基于 Docker API 开发应用学习 Docker API。本实验将使用 Python 语言，应用尽量实现的简单，让不熟悉 Python 语言的同学也能够完成。\n本节中，我们需要依次完成下面几项任务：\n docker 包的安装与使用 获取容器信息 使用 Dockerfile 创建镜像  对于 Docker 的镜像仓库来说，国内访问速度较慢，我们添加一个阿里云提供的 Docker 镜像加速器。\n首先，我们需要添加编辑 /etc/docker/daemon.json 文件，加入如下内容：\n{\r\u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://n6syp70m.mirror.aliyuncs.com\u0026#34;]\r}\r修改之后，需要重启 docker 服务，让修改生效。使用如下命令：\n$ sudo service docker restart\r4. docker 包的安装与使用 本实验中将使用 docker 包进行实现。 docker 是对 Docker Remote API 的 Python 封装，可以通过调用 Python 类和函数来实现 Docker Remote API 的操作，比如创建容器，镜像管理等。\n docker 包的详细文档见： http://docker-py.readthedocs.org/en/latest/ 。其中包含的方法很多，要学会举一反三，学会使用官方文档。\n 4.1 更新 pip 源 由于阿里云源地址的变动，本实验环境中的 pip 源需要重新配置。首先使用以下命令打开 pip 的配置文件，修改其中的内容：\n$ vim ~/.pip/pip.conf\r 实验环境中的 pip.conf 已经有内容，需要修改为和给出的内容一致\n 修改后配置文件中的内容为：\n[global]\rindex-url = https://mirrors.aliyun.com/pypi/simple/\r[install]\rtrusted-host=mirrors.aliyun.com\r然后使用以下命令，更新 pip 的版本：\n$ sudo pip install --upgrade pip\r4.2 配置远程访问 Docker Remote API 是由 Docker 守护进程提供的，默认情况下 Docker 守护进程可以由本地连接访问 Remote API，如果要提供远程访问，则需要绑定到网络接口上。例如，我们通常会添加下面的配置：\n-H=tcp://0.0.0.0:2375\r这句表示将 Docker 守护进程监听到所有的网络接口的 2375 端口上。\n修改配置文件 /etc/default/docker ：\n$ sudo vi /etc/default/docker\r在末尾添加以下配置：\nDOCKER_OPTS=\u0026quot;-H=tcp://0.0.0.0:2375 -H=unix:///var/run/docker.sock\u0026quot;\r 配置选项 -H=unix:///var/run/docker.sock 是允许本地访问连接。\n不要忘记重启 Docker 服务让配置文件起作用： sudo service docker restart\n 重启后我们可以进行测试：\n$ docker -H localhost:2375 info\r如果出现以上结果，就说明远程连接成功了，那么我们就可以使用 python 连接 Docker 了。\n4.3 配置虚拟环境 使用 virtualenv 配置虚拟环境：\n$ cd ~\r# 安装 virtualenv\r$ sudo pip install virtualenv\r# 由于实验环境中没有 Python3.5，而相关包对 Python3.5 有依赖，这里先安装 Python3.5\r$ sudo add-apt-repository ppa:fkrull/deadsnakes\r$ sudo apt-get update\r$ sudo apt-get install python3.5\r# 使用 python3.5 ,venv 为虚拟环境目录名\r$ virtualenv -p /usr/bin/python3.5 venv\r# 激活虚拟环境\r$ source venv/bin/activate\r**注意：后面的全部实验操作都在虚拟环境中进行。**\r4.4 安装 ipython 在虚拟环境中执行如下命令：\n$ pip3 install ipython\r4.5 安装 docker 包 在虚拟环境中输入下面的命令进行安装：\n$ pip3 install docker\r4.6 基本使用 安装完成后，我们可以在 python 中通过 docker 模块来使用。\n在虚拟环境中输入 ipython，本节后续步骤在 ipython 下进行操作。\n连接和操作 Docker 服务或 Swarm 服务的基础类需要首先实例化客户端：\nimport docker\rclient=docker.DockerClient(base_url=\u0026#39;tcp://127.0.0.1:2375\u0026#39;)\rclient.containers.list()\rclient\r 此处配置一个连接地址 tcp://127.0.0.1:2375 实例化一个客户端。\n  如果 client.containers.list() 的输出为空，说明 Docker 中没有容器，我们可以新建一个容器，然后再查看，使用如下命令新建容器：docker container run -itd ubuntu /bin/bash。\n 之前我们用 curl 命令调用 Docker Remote API 启动了 nginx 容器，这里我们用 python 实现同样效果。绑定主机的 /home/shiyanlou/data 目录和容器的 /data 目录，绑定主机端口 84 和容器端口 80 ：\ncontainer=client.containers.run(name=\u0026#39;syl_nginx\u0026#39;,image=\u0026#39;nginx:latest\u0026#39;,volumes={\u0026#39;/home/shiyanlou/data\u0026#39;:{\u0026#39;bind\u0026#39;:\u0026#39;/data\u0026#39;,\u0026#39;mode\u0026#39;:\u0026#39;rw\u0026#39;}},ports={\u0026#39;80/tcp\u0026#39;:84},detach=True)\r 其中 detach 表示立即在后台启动容器，类似 docker run -d 。这里为 true，返回了容器对象。\n  这里指定镜像 image='nginx:latest'，如果不加 latest 则必须先在终端输入 docker pull nginx:latest 先拉取镜像，否则此过程会持续很长时间。\n 接下来用浏览器访问地址 localhost:84 可看到 nginx 欢迎页面：\n然后我们尝试列出当前系统的所有镜像：\nclient.images.list()\r5. 获取容器信息 上面我们简单学习了 docker 包的基本用法，接下来学习如何获取容器信息。\n使用到的 API：\n client.containers.list() 获得容器列表及基本信息 容器对象的各种属性  实验可以继续在 ipython 中执行，最后将执行无误的代码合并成 python 脚本。\n为了本次实验，我们需要多创建几个容器：\n首先在终端中执行 docker pull redis:latest 命令获取最新版本的 redis 镜像，然后在 ipython 中执行如下命令：\nc1=client.containers.run(image=\u0026#39;redis\u0026#39;,detach=True)\rc2=client.containers.create(image=\u0026#39;nginx\u0026#39;,volumes={\u0026#39;/home/shiyanlou/data\u0026#39;:{\u0026#39;bind\u0026#39;:\u0026#39;/data\u0026#39;,\u0026#39;mode\u0026#39;:\u0026#39;rw\u0026#39;}},ports={\u0026#39;80/tcp\u0026#39;:85})\rnginx 使用的 create 创建，并没有启动，我们来启动它：\nc2.start()\r首先我们需要获得所有的容器的基本信息：\n all = True 代表列出所有容器，不加这个参数只会列出运行中的容器。\n 返回的 containers 列表中已经包含了我们所需的大部分信息，下一步是继续获取其他相关信息。\n使用 results 字典作为返回信息的存储，获得容器的各种属性，如容器 id 前 10 个字符，容器的镜像，容器的运行进程，容器的流统计信息。\nresults={}\rcontainer_list=client.containers.list()\rfor container in container_list:\rresults[\u0026#39;short_id\u0026#39;]=container.short_id\rresults[\u0026#39;image\u0026#39;]=container.image\rresults[\u0026#39;top\u0026#39;]=container.top()\rresults[\u0026#39;stats\u0026#39;]=container.stats()\r上述程序的输出：\n6. 使用 Dockerfile 创建镜像 依然在虚拟环境中执行如下操作。\n学习了获取容器，接下来我们学习 python 的 docker 包从 dockerfile 创建镜像。需要调用 client.images.build() 方法。\n6.1 程序结构 我们将要实现的程序放在 /home/shiyanlou/build-image.py，使用 vim 或 gedit 打开该文件输入下面的内容，初始化 Client 对象：\nimport docker\rclient=docker.DockerClient(base_url=\u0026#39;tcp://127.0.0.1:2375\u0026#39;)\r程序逻辑很简单，包含两部分内容：\n 处理参数：判断是否输入的是两个参数，读取第一个参数判断是否为路径并且路径下存在 Dockerfile。 如果存在 Dockerfile，就调用创建镜像的 API 创建镜像。  6.2 处理逻辑 判断是否输入了两个参数：\nimport sys\rif len(sys.argv) != 3:\rprint(\u0026#34;Parameter ERROR:args number\u0026#34;)\rsys.exit()\r判断第一个参数是否为路径并且路径存在 Dockerfile，如果存在则创建镜像，如果不存在，就返回错误信息：\nimport os\rif os.path.isdir(sys.argv[1]):\rdockerFile = os.path.join(sys.argv[1],\u0026#39;Dockerfile\u0026#39;)\rif os.path.exists(dockerFile):\r#调用创建镜像的 API\r image=client.images.build(path=sys.argv[1],tag=sys.argv[2])\r#打印镜像信息\r print(image)\r#列出所有镜像\r print(client.images.list())\relse:\rprint(\u0026#34;build error,not found Dockerfile\u0026#34;)\r path ：Dockerfile 所在路径\ntag ：定义的镜像标签\n 完整的程序文件内容如下：\nimport sys\rimport os\rimport docker\rclient=docker.DockerClient(base_url=\u0026#39;tcp://127.0.0.1:2375\u0026#39;)\rif len(sys.argv) != 3:\rprint(\u0026#34;Parameter ERROR:args number\u0026#34;)\rsys.exit()\rif os.path.isdir(sys.argv[1]):\rdockerFile = os.path.join(sys.argv[1],\u0026#39;Dockerfile\u0026#39;)\rif os.path.exists(dockerFile):\rimage=client.images.build(path=sys.argv[1],tag=sys.argv[2])\rprint(image)\rprint(client.images.list())\relse:\rprint(\u0026#34;build error,not found Dockerfile\u0026#34;)\r6.4 测试程序 创建测试所需的 Dockerfile 文件：\n$ mkdir /home/shiyanlou/imagetest\r$ cd /home/shiyanlou/imagetest\r$ vim Dockerfile\r输入 Dockerfile 的内容可以很简单：\nFROM ubuntu:14.04\rENV HOSTNAME=shiyanlou\r从 Dockerfile 构建容器：\n$ python build-image.py /home/shiyanlou/imagetest build_test\r查看最终创建的镜像：\n$ docker image ls\r7. 总结 本节实验中我们学习了以下内容：\n python docker 包的安装与使用 获取容器信息 使用 Dockerfile 创建镜像  请务必保证自己能够动手完成整个实验，只看文字很简单，真正操作的时候会遇到各种各样的问题，解决问题的过程才是收获的过程。\n","id":3,"section":"posts","summary":"Docker 概念及基本用法 1. 课程说明 课程为纯动手实验教程，为了能说清楚实验中的一些操作会加入理论内容。理论内容我们不会写太多，已经有太多好文章了，会精","tags":["tutorial","docker"],"title":"动手实战学Docker","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/12/%E5%8A%A8%E6%89%8B%E5%AE%9E%E6%88%98%E5%AD%A6docker/","year":"2019"},{"content":"Pygame基础讲解 一、实验介绍 1.1 实验内容 在本节课中，我们将讲解Pygame的常用对象及其操作，包括图形、动画、文字、音频等，确保同学们对Pygame有一个基础的了解，同时为后续课程做好准备。\n1.2 实验知识点  Pygame图形 Pygame动画 Pygame文字 Pygame音频 Pygame事件  1.3 实验环境  Python 3.5.1 Xfce终端  1.4 适合人群 本课程难度为一般，属于初级级别课程，适合具有Python基础的用户，熟悉Python基础知识加深巩固。\n1.5 代码获取 本节实验所用到的代码和相关资源文件可以通过下面命令下载到实验楼环境中，作为参照对比进行学习。\n$ wget http://labfile.oss.aliyuncs.com/courses/940/foundation.zip\r解压缩至/home/shiyanlou/foundation：\n$ unzip foundation.zip\r二、开发准备 本次课程主要利用Pygame模块来进行开发，首先我们需要打开Xfce终端，并使用pip命令来安装Pygame\n$ sudo pip3 install pygame\r安装完成之后进入Python的交互界面，输入以下命令查看是否成功安装。\nimport pygame\r若无异常，则说明安装成功。\n三、实验步骤 3.1 HelloWorld 首先开始我们第一个HelloWorld程序：\n# -*- coding: UTF-8 -*-\r # helloworld.py\r # 导入所需的模块\r import pygame, sys\r# 导入所有pygame.locals里的变量（比如下面大写的QUIT变量）\r from pygame.locals import *\r# 初始化pygame\r pygame.init()\r# 设置窗口的大小，单位为像素\r screen = pygame.display.set_mode((500, 400))\r# 设置窗口标题\r pygame.display.set_caption(\u0026#39;Hello World\u0026#39;)\r# 程序主循环\r while True:\r# 获取事件\r for event in pygame.event.get():\r# 判断事件是否为退出事件\r if event.type == QUIT:\r# 退出pygame\r pygame.quit()\r# 退出系统\r sys.exit()\r# 绘制屏幕内容\r pygame.display.update()\r效果图如下： 这里解释一下上面程序的运行方式 一个游戏循环（也可以称为主循环）就做下面这三件事：\n 处理事件 更新游戏状态 绘制游戏状态到屏幕上  3.2 绘制图形 Pygame的坐标原点（0，0）点位于左上角，X轴自左向右，Y轴自上向下，单位为像素。 这里介绍一下常用的方法：\n pygame.draw.line(Surface, color, start_pos, end_pos, width) 此方法用于绘制一条线段 pygame.draw.aaline(Surface, color, start_pos, end_pos, blend) 此方法用于绘制一条抗锯齿的线 pygame.draw.lines(Surface, color, closed, pointlist, width) 此方法用于绘制一条折线 pygame.draw.rect(Surface, color, Rect) 此方法用于绘制一个矩形 pygame.draw.rect(Surface, color, Rect, width) 此方法用于绘制一个矩形框 pygame.draw.ellipse(Surface, color, Rect) 此方法用于绘制一个椭圆 pygame.draw.ellipse(Surface, color, Rect, width) 此方法用于绘制一个椭圆框 pygame.draw.polygon(Surface, color, pointlist, width) 此方法用于绘制一个多边形 pygame.draw.arc(Surface, color, Rect, start_angle, stop_angle, width) 此方法用于绘制一条弧线 pygame.draw.circle(Surface, color, Rect, radius) 此方法用于绘制一个圆  以下为示例代码：\n# -*- coding: UTF-8 -*-\r # drawing.py\r # 导入需要的模块\r import pygame, sys\rfrom pygame.locals import *\rfrom math import pi\r# 初始化pygame\r pygame.init()\r# 设置窗口的大小，单位为像素\r screen = pygame.display.set_mode((400,300))\r# 设置窗口标题\r pygame.display.set_caption(\u0026#39;Drawing\u0026#39;)\r# 定义颜色\r BLACK = ( 0, 0, 0)\rWHITE = (255, 255, 255)\rRED = (255, 0, 0)\rGREEN = ( 0, 255, 0)\rBLUE = ( 0, 0, 255)\r# 设置背景颜色\r screen.fill(WHITE)\r# 绘制一条线\r pygame.draw.line(screen, GREEN, [0, 0], [50,30], 5)\r# 绘制一条抗锯齿的线\r pygame.draw.aaline(screen, GREEN, [0, 50],[50, 80],True)\r# 绘制一条折线\r pygame.draw.lines(screen, BLACK, False, [[0, 80], [50, 90], [200, 80], [220, 30]], 5)\r# 绘制一个空心矩形\r pygame.draw.rect(screen, BLACK, [75, 10, 50, 20], 2)\r# 绘制一个矩形\r pygame.draw.rect(screen, BLACK, [150, 10, 50, 20])\r# 绘制一个空心椭圆\r pygame.draw.ellipse(screen, RED, [225, 10, 50, 20], 2)\r# 绘制一个椭圆\r pygame.draw.ellipse(screen, RED, [300, 10, 50, 20])\r# 绘制多边形\r pygame.draw.polygon(screen, BLACK, [[100, 100], [0, 200], [200, 200]], 5)\r# 绘制多条弧线\r pygame.draw.arc(screen, BLACK,[210, 75, 150, 125], 0, pi/2, 2)\rpygame.draw.arc(screen, GREEN,[210, 75, 150, 125], pi/2, pi, 2)\rpygame.draw.arc(screen, BLUE, [210, 75, 150, 125], pi,3*pi/2, 2)\rpygame.draw.arc(screen, RED, [210, 75, 150, 125], 3*pi/2, 2*pi, 2)\r# 绘制一个圆\r pygame.draw.circle(screen, BLUE, [60, 250], 40)\r# 程序主循环\r while True:\r# 获取事件\r for event in pygame.event.get():\r# 判断事件是否为退出事件\r if event.type == QUIT:\r# 退出pygame\r pygame.quit()\r# 退出系统\r sys.exit()\r# 绘制屏幕内容\r pygame.display.update()\r效果图如下：\n3.3 实现动画 由于人类眼睛的特殊生理结构，当所看画面的帧率高于24的时候，就会认为是连贯的，此现象称之为视觉暂留。 帧率（Frame rate）是用于测量显示帧数的量度，所谓的测量单位为每秒显示帧数(Frames per Second，简称：FPS） 一般来说30fps是可以接受的，但是将性能提升至60fps则可以明显提升交互感和逼真感，但是一般来说超过75fps一般就不容易察觉到有明显的流畅度提升了。 在我们原有坐标系的基础上添加偏移量，再重新绘制，依次一张一张的循环绘制下去，就会得到我们想要的物体移动的效果。 Pygame实现动画主要用到的方法：\n pygame.image.load(filename) 加载一张图片 pygame.Surface.blit(source, dest, area=None, special_flags = 0) 将图片绘制到屏幕相应坐标上（后面两个参数默认，可以不传） pygame.time.Clock() 获得pygame的时钟 pygame.time.Clock.tick(FPS) 设置pygame时钟的间隔时间  以下为示例代码：\n# -*- coding: UTF-8 -*-\r # animation.py\r # 导入需要的模块\r import pygame, sys\rfrom pygame.locals import *\r# 初始化pygame\r pygame.init()\r# 设置帧率（屏幕每秒刷新的次数）\r FPS = 30\r# 获得pygame的时钟\r fpsClock = pygame.time.Clock()\r# 设置窗口大小\r screen = pygame.display.set_mode((500, 400), 0, 32)\r# 设置标题\r pygame.display.set_caption(\u0026#39;Animation\u0026#39;)\r# 定义颜色\r WHITE = (255, 255, 255)\r# 加载一张图片（所用到的的图片请参考1.5代码获取）\r img = pygame.image.load(\u0026#39;resources/shiyanlou.PNG\u0026#39;)\r# 初始化图片的位置\r imgx = 10\rimgy = 10\r# 初始化图片的移动方向\r direction = \u0026#39;right\u0026#39;\r# 程序主循环\r while True:\r# 每次都要重新绘制背景白色\r screen.fill(WHITE)\r# 判断移动的方向，并对相应的坐标做加减\r if direction == \u0026#39;right\u0026#39;:\rimgx += 5\rif imgx == 380:\rdirection = \u0026#39;down\u0026#39;\relif direction == \u0026#39;down\u0026#39;:\rimgy += 5\rif imgy == 300:\rdirection = \u0026#39;left\u0026#39;\relif direction == \u0026#39;left\u0026#39;:\rimgx -= 5\rif imgx == 10:\rdirection = \u0026#39;up\u0026#39;\relif direction == \u0026#39;up\u0026#39;:\rimgy -= 5\rif imgy == 10:\rdirection = \u0026#39;right\u0026#39;\r# 该方法将用于图片绘制到相应的坐标中\r screen.blit(img, (imgx, imgy))\rfor event in pygame.event.get():\rif event.type == QUIT:\rpygame.quit()\rsys.exit()\r# 刷新屏幕\r pygame.display.update()\r# 设置pygame时钟的间隔时间\r fpsClock.tick(FPS)\r效果图如下：\n3.4 绘制文字 如果你想绘制文字到屏幕上，Pygame提供了很方便的方法使用.ttf字体文件，这样我们就能很轻易的将文字绘制在屏幕上了。 这里我使用了ARBERKLEY.ttf作为字体，字体文件的获取请参考1.5代码获取。 主要用到的方法：\n pygame.font.Font(filename, size) filename：字体文件的文件名； size：字体的高height，单位为像素； pygame.font.Font.render(text, antialias, color, background=None) text：要显示的文字； antialias： 是否抗锯齿； color：字体颜色； background：背景颜色（可选参数）； .get_rect() 获得一个对象的rect，以便于设置其坐标位置  以下为示例代码：\n# -*- coding: UTF-8 -*-\r # font.py\r # 导入需要的模块\r import pygame, sys\rfrom pygame.locals import *\r# 初始化pygame\r pygame.init()\r# 设置窗口的大小，单位为像素\r screen = pygame.display.set_mode((500,400))\r# 设置窗口的标题\r pygame.display.set_caption(\u0026#39;Font\u0026#39;)\r# 定义颜色\r WHITE = (255, 255, 255)\rGREEN = ( 0, 255, 0)\rBLUE = ( 0, 0, 128)\r# 通过字体文件获得字体对象\r fontObj = pygame.font.Font(\u0026#39;resources/ARBERKLEY.ttf\u0026#39;, 50)\r# 配置要显示的文字\r textSurfaceObj = fontObj.render(\u0026#39;Pygame\u0026#39;, True, BLUE, GREEN)\r# 获得要显示的对象的rect\r textRectObj = textSurfaceObj.get_rect()\r# 设置显示对象的坐标\r textRectObj.center = (250, 200)\r# 设置背景\r screen.fill(WHITE)\r# 绘制字体\r screen.blit(textSurfaceObj, textRectObj)\r# 程序主循环\r while True:\r# 获取事件\r for event in pygame.event.get():\r# 判断事件是否为退出事件\r if event.type == QUIT:\r# 退出pygame\r pygame.quit()\r# 退出系统\r sys.exit()\r# 绘制屏幕内容\r pygame.display.update()\r效果图如下：\n3.5 播放音频 在Pygame里播放音频有两个方法，一个用来播放特效声音，一个用来播放背景音乐：\n pygame.mixer.Sound(filename) 该方法返回一个Sound对象，调用它的.play( )方法，即可播放较短的音频文件（比如玩家受到伤害、收集到金币等）； pygame.mixer.music.load(filename) 该方法用来加载背景音乐，之后调用pygame.mixer.music.play( )方法就可以播放背景音乐（Pygame只允许加载一个背景音乐在同一个时刻）  以下为示例代码：\n# -*- coding: UTF-8 -*-\r # audio.py\r # 导入需要的模块\r import pygame, sys\rfrom pygame.locals import *\r# 初始化pygame\r pygame.init()\r# 设置窗口的大小，单位为像素\r screen = pygame.display.set_mode((500,400))\r# 设置窗口的标题\r pygame.display.set_caption(\u0026#39;Audio\u0026#39;)\r# 定义颜色\r WHITE = (255, 255, 255)\r# 设置背景\r screen.fill(WHITE)\r# 加载并播放一个特效音频文件（所用到的音频文件请参考1.5代码获取）\r sound = pygame.mixer.Sound(\u0026#39;resources/bounce.ogg\u0026#39;)\rsound.play()\r# 加载背景音乐文件\r pygame.mixer.music.load(\u0026#39;resources/bgmusic.mp3\u0026#39;)\r# 播放背景音乐，第一个参数为播放的次数（-1表示无限循环），第二个参数是设置播放的起点（单位为秒）\r pygame.mixer.music.play(-1, 0.0)\r# 程序主循环\r while True:\r# 获取事件\r for event in pygame.event.get():\r# 判断事件是否为退出事件\r if event.type == QUIT:\r# 停止播放背景音乐\r pygame.mixer.music.stop()\r# 退出pygame\r pygame.quit()\r# 退出系统\r sys.exit()\r# 绘制屏幕内容\r pygame.display.update()\r注意：因实验楼里暂时不能播放音频，上述代码在实验楼环境中可能无法正常运行，同学们可以在自己的电脑上尝试运行。\n3.6 事件 Pygame里常用的事件如下表：\n   事件 产生途径 参数     QUIT 用户按下关闭按钮 none   ACTIVEEVENT Pygame被激活或者隐藏 gain, state   KEYDOWN 键盘被按下 unicode, key, mod   KEYUP 键盘被放开 key, mod   MOUSEMOTION 鼠标移动 pos, rel, buttons   MOUSEBUTTONDOWN 鼠标按下 pos, button   MOUSEBUTTONUP 鼠标放开 pos, button   VIDEORESIZE Pygame窗口缩放 size, w, h    以下为示例代码：\n# -*- coding: UTF-8 -*-\r # event.py\r # 导入需要的模块\r import pygame, sys\rfrom pygame.locals import *\r# 定义颜色\r WHITE = (255, 255, 255)\r# 初始化pygame\r pygame.init()\r# 设置窗口的大小，单位为像素\r screen = pygame.display.set_mode((500,400), 0, 32)\r# 设置窗口的标题\r pygame.display.set_caption(\u0026#39;Event\u0026#39;)\r# 设置背景\r screen.fill(WHITE)\r# 程序主循环\r while True:\r# 获取事件\r for event in pygame.event.get():\r# 判断事件是否为退出事件\r if event.type == QUIT:\r# 退出pygame\r pygame.quit()\r# 退出系统\r sys.exit()\r# 获得鼠标当前的位置  if event.type ==MOUSEMOTION:\rprint(event.pos)\r# 获得鼠标按下的位置\r if event.type ==MOUSEBUTTONDOWN:\rprint(\u0026#34;鼠标按下：\u0026#34;,event.pos)\r# 获得鼠标抬起的位置\r if event.type ==MOUSEBUTTONUP:\rprint(\u0026#34;鼠标抬起：\u0026#34;,event.pos) # 获得键盘按下的事件  if event.type == KEYDOWN:\rif(event.key==K_UP or event.key==K_w):\rprint(\u0026#34;上\u0026#34;)\rif(event.key==K_DOWN or event.key==K_s):\rprint(\u0026#34;下\u0026#34;)\rif(event.key==K_LEFT or event.key==K_a):\rprint(\u0026#34;左\u0026#34;)\rif(event.key==K_RIGHT or event.key==K_d):\rprint(\u0026#34;右\u0026#34;)\r# 按下键盘的Esc键退出\r if(event.key==K_ESCAPE):\r# 退出pygame\r pygame.quit()\r# 退出系统\r sys.exit()\r# 绘制屏幕内容\r pygame.display.update()\r效果图如下：\nPygame实现贪吃蛇 一、实验介绍 1.1 实验内容 本节实验将通过Pygame来实现贪吃蛇，最终效果图如下： 1.2 实验知识点  实现贪吃蛇  1.3 实验环境  Python 3.5.1 Xfce终端  1.4 适合人群 本课程难度为一般，属于初级级别课程，适合具有Python基础的用户，熟悉Python基础知识加深巩固。\n1.5 代码获取 本节实验所用到的代码和相关资源文件可以通过下面命令下载到实验楼环境中，作为参照对比进行学习。\n$ wget http://labfile.oss.aliyuncs.com/courses/940/snake.zip\r解压缩至/home/shiyanlou/snake：\n$ unzip snake.zip\r二、实验步骤 3.1 主要思路 我们的贪吃蛇游戏将主要包括三个核心模块，分别是游戏开始模块、游戏运行模块、游戏结束模块。这三个模块是这样配合工作的：先是显示游戏开始模块，然后一个循环一直在游戏运行模块和显示游戏结束模块之间运行。 游戏主要思路\n 绘制一个640*480的窗口 定义小方格的大小（必须要能被640和480整除） 绘制游戏开始的画面，等待按键事件输入 程序主循环里面包含两个模块，一个是游戏运行模块，另一个是显示游戏结束画面的模块 游戏运行模块：  随机初始化设置一个点作为贪吃蛇的起点 以这个点为起点，建立一个长度为3格的贪吃蛇（列表） 初始化一个运动的方向 随机一个苹果的位置 在游戏循环里处理事件 根据按键改变蛇的运动方向 检查游戏是否结束（撞到边界或者撞到自己） 检查贪吃蛇是否吃到苹果 绘制背景，方格，贪吃蛇，苹果，分数等游戏的元素   显示游戏结束画面的模块  绘制Game Over 等待用户按键重新开始游戏    3.2 核心框架 在编写核心模块之前，我们先将这个程序的核心框架和一些必要的方法实现出来，之后再去逐步完善。 我们把蛇身看成是一个个小方格组成的，用常量CELLSIZE表示方格的大小，我们把游戏屏幕也看成是由同样的小方格组成的，我们可以通过方格来与屏幕具体像素联系起来，简化编程，所以有了CELLWIDTH和CELLHEIGHT两个变量。 在main()方法中，我们初始化pygame，并进行一些基本设置，然后显示游戏开始画面，之后进入游戏主循环。 我们定义drawGrid()方法用于绘制所有方格，getRandomLocation()方法用于随机生成苹果的位置，生成的坐标用字典保存，drawApple(coord)方法用于根据生成的坐标字典绘制苹果，同样，drawWorm(wormCoords)方法用于根据贪吃蛇的坐标字典列表绘制贪吃蛇，drawScore(score)方法用于显示分数，terminate()方法用于退出游戏，在我们的游戏开始画面和游戏结束画面中，使用drawPressKeyMsg()方法用于提示按键消息，checkForKeyPress()方法用于检测按键事件以决定是否退出循环进入游戏运行画面。\n# -*- coding: UTF-8 -*-\r # snake.py\r import random, sys, time, pygame\rfrom pygame.locals import *\r# 屏幕刷新率（在这里相当于贪吃蛇的速度）\r FPS = 5\r# 屏幕宽度\r WINDOWWIDTH = 640\r# 屏幕高度\r WINDOWHEIGHT = 480\r# 小方格的大小\r CELLSIZE = 20\r# 断言，屏幕的宽和高必须能被方块大小整除\r assert WINDOWWIDTH % CELLSIZE == 0, \u0026#34;Window width must be a multiple of cell size.\u0026#34;\rassert WINDOWHEIGHT % CELLSIZE == 0, \u0026#34;Window height must be a multiple of cell size.\u0026#34;\r# 横向和纵向的方格数\r CELLWIDTH = int(WINDOWWIDTH / CELLSIZE)\rCELLHEIGHT = int(WINDOWHEIGHT / CELLSIZE)\r# 定义常用颜色\r WHITE = (255, 255, 255)\rBLACK = ( 0, 0, 0)\rRED = (255, 0, 0)\rGREEN = ( 0, 255, 0)\rDARKGREEN = ( 0, 155, 0)\rDARKGRAY = ( 40, 40, 40)\rBGCOLOR = BLACK\r# 定义贪吃蛇的动作\r UP = \u0026#39;up\u0026#39;\rDOWN = \u0026#39;down\u0026#39;\rLEFT = \u0026#39;left\u0026#39;\rRIGHT = \u0026#39;right\u0026#39;\r# 贪吃蛇的头（后面会经常用到）\r HEAD = 0\rdef main():\r# 定义全局变量\r global FPSCLOCK, DISPLAYSURF, BASICFONT\r# 初始化pygame\r pygame.init()\r# 获得pygame时钟\r FPSCLOCK = pygame.time.Clock()\r# 设置屏幕宽高\r DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))\r# 设置基本字体\r BASICFONT = pygame.font.Font(\u0026#39;resources/ARBERKLEY.ttf\u0026#39;, 18)\r# 设置窗口的标题\r pygame.display.set_caption(\u0026#39;Snake\u0026#39;)\r# 显示游戏开始画面\r showStartScreen()\rwhile True: # 这里一直循环于游戏运行时和显示游戏结束画面之间，运行游戏里有一个循环，显示游戏结束画面也有一个循环，两个循环都有相应的return，这样就可以达到切换这两个模块的效果\r # 运行游戏\r runGame()\r# 显示游戏结束画面\r showGameOverScreen()\r# 绘制所有的方格  def drawGrid():\rfor x in range(0, WINDOWWIDTH, CELLSIZE):\r# 绘制垂直线\r pygame.draw.line(DISPLAYSURF, DARKGRAY, (x, 0), (x, WINDOWHEIGHT))\rfor y in range(0, WINDOWHEIGHT, CELLSIZE):\r# 绘制水平线\r pygame.draw.line(DISPLAYSURF, DARKGRAY, (0, y), (WINDOWWIDTH, y))\r# 随机生成一个苹果的坐标位置  def getRandomLocation():\rreturn {\u0026#39;x\u0026#39;: random.randint(0, CELLWIDTH - 1), \u0026#39;y\u0026#39;: random.randint(0, CELLHEIGHT - 1)}\r# 根据coord绘制苹果\r def drawApple(coord):\rx = coord[\u0026#39;x\u0026#39;] * CELLSIZE\ry = coord[\u0026#39;y\u0026#39;] * CELLSIZE\rappleRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE)\rpygame.draw.rect(DISPLAYSURF, RED, appleRect)\r# 根据wormCoords列表绘制贪吃蛇\r def drawWorm(wormCoords):\rfor coord in wormCoords:\rx = coord[\u0026#39;x\u0026#39;] * CELLSIZE\ry = coord[\u0026#39;y\u0026#39;] * CELLSIZE\rwormSegmentRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE)\rpygame.draw.rect(DISPLAYSURF, DARKGREEN, wormSegmentRect)\rwormInnerSegmentRect = pygame.Rect(x + 4, y + 4, CELLSIZE - 8, CELLSIZE - 8)\rpygame.draw.rect(DISPLAYSURF, GREEN, wormInnerSegmentRect)\r# 显示分数  def drawScore(score):\rscoreSurf = BASICFONT.render(\u0026#39;Score: %s\u0026#39; % (score), True, WHITE)\rscoreRect = scoreSurf.get_rect()\rscoreRect.topleft = (WINDOWWIDTH - 120, 10)\rDISPLAYSURF.blit(scoreSurf, scoreRect)\r# 退出游戏\r def terminate():\rpygame.quit()\rsys.exit()\r# 提示按键消息  def drawPressKeyMsg():\rpressKeySurf = BASICFONT.render(\u0026#39;Press a key to play.\u0026#39;, True, DARKGRAY)\rpressKeyRect = pressKeySurf.get_rect()\rpressKeyRect.topleft = (WINDOWWIDTH - 200, WINDOWHEIGHT - 30)\rDISPLAYSURF.blit(pressKeySurf, pressKeyRect)\r# 检测按键事件\r def checkForKeyPress():\rif len(pygame.event.get(QUIT)) \u0026gt; 0:\rterminate()\rkeyUpEvents = pygame.event.get(KEYUP)\rif len(keyUpEvents) == 0:\rreturn None\rif keyUpEvents[0].key == K_ESCAPE:\rterminate()\rreturn keyUpEvents[0].key\r# 显示游戏开始画面\r def showStartScreen():\rpass\r# 游戏运行时\r def runGame():\rpass\r# 显示游戏结束画面\r def showGameOverScreen():\rpass\rif __name__ == \u0026#39;__main__\u0026#39;: main()\r3.3 游戏开始模块 游戏开始画面主要显示游戏名称和提示按键信息，同时调用检测按键事件以确定是否有按键事件产生，若有，则退出开始画面，进入游戏运行画面，或是直接退出游戏。 showStartScreen()的具体实现如下：\n# 显示游戏开始画面\r def showStartScreen():\rDISPLAYSURF.fill(BGCOLOR)\rtitleFont = pygame.font.Font(\u0026#39;resources/ARBERKLEY.ttf\u0026#39;, 100)\rtitleSurf = titleFont.render(\u0026#39;Snake!\u0026#39;, True, GREEN)\rtitleRect = titleSurf.get_rect()\rtitleRect.center = (WINDOWWIDTH / 2, WINDOWHEIGHT / 2)\rDISPLAYSURF.blit(titleSurf, titleRect)\rdrawPressKeyMsg()\rpygame.display.update()\rwhile True:\rif checkForKeyPress():\rpygame.event.get()\rreturn\r3.4 游戏运行模块 为了防止蛇身一出来就离墙太近，导致游戏失败，所以我们的蛇身会离墙有一段距离。产生的随机数范围为（5,CELLWIDTH-6）。我们用字典这种数据结构将坐标存放起来，用列表把这些字典元素包容在一起。wormCoords为蛇身的坐标表示，则wormCoords[0]为蛇头的表示，也就是wormCoords[HEAD]。蛇身的移动实际上就是不断删除尾端，添加头端的过程。 runGame()的具体实现如下：\n# 游戏运行画面\r def runGame():\r# 随机初始化设置一个点作为贪吃蛇的起点\r startx = random.randint(5, CELLWIDTH - 6)\rstarty = random.randint(5, CELLHEIGHT - 6)\r# 以这个点为起点，建立一个长度为3格的贪吃蛇（列表）\r wormCoords = [{\u0026#39;x\u0026#39;: startx, \u0026#39;y\u0026#39;: starty},\r{\u0026#39;x\u0026#39;: startx - 1, \u0026#39;y\u0026#39;: starty},\r{\u0026#39;x\u0026#39;: startx - 2, \u0026#39;y\u0026#39;: starty}]\rdirection = RIGHT # 初始化一个运动的方向\r # 随机一个苹果的位置\r apple = getRandomLocation()\r# 游戏主循环\r while True:\r# 事件处理\r for event in pygame.event.get():\r# 退出事件\r if event.type == QUIT:\rterminate()\r# 按键事件\r elif event.type == KEYDOWN:\r#如果按下的是左键或a键，且当前的方向不是向右，就改变方向，以此类推\r if (event.key == K_LEFT or event.key == K_a) and direction != RIGHT:\rdirection = LEFT\relif (event.key == K_RIGHT or event.key == K_d) and direction != LEFT:\rdirection = RIGHT\relif (event.key == K_UP or event.key == K_w) and direction != DOWN:\rdirection = UP\relif (event.key == K_DOWN or event.key == K_s) and direction != UP:\rdirection = DOWN\relif event.key == K_ESCAPE:\rterminate()\r# 检查贪吃蛇是否撞到撞到边界，即检查蛇头的坐标\r if wormCoords[HEAD][\u0026#39;x\u0026#39;] == -1 or wormCoords[HEAD][\u0026#39;x\u0026#39;] == CELLWIDTH or wormCoords[HEAD][\u0026#39;y\u0026#39;] == -1 or wormCoords[HEAD][\u0026#39;y\u0026#39;] == CELLHEIGHT:\r# game over\r return\r# 检查贪吃蛇是否撞到自己，即检查蛇头的坐标是否等于蛇身的坐标\r for wormBody in wormCoords[1:]:\rif wormBody[\u0026#39;x\u0026#39;] == wormCoords[HEAD][\u0026#39;x\u0026#39;] and wormBody[\u0026#39;y\u0026#39;] == wormCoords[HEAD][\u0026#39;y\u0026#39;]:\r# game over\r return\r# 检查贪吃蛇是否吃到苹果，若没吃到，则删除尾端，蛇身前进一格\r if wormCoords[HEAD][\u0026#39;x\u0026#39;] == apple[\u0026#39;x\u0026#39;] and wormCoords[HEAD][\u0026#39;y\u0026#39;] == apple[\u0026#39;y\u0026#39;]:\r# 不移除蛇的最后一个尾巴格\r # 重新随机生成一个苹果\r apple = getRandomLocation()\relse:\r# 移除蛇的最后一个尾巴格\r del wormCoords[-1]\r# 根据方向，添加一个新的蛇头，以这种方式来移动贪吃蛇\r if direction == UP:\rnewHead = {\u0026#39;x\u0026#39;: wormCoords[HEAD][\u0026#39;x\u0026#39;], \u0026#39;y\u0026#39;: wormCoords[HEAD][\u0026#39;y\u0026#39;] - 1}\relif direction == DOWN:\rnewHead = {\u0026#39;x\u0026#39;: wormCoords[HEAD][\u0026#39;x\u0026#39;], \u0026#39;y\u0026#39;: wormCoords[HEAD][\u0026#39;y\u0026#39;] + 1}\relif direction == LEFT:\rnewHead = {\u0026#39;x\u0026#39;: wormCoords[HEAD][\u0026#39;x\u0026#39;] - 1, \u0026#39;y\u0026#39;: wormCoords[HEAD][\u0026#39;y\u0026#39;]}\relif direction == RIGHT:\rnewHead = {\u0026#39;x\u0026#39;: wormCoords[HEAD][\u0026#39;x\u0026#39;] + 1, \u0026#39;y\u0026#39;: wormCoords[HEAD][\u0026#39;y\u0026#39;]}\r# 插入新的蛇头在数组的最前面\r wormCoords.insert(0, newHead)\r# 绘制背景\r DISPLAYSURF.fill(BGCOLOR)\r# 绘制所有的方格\r drawGrid()\r# 绘制贪吃蛇\r drawWorm(wormCoords)\r# 绘制苹果\r drawApple(apple)\r# 绘制分数（分数为贪吃蛇列表当前的长度-3）\r drawScore(len(wormCoords) - 3)\r# 更新屏幕\r pygame.display.update()\r# 设置帧率\r FPSCLOCK.tick(FPS)\r3.5 游戏结束模块 游戏结束画面与游戏开始画面类似，showGameOverScreen()的具体实现如下：\n# 显示游戏结束画面\r def showGameOverScreen():\rgameOverFont = pygame.font.Font(\u0026#39;resources/ARBERKLEY.ttf\u0026#39;, 50)\rgameSurf = gameOverFont.render(\u0026#39;Game\u0026#39;, True, WHITE)\roverSurf = gameOverFont.render(\u0026#39;Over\u0026#39;, True, WHITE)\rgameRect = gameSurf.get_rect()\roverRect = overSurf.get_rect()\rgameRect.midtop = (WINDOWWIDTH / 2, WINDOWHEIGHT / 2-gameRect.height-10)\roverRect.midtop = (WINDOWWIDTH / 2, WINDOWHEIGHT / 2)\rDISPLAYSURF.blit(gameSurf, gameRect)\rDISPLAYSURF.blit(overSurf, overRect)\rdrawPressKeyMsg()\rpygame.display.update()\rpygame.time.wait(500)\rcheckForKeyPress()\rwhile True:\rif checkForKeyPress():\rpygame.event.get()\rreturn\r3.6 尝试运行代码 if __name__ == \u0026#34;__main__\u0026#34;:\rmain()\r执行 python snake.py\nPygame实现俄罗斯方块 一、实验介绍 1.1 实验内容 本节实验我们将使用Pygame实现经典的俄罗斯方块，最终效果图如下： 1.2 实验知识点  实现俄罗斯方块  1.3 实验环境  Python 3.5.1 Xfce终端  1.4 适合人群 本课程难度为一般，属于初级级别课程，适合具有Python基础的用户，熟悉Python基础知识加深巩固。\n1.5 代码获取 本节实验所用到的代码和相关资源文件可以通过下面命令下载到实验楼环境中，作为参照对比进行学习。\n$ wget http://labfile.oss.aliyuncs.com/courses/940/tetris.zip\r解压缩至/home/shiyanlou/tetris：\n$ unzip tetris.zip\r二、实验步骤 3.1 基本术语 Board：由10乘20个Box组成，Piece就落在这里面。\nBox：组成Piece的其中小方块，是组成Piece的基本单元。\nPiece：从Board顶掉下的东西，游戏者可以翻转和改变位置。每个Piece由4个Box组成。\nShape：不同类型的Piece，这里Shape的名字被叫做T, S, Z, J, L, I, O。如下图所示： Template：用一个列表存放Shape被翻转后的所有可能样式。变量名字如S_SHAPE_TEMPLATE。\n3.2 初始化 BOXSIZE，BOARDWIDTH，BOARDHEIGHT与前面贪吃蛇相关初始化类似，使其与屏幕像素点联系起来。 MOVESIDEWAYSFREQ和MOVEDOWNFREQ两个变量设置相关频率。 XMARGIN和TOPMARGIN分别指Board距窗口两边的距离和上边的距离。 COLORS指组成Piece的小Box的颜色，而LIGHTCOLORS是围绕在小Box周围的颜色，是为了强调出轮廓而设计的。 游戏必须知道每个类型的Piece有多少种Shape，在这里我们用在列表中嵌入含有字符串的列表来构成这个Template，一个Piece类型的Template含有了这个Piece可能变换的所有Shape。 TEMPLATEWIDTH和TEMPLATEHEIGHT则表示组成Template的行和列。 字典PIECES里面储存了所有不同的Template。\n# -*- coding: UTF-8 -*-\r # tetris.py\r import random, time, pygame, sys\rfrom pygame.locals import *\r#设置屏幕刷新率\r FPS = 25\r# 设置窗口宽度\r WINDOWWIDTH = 640\r# 设置窗口高度\r WINDOWHEIGHT = 480\r# 方格大小\r BOXSIZE = 20\r# 放置俄罗斯方块窗口的大小\r BOARDWIDTH = 10 BOARDHEIGHT = 20\r# 代表空的形状\r BLANK = \u0026#39;.\u0026#39;\r# 若一直按下方向左键或右键那么每0.15秒方块才会继续移动\r MOVESIDEWAYSFREQ = 0.15\r# 向下的频率\r MOVEDOWNFREQ = 0.1\r# x方向的边距\r XMARGIN = int((WINDOWWIDTH - BOARDWIDTH * BOXSIZE) / 2)\r# 距离窗口顶部的边距\r TOPMARGIN = WINDOWHEIGHT - (BOARDHEIGHT * BOXSIZE) - 5\r# 定义颜色\r WHITE = (255, 255, 255)\rGRAY = (185, 185, 185)\rBLACK = ( 0, 0, 0)\rRED = (155, 0, 0)\rLIGHTRED = (175, 20, 20)\rGREEN = ( 0, 155, 0)\rLIGHTGREEN = ( 20, 175, 20)\rBLUE = ( 0, 0, 155)\rLIGHTBLUE = ( 20, 20, 175)\rYELLOW = (155, 155, 0)\rLIGHTYELLOW = (175, 175, 20)\rBORDERCOLOR = BLUE\rBGCOLOR = BLACK\rTEXTCOLOR = WHITE\rTEXTSHADOWCOLOR = GRAY\rCOLORS = ( BLUE, GREEN, RED, YELLOW)\rLIGHTCOLORS = (LIGHTBLUE, LIGHTGREEN, LIGHTRED, LIGHTYELLOW)\r# 断言 每一个颜色都应该对应有亮色\r assert len(COLORS) == len(LIGHTCOLORS)\r# 模板的宽高\r TEMPLATEWIDTH = 5\rTEMPLATEHEIGHT = 5\r# 形状_S（S旋转有2种）\r S_SHAPE_TEMPLATE = [[\u0026#39;.....\u0026#39;,\r\u0026#39;.....\u0026#39;,\r\u0026#39;..OO.\u0026#39;,\r\u0026#39;.OO..\u0026#39;,\r\u0026#39;.....\u0026#39;],\r[\u0026#39;.....\u0026#39;,\r\u0026#39;..O..\u0026#39;,\r\u0026#39;..OO.\u0026#39;,\r\u0026#39;...O.\u0026#39;,\r\u0026#39;.....\u0026#39;]]\r# 形状_Z（Z旋转有2种）\r Z_SHAPE_TEMPLATE = [[\u0026#39;.....\u0026#39;,\r\u0026#39;.....\u0026#39;,\r\u0026#39;.OO..\u0026#39;,\r\u0026#39;..OO.\u0026#39;,\r\u0026#39;.....\u0026#39;],\r[\u0026#39;.....\u0026#39;,\r\u0026#39;..O..\u0026#39;,\r\u0026#39;.OO..\u0026#39;,\r\u0026#39;.O...\u0026#39;,\r\u0026#39;.....\u0026#39;]]\r# 形状_I（I旋转有2种）\r I_SHAPE_TEMPLATE = [[\u0026#39;..O..\u0026#39;,\r\u0026#39;..O..\u0026#39;,\r\u0026#39;..O..\u0026#39;,\r\u0026#39;..O..\u0026#39;,\r\u0026#39;.....\u0026#39;],\r[\u0026#39;.....\u0026#39;,\r\u0026#39;.....\u0026#39;,\r\u0026#39;OOOO.\u0026#39;,\r\u0026#39;.....\u0026#39;,\r\u0026#39;.....\u0026#39;]]\r# 形状_O（O旋转只有一个）\r O_SHAPE_TEMPLATE = [[\u0026#39;.....\u0026#39;,\r\u0026#39;.....\u0026#39;,\r\u0026#39;.OO..\u0026#39;,\r\u0026#39;.OO..\u0026#39;,\r\u0026#39;.....\u0026#39;]]\r# 形状_J（J旋转有4种）\r J_SHAPE_TEMPLATE = [[\u0026#39;.....\u0026#39;,\r\u0026#39;.O...\u0026#39;,\r\u0026#39;.OOO.\u0026#39;,\r\u0026#39;.....\u0026#39;,\r\u0026#39;.....\u0026#39;],\r[\u0026#39;.....\u0026#39;,\r\u0026#39;..OO.\u0026#39;,\r\u0026#39;..O..\u0026#39;,\r\u0026#39;..O..\u0026#39;,\r\u0026#39;.....\u0026#39;],\r[\u0026#39;.....\u0026#39;,\r\u0026#39;.....\u0026#39;,\r\u0026#39;.OOO.\u0026#39;,\r\u0026#39;...O.\u0026#39;,\r\u0026#39;.....\u0026#39;],\r[\u0026#39;.....\u0026#39;,\r\u0026#39;..O..\u0026#39;,\r\u0026#39;..O..\u0026#39;,\r\u0026#39;.OO..\u0026#39;,\r\u0026#39;.....\u0026#39;]]\r# 形状_L（L旋转有4种）\r L_SHAPE_TEMPLATE = [[\u0026#39;.....\u0026#39;,\r\u0026#39;...O.\u0026#39;,\r\u0026#39;.OOO.\u0026#39;,\r\u0026#39;.....\u0026#39;,\r\u0026#39;.....\u0026#39;],\r[\u0026#39;.....\u0026#39;,\r\u0026#39;..O..\u0026#39;,\r\u0026#39;..O..\u0026#39;,\r\u0026#39;..OO.\u0026#39;,\r\u0026#39;.....\u0026#39;],\r[\u0026#39;.....\u0026#39;,\r\u0026#39;.....\u0026#39;,\r\u0026#39;.OOO.\u0026#39;,\r\u0026#39;.O...\u0026#39;,\r\u0026#39;.....\u0026#39;],\r[\u0026#39;.....\u0026#39;,\r\u0026#39;.OO..\u0026#39;,\r\u0026#39;..O..\u0026#39;,\r\u0026#39;..O..\u0026#39;,\r\u0026#39;.....\u0026#39;]]\r# 形状_T（T旋转有4种）\r T_SHAPE_TEMPLATE = [[\u0026#39;.....\u0026#39;,\r\u0026#39;..O..\u0026#39;,\r\u0026#39;.OOO.\u0026#39;,\r\u0026#39;.....\u0026#39;,\r\u0026#39;.....\u0026#39;],\r[\u0026#39;.....\u0026#39;,\r\u0026#39;..O..\u0026#39;,\r\u0026#39;..OO.\u0026#39;,\r\u0026#39;..O..\u0026#39;,\r\u0026#39;.....\u0026#39;],\r[\u0026#39;.....\u0026#39;,\r\u0026#39;.....\u0026#39;,\r\u0026#39;.OOO.\u0026#39;,\r\u0026#39;..O..\u0026#39;,\r\u0026#39;.....\u0026#39;],\r[\u0026#39;.....\u0026#39;,\r\u0026#39;..O..\u0026#39;,\r\u0026#39;.OO..\u0026#39;,\r\u0026#39;..O..\u0026#39;,\r\u0026#39;.....\u0026#39;]]\r# 定义一个数据结构存储对应的形状\r PIECES = {\u0026#39;S\u0026#39;: S_SHAPE_TEMPLATE,\r\u0026#39;Z\u0026#39;: Z_SHAPE_TEMPLATE,\r\u0026#39;J\u0026#39;: J_SHAPE_TEMPLATE,\r\u0026#39;L\u0026#39;: L_SHAPE_TEMPLATE,\r\u0026#39;I\u0026#39;: I_SHAPE_TEMPLATE,\r\u0026#39;O\u0026#39;: O_SHAPE_TEMPLATE,\r\u0026#39;T\u0026#39;: T_SHAPE_TEMPLATE}\r3.3 main()方法 主函数的前部分主要创建一些全局变量和在游戏开始之前显示一个开始画面。之后是游戏主循环，循环中首先简单的随机决定采用哪个背景音乐，然后调用runGame()运行游戏，当游戏失败，runGame()就会返回到main()函数，这时会停止背景音乐并且显示游戏失败的画面。当游戏者按下任一个键，显示游戏失败的showTextScreen()函数就会返回到main()函数，游戏循环会再次开始然后继续下一次游戏。\ndef main():\r# 定义全局变量\r global FPSCLOCK, DISPLAYSURF, BASICFONT, BIGFONT\r# 初始化pygame\r pygame.init()\r# 获得pygame时钟\r FPSCLOCK = pygame.time.Clock()\r# 设置窗口\r DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))\r# 设置基础的字体\r BASICFONT = pygame.font.Font(\u0026#39;resources/ARBERKLEY.ttf\u0026#39;, 18)\r# 设置大字体\r BIGFONT = pygame.font.Font(\u0026#39;resources/ARBERKLEY.ttf\u0026#39;, 100)\r# 窗口标题\r pygame.display.set_caption(\u0026#39;Tetris\u0026#39;)\r# 显示开始画面\r showTextScreen(\u0026#39;Tetris\u0026#39;)\r# 游戏主循环\r while True:\r#因实验楼中暂时无法播放音频，故将此段代码注释，同学们可以在自己的电脑上尝试播放\r # 二选一随机播放背景音乐\r # if random.randint(0, 1) == 0:\r # pygame.mixer.music.load(\u0026#39;resources/tetrisb.mid\u0026#39;)\r # else:\r # pygame.mixer.music.load(\u0026#39;resources/tetrisc.mid\u0026#39;)\r # pygame.mixer.music.play(-1, 0.0)\r # 运行游戏\r runGame()\r# 退出游戏后，结束播放音乐\r pygame.mixer.music.stop()\r# 显示结束画面\r showTextScreen(\u0026#39;Game Over\u0026#39;)\r3.4 基本模块 在开始编写runGame()方法之前，我们不妨先来定义一些基本模块，这些模块在之后都将被用到。 我们可以定义一个退出方法，以便需要的时候退出游戏：\n# 退出\r def terminate():\rpygame.quit()\rsys.exit()\r此外，玩家可能会按键退出游戏，当玩家按下Esc键时，我们即调用刚刚定义的退出方法来退出游戏，相关监测方法如下：\n# 检查是否有退出事件\r def checkForQuit():\r# 获得所有QUIT事件\r for event in pygame.event.get(QUIT):\r# 若存在任何QUIT事件，则终止\r terminate()\r# 获得所有KEYUP事件\r for event in pygame.event.get(KEYUP):\rif event.key == K_ESCAPE:\r# 若KEYUP事件是Esc键，则终止\r terminate()\r# 把其他的KEYUP事件对象放回来\r pygame.event.post(event)\r与此同时，我们还需要定义一个用于监测是否有按键被按下的方法，当处于开始、结束、暂停画面时，可以调用该方法，以便程序退出当前画面。\n# 检查是否有按键被按下\r def checkForKeyPress():\r# 通过事件队列寻找KEYUP事件\r # 从事件队列删除KEYDOWN事件\r checkForQuit()\rfor event in pygame.event.get([KEYDOWN, KEYUP]):\rif event.type == KEYDOWN:\rcontinue\rreturn event.key\rreturn None\r考虑到我们需要在屏幕上显示文字，不妨直接创建相关方法，以便程序复用，如下，此程序接收三个参数：要显示的文字、要显示文字的字体、要显示文字的颜色，它会返回相应的文本对象，以方便使用。\n# 创建文本绘制对象\r def makeTextObjs(text, font, color):\rsurf = font.render(text, True, color)\rreturn surf, surf.get_rect()\r游戏开始画面、游戏结束画面以及游戏暂停画面可用一个方法来实现，我们向该方法中传递相关的文本参数以显示相关的画面，同时我们在循环中调用之前的checkForKeyPress()方法，以监测是否有按键被按下，从而实现是否从当前画面中退出：\n# 显示开始、暂停、结束画面\r def showTextScreen(text):\r# 这个函数用于在屏幕中央显示大文本，直到按下任意键\r # 绘制文字阴影\r titleSurf, titleRect = makeTextObjs(text, BIGFONT, TEXTSHADOWCOLOR)\rtitleRect.center = (int(WINDOWWIDTH / 2), int(WINDOWHEIGHT / 2))\rDISPLAYSURF.blit(titleSurf, titleRect)\r# 绘制文字\r titleSurf, titleRect = makeTextObjs(text, BIGFONT, TEXTCOLOR)\rtitleRect.center = (int(WINDOWWIDTH / 2) - 3, int(WINDOWHEIGHT / 2) - 3)\rDISPLAYSURF.blit(titleSurf, titleRect)\r# 绘制额外的\u0026#34;Press a key to play.\u0026#34;文字\r pressKeySurf, pressKeyRect = makeTextObjs(\u0026#39;Press a key to play.\u0026#39;, BASICFONT, TEXTCOLOR)\rpressKeyRect.center = (int(WINDOWWIDTH / 2), int(WINDOWHEIGHT / 2) + 100)\rDISPLAYSURF.blit(pressKeySurf, pressKeyRect)\rwhile checkForKeyPress() == None:\rpygame.display.update()\rFPSCLOCK.tick()\r在游戏开始之前，我们需要一个空的Board框，我们用一个二维列表表示Board框，列表中的每一项都为BLANK：\n# 清空Board\r def getBlankBoard():\rboard = []\rfor i in range(BOARDWIDTH):\rboard.append([BLANK] * BOARDHEIGHT)\rreturn board\r游戏运行时，每次都会有一个新的Piece从顶部落下，我们用一个字典来表示Piece，字典中的键包括Shape、相应Shape的方向、起始位置、以及颜色，获得新Piece的方法如下：\n# 随机获得一个新的Piece（形状，方向，颜色）\r def getNewPiece():\rshape = random.choice(list(PIECES.keys()))\rnewPiece = {\u0026#39;shape\u0026#39;: shape,\r\u0026#39;rotation\u0026#39;: random.randint(0, len(PIECES[shape]) - 1),\r\u0026#39;x\u0026#39;: int(BOARDWIDTH / 2) - int(TEMPLATEWIDTH / 2), # x居中\r \u0026#39;y\u0026#39;: -2, # y在屏幕的上方，小于0\r \u0026#39;color\u0026#39;: random.randint(0, len(COLORS)-1)}\rreturn newPiece\r获取新Piece之后，就要将它添加到Board框中，添加的原理就是将Board框中对应坐标的Box绘制成相应Piece的颜色：\n# 将一个Piece添加到Board中\r def addToBoard(board, piece):\rfor x in range(TEMPLATEWIDTH):\rfor y in range(TEMPLATEHEIGHT):\rif PIECES[piece[\u0026#39;shape\u0026#39;]][piece[\u0026#39;rotation\u0026#39;]][y][x] != BLANK:\rboard[x + piece[\u0026#39;x\u0026#39;]][y + piece[\u0026#39;y\u0026#39;]] = piece[\u0026#39;color\u0026#39;]\r当Piece着陆之后在Board外时，游戏结束，因此我们需要一个判断Board边界的方法：\n# Board边界\r def isOnBoard(x, y):\rreturn x \u0026gt;= 0 and x \u0026lt; BOARDWIDTH and y \u0026lt; BOARDHEIGHT\r刚刚那种判断游戏结束的方法，我们可以将其抽象出来，看成是检查Piece的当前位置是否合法，因为不光是在判断游戏结束时调用它，在调整Piece形状时也需要调用，判断调整形状后的Piece在当前位置中是否容得下。\n# Piece在当前的Board里是否是一个合法可用的位置\r def isValidPosition(board, piece, adjX=0, adjY=0):\r# 若Piece在Board内并且无碰撞，则返回True\r for x in range(TEMPLATEWIDTH):\rfor y in range(TEMPLATEHEIGHT):\risAboveBoard = y + piece[\u0026#39;y\u0026#39;] + adjY \u0026lt; 0\rif isAboveBoard or PIECES[piece[\u0026#39;shape\u0026#39;]][piece[\u0026#39;rotation\u0026#39;]][y][x] == BLANK:\rcontinue\rif not isOnBoard(x + piece[\u0026#39;x\u0026#39;] + adjX, y + piece[\u0026#39;y\u0026#39;] + adjY):\rreturn False\rif board[x + piece[\u0026#39;x\u0026#39;] + adjX][y + piece[\u0026#39;y\u0026#39;] + adjY] != BLANK:\rreturn False\rreturn True\r此外，当游戏中某一行被填满时，我们将移除这一行，因此我们需要一个判断某行是否填满的方法，判断的原理就是看相应的这一行列表中的项是否为BLANK：\n# 判断当前的这行是否被全部填满\r def isCompleteLine(board, y):\rfor x in range(BOARDWIDTH):\rif board[x][y] == BLANK:\rreturn False\rreturn True\r还需要一个移除某行的方法，也就是将这一行上面的每一行都下降一行，同时还应该返回完成填满的总行数，这个值将作为玩家的分值，也就是说每成功移除一行，玩家分数加1：\n# 检查每一行，移除完成填满的一行，将这一行上面的所有的都下降一行，返回完成填满的总行数\r def removeCompleteLines(board):\rnumLinesRemoved = 0\r# 从-1开始从下往上检查每一行\r y = BOARDHEIGHT - 1 while y \u0026gt;= 0:\rif isCompleteLine(board, y):\rfor pullDownY in range(y, 0, -1):\rfor x in range(BOARDWIDTH):\rboard[x][pullDownY] = board[x][pullDownY-1]\rfor x in range(BOARDWIDTH):\rboard[x][0] = BLANK\rnumLinesRemoved += 1\relse:\ry -= 1\rreturn numLinesRemoved\r随着游戏分数的越来越大，相应的等级也应越来越大，等级是当前消除行数除以10，我们假设刚开始时等级为1，随着等级的不断增大，下落频率应相应的减小，如下所示：\n# 根据分数来计算等级和下落的频率\r def calculateLevelAndFallFreq(score):\rlevel = int(score / 10) + 1\rfallFreq = 0.27 - (level * 0.02)\rreturn level, fallFreq\r3.5 runGame()方法 在游戏开始和Piece掉落之前，我们需要初始化一些跟游戏开始相关的变量。fallingPiece变量被赋值成当前掉落的变量，nextPiece变量被赋值成游戏者可以在屏幕NEXT区域看见的下一个Piece。 游戏主循环中，fallingPiece变量在Piece着陆后被设置成None。这意味着nextPiece变量中的下一个Piece应该被赋值给fallingPiece变量，然后一个随机的Piece又会被赋值给nextPiece变量。lastFallTime变量也被赋值成当前时间，这样我们就可以通过fallFreq变量控制Piece下落的频率。 事件循环主要处理当翻转方块、移动方块时或者暂停游戏时的一些事情。若游戏暂停，我们应该隐藏掉游戏界面以防止游戏者作弊（否则游戏者会看着画面思考怎么处理方块），用DISPLAYSURF.fill(BGCOLOR)就可以实现这个效果。停止按下方向键或ASD键会把movingLeft，movingRight，movingDown变量设置为False，表明游戏者不再想要在此方向上移动方块。当左方向键按下（而且往左移动是有效的，通过调用isVaildPosition()函数知道的），那么我们应该改变一个方块的位置使其向左移动一格。 如果方向键上或W键被按下，那么就会翻转方块，就是将储存在fallingPiece字典中的‘rotation’键的键值加1，然而，当增加的'rotation'键值大于所有当前类型方块的形状的数目的话（此变量储存在len(SHAPES[fallingPiece[\u0026lsquo;shape\u0026rsquo;]])变量中），那么它翻转到最初的形状。如果翻转后的形状因为其中的一些小方块已经超过边框的范围而无效，那么我们就要把它变回原来的形状通过将fallingPiece[\u0026lsquo;rotation\u0026rsquo;])减去1，同理，按Q键执行反向翻转时则是加1。 当游戏者按下空格键，方块将会迅速的下落至着陆。程序首先需要找出到它着陆需要下降个多少个格子，其中有关moving的三个变量都要被设置为False（保证程序后面部分的代码知道游戏者已经停止了按下所有的方向键）。 方块自然下落的速率由lastFallTime变量决定。如果自从上个Piece掉落了一个格子后过去了足够的时间，那么我们就会再让Piece移动一个格子。\n# 运行游戏\r def runGame():\r# 在游戏开始前初始化变量\r # 获得一个空的board\r board = getBlankBoard()\r# 最后向下移动的时刻\r lastMoveDownTime = time.time()\r# 最后侧向移动的时刻\r lastMoveSidewaysTime = time.time()\r# 最后的下降时间\r lastFallTime = time.time()\r# 是否可以 向下，向左，向右\r # 注意:这里没有向上可用\r movingDown = False movingLeft = False\rmovingRight = False\r# 分数\r score = 0\r# 根据分数计算等级和下降的频率\r level, fallFreq = calculateLevelAndFallFreq(score)\r# 获得新的形状（当前的形状）\r fallingPiece = getNewPiece()\r# 获得下一个形状\r nextPiece = getNewPiece()\r# 游戏循环体\r while True:\r# 当前没有下降的形状\r if fallingPiece == None:\r# 重新获得新的形状和下一个形状\r fallingPiece = nextPiece\rnextPiece = getNewPiece()\r# 重置最后下降的时间\r lastFallTime = time.time()\r# 判断界面上是否还有空位（方块是否到顶），没有则结束游戏\r if not isValidPosition(board, fallingPiece):\rreturn\r# 检查是否有退出事件\r checkForQuit()\r# 事件处理循环\r for event in pygame.event.get():\r# KEYUP事件处理\r if event.type == KEYUP:\r# 用户按P键暂停\r if (event.key == K_p):\rDISPLAYSURF.fill(BGCOLOR)\r#停止音乐\r pygame.mixer.music.stop()\r# 显示暂停界面，直到按任意键继续\r showTextScreen(\u0026#39;Paused\u0026#39;)\r#因实验楼中暂时无法播放音频，故将此段代码注释，同学们可以在自己的电脑上尝试播放\r # 继续循环音乐\r # pygame.mixer.music.play(-1, 0.0)\r # 重置各种时间\r lastFallTime = time.time()\rlastMoveDownTime = time.time()\rlastMoveSidewaysTime = time.time()\relif (event.key == K_LEFT or event.key == K_a):\rmovingLeft = False\relif (event.key == K_RIGHT or event.key == K_d):\rmovingRight = False\relif (event.key == K_DOWN or event.key == K_s):\rmovingDown = False\r# KEYDOWN事件处理\r elif event.type == KEYDOWN:\r# 左右移动piece\r if (event.key == K_LEFT or event.key == K_a) and isValidPosition(board, fallingPiece, adjX=-1):\rfallingPiece[\u0026#39;x\u0026#39;] -= 1\rmovingLeft = True\rmovingRight = False\rlastMoveSidewaysTime = time.time()\relif (event.key == K_RIGHT or event.key == K_d) and isValidPosition(board, fallingPiece, adjX=1):\rfallingPiece[\u0026#39;x\u0026#39;] += 1\rmovingRight = True\rmovingLeft = False\rlastMoveSidewaysTime = time.time()\r# UP或W键 旋转piece (在有空间旋转的前提下)\r # 正向旋转\r elif (event.key == K_UP or event.key == K_w):\rfallingPiece[\u0026#39;rotation\u0026#39;] = (fallingPiece[\u0026#39;rotation\u0026#39;] + 1) % len(PIECES[fallingPiece[\u0026#39;shape\u0026#39;]])\rif not isValidPosition(board, fallingPiece):\rfallingPiece[\u0026#39;rotation\u0026#39;] = (fallingPiece[\u0026#39;rotation\u0026#39;] - 1) % len(PIECES[fallingPiece[\u0026#39;shape\u0026#39;]])\r# Q键，反向旋转\r elif (event.key == K_q):\rfallingPiece[\u0026#39;rotation\u0026#39;] = (fallingPiece[\u0026#39;rotation\u0026#39;] - 1) % len(PIECES[fallingPiece[\u0026#39;shape\u0026#39;]])\rif not isValidPosition(board, fallingPiece):\rfallingPiece[\u0026#39;rotation\u0026#39;] = (fallingPiece[\u0026#39;rotation\u0026#39;] + 1) % len(PIECES[fallingPiece[\u0026#39;shape\u0026#39;]])\r# DOWN或S键 使piece下降得更快\r elif (event.key == K_DOWN or event.key == K_s):\rmovingDown = True\rif isValidPosition(board, fallingPiece, adjY=1):\rfallingPiece[\u0026#39;y\u0026#39;] += 1\rlastMoveDownTime = time.time()\r# 空格键，直接下降到最下面且可用的地方\r elif event.key == K_SPACE:\rmovingDown = False\rmovingLeft = False\rmovingRight = False\rfor i in range(1, BOARDHEIGHT):\rif not isValidPosition(board, fallingPiece, adjY=i):\rbreak\rfallingPiece[\u0026#39;y\u0026#39;] += i - 1\r# 根据记录的用户输入方向的变量来移动piece\r if (movingLeft or movingRight) and time.time() - lastMoveSidewaysTime \u0026gt; MOVESIDEWAYSFREQ:\rif movingLeft and isValidPosition(board, fallingPiece, adjX=-1):\rfallingPiece[\u0026#39;x\u0026#39;] -= 1\relif movingRight and isValidPosition(board, fallingPiece, adjX=1):\rfallingPiece[\u0026#39;x\u0026#39;] += 1\rlastMoveSidewaysTime = time.time()\rif movingDown and time.time() - lastMoveDownTime \u0026gt; MOVEDOWNFREQ and isValidPosition(board, fallingPiece, adjY=1):\rfallingPiece[\u0026#39;y\u0026#39;] += 1\rlastMoveDownTime = time.time()\r# 自动下降piece\r if time.time() - lastFallTime \u0026gt; fallFreq:\rif not isValidPosition(board, fallingPiece, adjY=1):\raddToBoard(board, fallingPiece)\rscore += removeCompleteLines(board)\rlevel, fallFreq = calculateLevelAndFallFreq(score)\rfallingPiece = None\relse:\rfallingPiece[\u0026#39;y\u0026#39;] += 1\rlastFallTime = time.time()\r# 绘制屏幕上的所有东西\r DISPLAYSURF.fill(BGCOLOR)\rdrawBoard(board)\rdrawStatus(score, level)\rdrawNextPiece(nextPiece)\rif fallingPiece != None:\rdrawPiece(fallingPiece)\rpygame.display.update()\rFPSCLOCK.tick(FPS)\r3.6 绘制屏幕 之前的编程，为了简化操作，我们使用的是Board的坐标，在绘制图形之前，我们需要把Box的坐标转换为相应的像素坐标：\n# 根据Board的坐标转化成像素坐标\r def convertToPixelCoords(boxx, boxy):\rreturn (XMARGIN + (boxx * BOXSIZE)), (TOPMARGIN + (boxy * BOXSIZE))\r绘制Box，：\n# 绘制Box\r def drawBox(boxx, boxy, color, pixelx=None, pixely=None):\r# 使用Board的坐标绘制单个Box（一个Piece含有4个Box），若像素坐标pixelx、pixely被指定，则直接使用像素坐标（用于NextPiece区域）\r if color == BLANK:\rreturn\rif pixelx == None and pixely == None:\rpixelx, pixely = convertToPixelCoords(boxx, boxy)\rpygame.draw.rect(DISPLAYSURF, COLORS[color], (pixelx + 1, pixely + 1, BOXSIZE - 1, BOXSIZE - 1))\rpygame.draw.rect(DISPLAYSURF, LIGHTCOLORS[color], (pixelx + 1, pixely + 1, BOXSIZE - 4, BOXSIZE - 4))\r绘制Board主要包括绘制Board边框、绘制Board背景以及绘制Board中的Box：\n# 绘制Board\r def drawBoard(board):\r# 绘制Board边框\r pygame.draw.rect(DISPLAYSURF, BORDERCOLOR, (XMARGIN - 3, TOPMARGIN - 7, (BOARDWIDTH * BOXSIZE) + 8, (BOARDHEIGHT * BOXSIZE) + 8), 5)\r# 绘制Board背景\r pygame.draw.rect(DISPLAYSURF, BGCOLOR, (XMARGIN, TOPMARGIN, BOXSIZE * BOARDWIDTH, BOXSIZE * BOARDHEIGHT))\r# 绘制Board中的Box\r for x in range(BOARDWIDTH):\rfor y in range(BOARDHEIGHT):\rdrawBox(x, y, board[x][y])\r绘制分数、等级等状态信息：\n# 绘制游戏分数、等级信息\r def drawStatus(score, level):\r# 绘制分数文本\r scoreSurf = BASICFONT.render(\u0026#39;Score: %s\u0026#39; % score, True, TEXTCOLOR)\rscoreRect = scoreSurf.get_rect()\rscoreRect.topleft = (WINDOWWIDTH - 150, 20)\rDISPLAYSURF.blit(scoreSurf, scoreRect)\r# 绘制等级文本\r levelSurf = BASICFONT.render(\u0026#39;Level: %s\u0026#39; % level, True, TEXTCOLOR)\rlevelRect = levelSurf.get_rect()\rlevelRect.topleft = (WINDOWWIDTH - 150, 50)\rDISPLAYSURF.blit(levelSurf, levelRect)\r绘制Piece:\n# 绘制各种形状Piece（S,Z,I,O,J,L,T）\r def drawPiece(piece, pixelx=None, pixely=None):\rshapeToDraw = PIECES[piece[\u0026#39;shape\u0026#39;]][piece[\u0026#39;rotation\u0026#39;]]\rif pixelx == None and pixely == None:\r# 若pixelx、pixely没有被指定，则使用piece数据结构中存储的位置\r pixelx, pixely = convertToPixelCoords(piece[\u0026#39;x\u0026#39;], piece[\u0026#39;y\u0026#39;])\r# 绘制组成Piece的每个Box\r for x in range(TEMPLATEWIDTH):\rfor y in range(TEMPLATEHEIGHT):\rif shapeToDraw[y][x] != BLANK:\rdrawBox(None, None, piece[\u0026#39;color\u0026#39;], pixelx + (x * BOXSIZE), pixely + (y * BOXSIZE))\r绘制NextPiece区域显示的内容：\n# 绘制提示信息，下一个Piece\r def drawNextPiece(piece):\r# 绘制\u0026#34;Next\u0026#34;文本\r nextSurf = BASICFONT.render(\u0026#39;Next:\u0026#39;, True, TEXTCOLOR)\rnextRect = nextSurf.get_rect()\rnextRect.topleft = (WINDOWWIDTH - 120, 80)\rDISPLAYSURF.blit(nextSurf, nextRect)\r# 绘制NextPiece\r drawPiece(piece, pixelx=WINDOWWIDTH-120, pixely=100)\r3.7 尝试运行代码 if __name__ == \u0026#34;__main__\u0026#34;:\rmain()\r执行 python3 tetris.py\n","id":4,"section":"posts","summary":"Pygame基础讲解 一、实验介绍 1.1 实验内容 在本节课中，我们将讲解Pygame的常用对象及其操作，包括图形、动画、文字、音频等，确保同学们对P","tags":["tutorial","pygame"],"title":"贪吃蛇","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/12/%E5%9F%BA%E4%BA%8Epygame%E5%BC%80%E5%8F%91%E8%B4%AA%E5%90%83%E8%9B%87%E5%92%8C%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/","year":"2019"},{"content":"This tutorial will show you how to create a simple theme in Hugo\nCreating a New Theme Introduction This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I’ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won’t cover using CSS to style your theme.\nWe’ll start with creating a new site with a very basic template. Then we’ll add in a few pages and posts. With small variations on that, you will be able to create many different types of web sites.\nIn this tutorial, commands that you enter will start with the “$” prompt. The output will follow. Lines that start with “#” are comments that I’ve added to explain a point. When I show updates to a file, the “:wq” on the last line means to save the file.\nHere’s an example:\n## this is a comment\r$ echo this is a command\rthis is a command\r## edit the file\r$ vi foo.md\r+++\rdate = \u0026quot;2014-09-28\u0026quot;\rtitle = \u0026quot;creating a new theme\u0026quot;\r+++\rbah and humbug\r:wq\r## show it\r$ cat foo.md\r+++\rdate = \u0026quot;2014-09-28\u0026quot;\rtitle = \u0026quot;creating a new theme\u0026quot;\r+++\rbah and humbug\r$\rSome Definitions There are a few concepts that you need to understand before creating a theme.\nSkins Skins are the files responsible for the look and feel of your site. It’s the CSS that controls colors and fonts, it’s the Javascript that determines actions and reactions. It’s also the rules that Hugo uses to transform your content into the HTML that the site will serve to visitors.\nYou have two ways to create a skin. The simplest way is to create it in the layouts/ directory. If you do, then you don’t have to worry about configuring Hugo to recognize it. The first place that Hugo will look for rules and files is in the layouts/ directory so it will always find the skin.\nYour second choice is to create it in a sub-directory of the themes/ directory. If you do, then you must always tell Hugo where to search for the skin. It’s extra work, though, so why bother with it?\nThe difference between creating a skin in layouts/ and creating it in themes/ is very subtle. A skin in layouts/ can’t be customized without updating the templates and static files that it is built from. A skin created in themes/, on the other hand, can be and that makes it easier for other people to use it.\nThe rest of this tutorial will call a skin created in the themes/ directory a theme.\nNote that you can use this tutorial to create a skin in the layouts/ directory if you wish to. The main difference will be that you won’t need to update the site’s configuration file to use a theme.\nThe Home Page The home page, or landing page, is the first page that many visitors to a site see. It is the index.html file in the root directory of the web site. Since Hugo writes files to the public/ directory, our home page is public/index.html.\nSite Configuration File When Hugo runs, it looks for a configuration file that contains settings that override default values for the entire site. The file can use TOML, YAML, or JSON. I prefer to use TOML for my configuration files. If you prefer to use JSON or YAML, you’ll need to translate my examples. You’ll also need to change the name of the file since Hugo uses the extension to determine how to process it.\nHugo translates Markdown files into HTML. By default, Hugo expects to find Markdown files in your content/ directory and template files in your themes/ directory. It will create HTML files in your public/ directory. You can change this by specifying alternate locations in the configuration file.\nContent Content is stored in text files that contain two sections. The first section is the “front matter,” which is the meta-information on the content. The second section contains Markdown that will be converted to HTML.\nFront Matter The front matter is information about the content. Like the configuration file, it can be written in TOML, YAML, or JSON. Unlike the configuration file, Hugo doesn’t use the file’s extension to know the format. It looks for markers to signal the type. TOML is surrounded by “+++”, YAML by “---”, and JSON is enclosed in curly braces. I prefer to use TOML, so you’ll need to translate my examples if you prefer YAML or JSON.\nThe information in the front matter is passed into the template before the content is rendered into HTML.\nMarkdown Content is written in Markdown which makes it easier to create the content. Hugo runs the content through a Markdown engine to create the HTML which will be written to the output file.\nTemplate Files Hugo uses template files to render content into HTML. Template files are a bridge between the content and presentation. Rules in the template define what content is published, where it’s published to, and how it will rendered to the HTML file. The template guides the presentation by specifying the style to use.\nThere are three types of templates: single, list, and partial. Each type takes a bit of content as input and transforms it based on the commands in the template.\nHugo uses its knowledge of the content to find the template file used to render the content. If it can’t find a template that is an exact match for the content, it will shift up a level and search from there. It will continue to do so until it finds a matching template or runs out of templates to try. If it can’t find a template, it will use the default template for the site.\nPlease note that you can use the front matter to influence Hugo’s choice of templates.\nSingle Template A single template is used to render a single piece of content. For example, an article or post would be a single piece of content and use a single template.\nList Template A list template renders a group of related content. That could be a summary of recent postings or all articles in a category. List templates can contain multiple groups.\nThe homepage template is a special type of list template. Hugo assumes that the home page of your site will act as the portal for the rest of the content in the site.\nPartial Template A partial template is a template that can be included in other templates. Partial templates must be called using the “partial” template command. They are very handy for rolling up common behavior. For example, your site may have a banner that all pages use. Instead of copying the text of the banner into every single and list template, you could create a partial with the banner in it. That way if you decide to change the banner, you only have to change the partial template.\nCreate a New Site Let’s use Hugo to create a new web site. I’m a Mac user, so I’ll create mine in my home directory, in the Sites folder. If you’re using Linux, you might have to create the folder first.\nThe “new site” command will create a skeleton of a site. It will give you the basic directory structure and a useable configuration file.\n$ hugo new site ~/Sites/zafta\r$ cd ~/Sites/zafta\r$ ls -l\rtotal 8\rdrwxr-xr-x 7 quoha staff 238 Sep 29 16:49 .\rdrwxr-xr-x 3 quoha staff 102 Sep 29 16:49 ..\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes\r-rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static\r$\rTake a look in the content/ directory to confirm that it is empty.\nThe other directories (archetypes/, layouts/, and static/) are used when customizing a theme. That’s a topic for a different tutorial, so please ignore them for now.\nGenerate the HTML For the New Site Running the hugo command with no options will read all the available content and generate the HTML files. It will also copy all static files (that’s everything that’s not content). Since we have an empty site, it won’t do much, but it will do it very quickly.\n$ hugo --verbose\rINFO: 2014/09/29 Using config file: config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]\rWARN: 2014/09/29 Unable to locate layout: [404.html]\r0 draft content 0 future content 0 pages created 0 tags created\r0 categories created\rin 2 ms\r$ The “--verbose” flag gives extra information that will be helpful when we build the template. Every line of the output that starts with “INFO:” or “WARN:” is present because we used that flag. The lines that start with “WARN:” are warning messages. We’ll go over them later.\nWe can verify that the command worked by looking at the directory again.\n$ ls -l\rtotal 8\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes\r-rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts\rdrwxr-xr-x 4 quoha staff 136 Sep 29 17:02 public\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static\r$\rSee that new public/ directory? Hugo placed all generated content there. When you’re ready to publish your web site, that’s the place to start. For now, though, let’s just confirm that we have what we’d expect from a site with no content.\n$ ls -l public\rtotal 16\r-rw-r--r-- 1 quoha staff 416 Sep 29 17:02 index.xml\r-rw-r--r-- 1 quoha staff 262 Sep 29 17:02 sitemap.xml\r$ Hugo created two XML files, which is standard, but there are no HTML files.\nTest the New Site Verify that you can run the built-in web server. It will dramatically shorten your development cycle if you do. Start it by running the “server” command. If it is successful, you will see output similar to the following:\n$ hugo server --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]\rWARN: 2014/09/29 Unable to locate layout: [404.html]\r0 draft content 0 future content 0 pages created 0 tags created\r0 categories created\rin 2 ms\rServing pages from /Users/quoha/Sites/zafta/public\rWeb Server is available at http://localhost:1313\rPress Ctrl+C to stop\rConnect to the listed URL (it’s on the line that starts with “Web Server”). If everything is working correctly, you should get a page that shows the following:\nindex.xml\rsitemap.xml\rThat’s a listing of your public/ directory. Hugo didn’t create a home page because our site has no content. When there’s no index.html file in a directory, the server lists the files in the directory, which is what you should see in your browser.\nLet’s go back and look at those warnings again.\nWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]\rWARN: 2014/09/29 Unable to locate layout: [404.html]\rThat second warning is easier to explain. We haven’t created a template to be used to generate “page not found errors.” The 404 message is a topic for a separate tutorial.\nNow for the first warning. It is for the home page. You can tell because the first layout that it looked for was “index.html.” That’s only used by the home page.\nI like that the verbose flag causes Hugo to list the files that it’s searching for. For the home page, they are index.html, _default/list.html, and _default/single.html. There are some rules that we’ll cover later that explain the names and paths. For now, just remember that Hugo couldn’t find a template for the home page and it told you so.\nAt this point, you’ve got a working installation and site that we can build upon. All that’s left is to add some content and a theme to display it.\nCreate a New Theme Hugo doesn’t ship with a default theme. There are a few available (I counted a dozen when I first installed Hugo) and Hugo comes with a command to create new themes.\nWe’re going to create a new theme called “zafta.” Since the goal of this tutorial is to show you how to fill out the files to pull in your content, the theme will not contain any CSS. In other words, ugly but functional.\nAll themes have opinions on content and layout. For example, Zafta uses “post” over “blog”. Strong opinions make for simpler templates but differing opinions make it tougher to use themes. When you build a theme, consider using the terms that other themes do.\nCreate a Skeleton Use the hugo “new” command to create the skeleton of a theme. This creates the directory structure and places empty files for you to fill out.\n$ hugo new theme zafta\r$ ls -l\rtotal 8\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes\r-rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts\rdrwxr-xr-x 4 quoha staff 136 Sep 29 17:02 public\rdrwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static\rdrwxr-xr-x 3 quoha staff 102 Sep 29 17:31 themes\r$ find themes -type f | xargs ls -l\r-rw-r--r-- 1 quoha staff 1081 Sep 29 17:31 themes/zafta/LICENSE.md\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/archetypes/default.md\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/single.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/header.html\r-rw-r--r-- 1 quoha staff 93 Sep 29 17:31 themes/zafta/theme.toml\r$ The skeleton includes templates (the files ending in .html), license file, a description of your theme (the theme.toml file), and an empty archetype.\nPlease take a minute to fill out the theme.toml and LICENSE.md files. They’re optional, but if you’re going to be distributing your theme, it tells the world who to praise (or blame). It’s also nice to declare the license so that people will know how they can use the theme.\n$ vi themes/zafta/theme.toml\rauthor = \u0026quot;michael d henderson\u0026quot;\rdescription = \u0026quot;a minimal working template\u0026quot;\rlicense = \u0026quot;MIT\u0026quot;\rname = \u0026quot;zafta\u0026quot;\rsource_repo = \u0026quot;\u0026quot;\rtags = [\u0026quot;tags\u0026quot;, \u0026quot;categories\u0026quot;]\r:wq\r## also edit themes/zafta/LICENSE.md and change\r## the bit that says \u0026quot;YOUR_NAME_HERE\u0026quot;\rNote that the the skeleton’s template files are empty. Don’t worry, we’ll be changing that shortly.\n$ find themes/zafta -name '*.html' | xargs ls -l\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/single.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/header.html\r$\rUpdate the Configuration File to Use the Theme Now that we’ve got a theme to work with, it’s a good idea to add the theme name to the configuration file. This is optional, because you can always add “-t zafta” on all your commands. I like to put it the configuration file because I like shorter command lines. If you don’t put it in the configuration file or specify it on the command line, you won’t use the template that you’re expecting to.\nEdit the file to add the theme, add a title for the site, and specify that all of our content will use the TOML format.\n$ vi config.toml\rtheme = \u0026quot;zafta\u0026quot;\rbaseurl = \u0026quot;\u0026quot;\rlanguageCode = \u0026quot;en-us\u0026quot;\rtitle = \u0026quot;zafta - totally refreshing\u0026quot;\rMetaDataFormat = \u0026quot;toml\u0026quot;\r:wq\r$\rGenerate the Site Now that we have an empty theme, let’s generate the site again.\n$ hugo --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content 0 future content 0 pages created 0 tags created\r0 categories created\rin 2 ms\r$\rDid you notice that the output is different? The warning message for the home page has disappeared and we have an additional information line saying that Hugo is syncing from the theme’s directory.\nLet’s check the public/ directory to see what Hugo’s created.\n$ ls -l public\rtotal 16\rdrwxr-xr-x 2 quoha staff 68 Sep 29 17:56 css\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:56 index.html\r-rw-r--r-- 1 quoha staff 407 Sep 29 17:56 index.xml\rdrwxr-xr-x 2 quoha staff 68 Sep 29 17:56 js\r-rw-r--r-- 1 quoha staff 243 Sep 29 17:56 sitemap.xml\r$\rNotice four things:\n Hugo created a home page. This is the file public/index.html. Hugo created a css/ directory. Hugo created a js/ directory. Hugo claimed that it created 0 pages. It created a file and copied over static files, but didn’t create any pages. That’s because it considers a “page” to be a file created directly from a content file. It doesn’t count things like the index.html files that it creates automatically.  The Home Page Hugo supports many different types of templates. The home page is special because it gets its own type of template and its own template file. The file, layouts/index.html, is used to generate the HTML for the home page. The Hugo documentation says that this is the only required template, but that depends. Hugo’s warning message shows that it looks for three different templates:\nWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]\rIf it can’t find any of these, it completely skips creating the home page. We noticed that when we built the site without having a theme installed.\nWhen Hugo created our theme, it created an empty home page template. Now, when we build the site, Hugo finds the template and uses it to generate the HTML for the home page. Since the template file is empty, the HTML file is empty, too. If the template had any rules in it, then Hugo would have used them to generate the home page.\n$ find . -name index.html | xargs ls -l\r-rw-r--r-- 1 quoha staff 0 Sep 29 20:21 ./public/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 ./themes/zafta/layouts/index.html\r$ The Magic of Static Hugo does two things when generating the site. It uses templates to transform content into HTML and it copies static files into the site. Unlike content, static files are not transformed. They are copied exactly as they are.\nHugo assumes that your site will use both CSS and JavaScript, so it creates directories in your theme to hold them. Remember opinions? Well, Hugo’s opinion is that you’ll store your CSS in a directory named css/ and your JavaScript in a directory named js/. If you don’t like that, you can change the directory names in your theme directory or even delete them completely. Hugo’s nice enough to offer its opinion, then behave nicely if you disagree.\n$ find themes/zafta -type d | xargs ls -ld\rdrwxr-xr-x 7 quoha staff 238 Sep 29 17:38 themes/zafta\rdrwxr-xr-x 3 quoha staff 102 Sep 29 17:31 themes/zafta/archetypes\rdrwxr-xr-x 5 quoha staff 170 Sep 29 17:31 themes/zafta/layouts\rdrwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/layouts/_default\rdrwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/layouts/partials\rdrwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/static\rdrwxr-xr-x 2 quoha staff 68 Sep 29 17:31 themes/zafta/static/css\rdrwxr-xr-x 2 quoha staff 68 Sep 29 17:31 themes/zafta/static/js\r$ The Theme Development Cycle When you’re working on a theme, you will make changes in the theme’s directory, rebuild the site, and check your changes in the browser. Hugo makes this very easy:\n Purge the public/ directory. Run the built in web server in watch mode. Open your site in a browser. Update the theme. Glance at your browser window to see changes. Return to step 4.  I’ll throw in one more opinion: never work on a theme on a live site. Always work on a copy of your site. Make changes to your theme, test them, then copy them up to your site. For added safety, use a tool like Git to keep a revision history of your content and your theme. Believe me when I say that it is too easy to lose both your mind and your changes.\nCheck the main Hugo site for information on using Git with Hugo.\nPurge the public/ Directory When generating the site, Hugo will create new files and update existing ones in the public/ directory. It will not delete files that are no longer used. For example, files that were created in the wrong directory or with the wrong title will remain. If you leave them, you might get confused by them later. I recommend cleaning out your site prior to generating it.\nNote: If you’re building on an SSD, you should ignore this. Churning on a SSD can be costly.\nHugo’s Watch Option Hugo’s “--watch” option will monitor the content/ and your theme directories for changes and rebuild the site automatically.\nLive Reload Hugo’s built in web server supports live reload. As pages are saved on the server, the browser is told to refresh the page. Usually, this happens faster than you can say, “Wow, that’s totally amazing.”\nDevelopment Commands Use the following commands as the basis for your workflow.\n## purge old files. hugo will recreate the public directory.\r##\r$ rm -rf public\r##\r## run hugo in watch mode\r##\r$ hugo server --watch --verbose\rHere’s sample output showing Hugo detecting a change to the template for the home page. Once generated, the web browser automatically reloaded the page. I’ve said this before, it’s amazing.\n$ rm -rf public\r$ hugo server --watch --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content 0 future content 0 pages created 0 tags created\r0 categories created\rin 2 ms\rWatching for changes in /Users/quoha/Sites/zafta/content\rServing pages from /Users/quoha/Sites/zafta/public\rWeb Server is available at http://localhost:1313\rPress Ctrl+C to stop\rINFO: 2014/09/29 File System Event: [\u0026quot;/Users/quoha/Sites/zafta/themes/zafta/layouts/index.html\u0026quot;: MODIFY|ATTRIB]\rChange detected, rebuilding site\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content 0 future content 0 pages created 0 tags created\r0 categories created\rin 1 ms\rUpdate the Home Page Template The home page is one of a few special pages that Hugo creates automatically. As mentioned earlier, it looks for one of three files in the theme’s layout/ directory:\n index.html _default/list.html _default/single.html  We could update one of the default templates, but a good design decision is to update the most specific template available. That’s not a hard and fast rule (in fact, we’ll break it a few times in this tutorial), but it is a good generalization.\nMake a Static Home Page Right now, that page is empty because we don’t have any content and we don’t have any logic in the template. Let’s change that by adding some text to the template.\n$ vi themes/zafta/layouts/index.html\r\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq\r$\rBuild the web site and then verify the results.\n$ hugo --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content 0 future content 0 pages created 0 tags created\r0 categories created\rin 2 ms\r$ find public -type f -name '*.html' | xargs ls -l\r-rw-r--r-- 1 quoha staff 78 Sep 29 21:26 public/index.html\r$ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt; \u0026lt;/html\u0026gt;\rLive Reload Note: If you’re running the server with the --watch option, you’ll see different content in the file:\n$ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt;document.write('\u0026lt;script src=\u0026quot;http://' + (location.host || 'localhost').split(':')[0] + ':1313/livereload.js?mindelay=10\u0026quot;\u0026gt;\u0026lt;/' + 'script\u0026gt;')\u0026lt;/script\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;\rWhen you use --watch, the Live Reload script is added by Hugo. Look for live reload in the documentation to see what it does and how to disable it.\nBuild a “Dynamic” Home Page “Dynamic home page?” Hugo’s a static web site generator, so this seems an odd thing to say. I mean let’s have the home page automatically reflect the content in the site every time Hugo builds it. We’ll use iteration in the template to do that.\nCreate New Posts Now that we have the home page generating static content, let’s add some content to the site. We’ll display these posts as a list on the home page and on their own page, too.\nHugo has a command to generate a skeleton post, just like it does for sites and themes.\n$ hugo --verbose new post/first.md\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 attempting to create post/first.md of post\rINFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/default.md\rERROR: 2014/09/29 Unable to Cast \u0026lt;nil\u0026gt; to map[string]interface{}\r$ That wasn’t very nice, was it?\nThe “new” command uses an archetype to create the post file. Hugo created an empty default archetype file, but that causes an error when there’s a theme. For me, the workaround was to create an archetypes file specifically for the post type.\n$ vi themes/zafta/archetypes/post.md\r+++\rDescription = \u0026quot;\u0026quot;\rTags = []\rCategories = []\r+++\r:wq\r$ find themes/zafta/archetypes -type f | xargs ls -l\r-rw-r--r-- 1 quoha staff 0 Sep 29 21:53 themes/zafta/archetypes/default.md\r-rw-r--r-- 1 quoha staff 51 Sep 29 21:54 themes/zafta/archetypes/post.md\r$ hugo --verbose new post/first.md\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 attempting to create post/first.md of post\rINFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md\rINFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/first.md\r/Users/quoha/Sites/zafta/content/post/first.md created\r$ hugo --verbose new post/second.md\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 attempting to create post/second.md of post\rINFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md\rINFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/second.md\r/Users/quoha/Sites/zafta/content/post/second.md created\r$ ls -l content/post\rtotal 16\r-rw-r--r-- 1 quoha staff 104 Sep 29 21:54 first.md\r-rw-r--r-- 1 quoha staff 105 Sep 29 21:57 second.md\r$ cat content/post/first.md +++\rCategories = []\rDescription = \u0026quot;\u0026quot;\rTags = []\rdate = \u0026quot;2014-09-29T21:54:53-05:00\u0026quot;\rtitle = \u0026quot;first\u0026quot;\r+++\rmy first post\r$ cat content/post/second.md +++\rCategories = []\rDescription = \u0026quot;\u0026quot;\rTags = []\rdate = \u0026quot;2014-09-29T21:57:09-05:00\u0026quot;\rtitle = \u0026quot;second\u0026quot;\r+++\rmy second post\r$ Build the web site and then verify the results.\n$ rm -rf public\r$ hugo --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 found taxonomies: map[string]string{\u0026quot;category\u0026quot;:\u0026quot;categories\u0026quot;, \u0026quot;tag\u0026quot;:\u0026quot;tags\u0026quot;}\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content 0 future content 2 pages created 0 tags created\r0 categories created\rin 4 ms\r$\rThe output says that it created 2 pages. Those are our new posts:\n$ find public -type f -name '*.html' | xargs ls -l\r-rw-r--r-- 1 quoha staff 78 Sep 29 22:13 public/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/first/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/second/index.html\r$\rThe new files are empty because because the templates used to generate the content are empty. The homepage doesn’t show the new content, either. We have to update the templates to add the posts.\nList and Single Templates In Hugo, we have three major kinds of templates. There’s the home page template that we updated previously. It is used only by the home page. We also have “single” templates which are used to generate output for a single content file. We also have “list” templates that are used to group multiple pieces of content before generating output.\nGenerally speaking, list templates are named “list.html” and single templates are named “single.html.”\nThere are three other types of templates: partials, content views, and terms. We will not go into much detail on these.\nAdd Content to the Homepage The home page will contain a list of posts. Let’s update its template to add the posts that we just created. The logic in the template will run every time we build the site.\n$ vi themes/zafta/layouts/index.html \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r{{ range first 10 .Data.Pages }}\r\u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt;\r{{ end }}\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r:wq\r$\rHugo uses the Go template engine. That engine scans the template files for commands which are enclosed between “{{” and “}}”. In our template, the commands are:\n range .Title end  The “range” command is an iterator. We’re going to use it to go through the first ten pages. Every HTML file that Hugo creates is treated as a page, so looping through the list of pages will look at every file that will be created.\nThe “.Title” command prints the value of the “title” variable. Hugo pulls it from the front matter in the Markdown file.\nThe “end” command signals the end of the range iterator. The engine loops back to the top of the iteration when it finds “end.” Everything between the “range” and “end” is evaluated every time the engine goes through the iteration. In this file, that would cause the title from the first ten pages to be output as heading level one.\nIt’s helpful to remember that some variables, like .Data, are created before any output files. Hugo loads every content file into the variable and then gives the template a chance to process before creating the HTML files.\nBuild the web site and then verify the results.\n$ rm -rf public\r$ hugo --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 found taxonomies: map[string]string{\u0026quot;tag\u0026quot;:\u0026quot;tags\u0026quot;, \u0026quot;category\u0026quot;:\u0026quot;categories\u0026quot;}\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content 0 future content 2 pages created 0 tags created\r0 categories created\rin 4 ms\r$ find public -type f -name '*.html' | xargs ls -l -rw-r--r-- 1 quoha staff 94 Sep 29 22:23 public/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/first/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/second/index.html\r$ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;second\u0026lt;/h1\u0026gt;\r\u0026lt;h1\u0026gt;first\u0026lt;/h1\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r$\rCongratulations, the home page shows the title of the two posts. The posts themselves are still empty, but let’s take a moment to appreciate what we’ve done. Your template now generates output dynamically. Believe it or not, by inserting the range command inside of those curly braces, you’ve learned everything you need to know to build a theme. All that’s really left is understanding which template will be used to generate each content file and becoming familiar with the commands for the template engine.\nAnd, if that were entirely true, this tutorial would be much shorter. There are a few things to know that will make creating a new template much easier. Don’t worry, though, that’s all to come.\nAdd Content to the Posts We’re working with posts, which are in the content/post/ directory. That means that their section is “post” (and if we don’t do something weird, their type is also “post”).\nHugo uses the section and type to find the template file for every piece of content. Hugo will first look for a template file that matches the section or type name. If it can’t find one, then it will look in the _default/ directory. There are some twists that we’ll cover when we get to categories and tags, but for now we can assume that Hugo will try post/single.html, then _default/single.html.\nNow that we know the search rule, let’s see what we actually have available:\n$ find themes/zafta -name single.html | xargs ls -l\r-rw-r--r-- 1 quoha staff 132 Sep 29 17:31 themes/zafta/layouts/_default/single.html\rWe could create a new template, post/single.html, or change the default. Since we don’t know of any other content types, let’s start with updating the default.\nRemember, any content that we haven’t created a template for will end up using this template. That can be good or bad. Bad because I know that we’re going to be adding different types of content and we’re going to end up undoing some of the changes we’ve made. It’s good because we’ll be able to see immediate results. It’s also good to start here because we can start to build the basic layout for the site. As we add more content types, we’ll refactor this file and move logic around. Hugo makes that fairly painless, so we’ll accept the cost and proceed.\nPlease see the Hugo documentation on template rendering for all the details on determining which template to use. And, as the docs mention, if you’re building a single page application (SPA) web site, you can delete all of the other templates and work with just the default single page. That’s a refreshing amount of joy right there.\nUpdate the Template File $ vi themes/zafta/layouts/_default/single.html \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt;\r{{ .Content }}\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r:wq\r$\rBuild the web site and verify the results.\n$ rm -rf public\r$ hugo --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 found taxonomies: map[string]string{\u0026quot;tag\u0026quot;:\u0026quot;tags\u0026quot;, \u0026quot;category\u0026quot;:\u0026quot;categories\u0026quot;}\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content 0 future content 2 pages created 0 tags created\r0 categories created\rin 4 ms\r$ find public -type f -name '*.html' | xargs ls -l\r-rw-r--r-- 1 quoha staff 94 Sep 29 22:40 public/index.html\r-rw-r--r-- 1 quoha staff 125 Sep 29 22:40 public/post/first/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:40 public/post/index.html\r-rw-r--r-- 1 quoha staff 128 Sep 29 22:40 public/post/second/index.html\r$ cat public/post/first/index.html \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;title\u0026gt;first\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;first\u0026lt;/h1\u0026gt;\r\u0026lt;p\u0026gt;my first post\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r$ cat public/post/second/index.html \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;title\u0026gt;second\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;second\u0026lt;/h1\u0026gt;\r\u0026lt;p\u0026gt;my second post\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r$\rNotice that the posts now have content. You can go to localhost:1313/post/first to verify.\nLinking to Content The posts are on the home page. Let’s add a link from there to the post. Since this is the home page, we’ll update its template.\n$ vi themes/zafta/layouts/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r{{ range first 10 .Data.Pages }}\r\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\r{{ end }}\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rBuild the web site and verify the results.\n$ rm -rf public\r$ hugo --verbose\rINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\rINFO: 2014/09/29 found taxonomies: map[string]string{\u0026quot;tag\u0026quot;:\u0026quot;tags\u0026quot;, \u0026quot;category\u0026quot;:\u0026quot;categories\u0026quot;}\rWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\r0 draft content 0 future content 2 pages created 0 tags created\r0 categories created\rin 4 ms\r$ find public -type f -name '*.html' | xargs ls -l\r-rw-r--r-- 1 quoha staff 149 Sep 29 22:44 public/index.html\r-rw-r--r-- 1 quoha staff 125 Sep 29 22:44 public/post/first/index.html\r-rw-r--r-- 1 quoha staff 0 Sep 29 22:44 public/post/index.html\r-rw-r--r-- 1 quoha staff 128 Sep 29 22:44 public/post/second/index.html\r$ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;/post/second/\u0026quot;\u0026gt;second\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\r\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;/post/first/\u0026quot;\u0026gt;first\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r$\rCreate a Post Listing We have the posts displaying on the home page and on their own page. We also have a file public/post/index.html that is empty. Let’s make it show a list of all posts (not just the first ten).\nWe need to decide which template to update. This will be a listing, so it should be a list template. Let’s take a quick look and see which list templates are available.\n$ find themes/zafta -name list.html | xargs ls -l\r-rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html\rAs with the single post, we have to decide to update _default/list.html or create post/list.html. We still don’t have multiple content types, so let’s stay consistent and update the default list template.\nCreating Top Level Pages Let’s add an “about” page and display it at the top level (as opposed to a sub-level like we did with posts).\nThe default in Hugo is to use the directory structure of the content/ directory to guide the location of the generated html in the public/ directory. Let’s verify that by creating an “about” page at the top level:\n$ vi content/about.md +++\rtitle = \u0026quot;about\u0026quot;\rdescription = \u0026quot;about this site\u0026quot;\rdate = \u0026quot;2014-09-27\u0026quot;\rslug = \u0026quot;about time\u0026quot;\r+++\r## about us\ri'm speechless\r:wq\rGenerate the web site and verify the results.\n$ find public -name '*.html' | xargs ls -l\r-rw-rw-r-- 1 mdhender staff 334 Sep 27 15:08 public/about-time/index.html\r-rw-rw-r-- 1 mdhender staff 527 Sep 27 15:08 public/index.html\r-rw-rw-r-- 1 mdhender staff 358 Sep 27 15:08 public/post/first-post/index.html\r-rw-rw-r-- 1 mdhender staff 0 Sep 27 15:08 public/post/index.html\r-rw-rw-r-- 1 mdhender staff 342 Sep 27 15:08 public/post/second-post/index.html\rNotice that the page wasn’t created at the top level. It was created in a sub-directory named ‘about-time/’. That name came from our slug. Hugo will use the slug to name the generated content. It’s a reasonable default, by the way, but we can learn a few things by fighting it for this file.\nOne other thing. Take a look at the home page.\n$ cat public/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;http://localhost:1313/post/theme/\u0026quot;\u0026gt;creating a new theme\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\r\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;http://localhost:1313/about-time/\u0026quot;\u0026gt;about\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\r\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;http://localhost:1313/post/second-post/\u0026quot;\u0026gt;second\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\r\u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;http://localhost:1313/post/first-post/\u0026quot;\u0026gt;first\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\r\u0026lt;script\u0026gt;document.write('\u0026lt;script src=\u0026quot;http://'\r+ (location.host || 'localhost').split(':')[0]\r+ ':1313/livereload.js?mindelay=10\u0026quot;\u0026gt;\u0026lt;/'\r+ 'script\u0026gt;')\u0026lt;/script\u0026gt;\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rNotice that the “about” link is listed with the posts? That’s not desirable, so let’s change that first.\n$ vi themes/zafta/layouts/index.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;posts\u0026lt;/h1\u0026gt;\r{{ range first 10 .Data.Pages }}\r{{ if eq .Type \u0026quot;post\u0026quot;}}\r\u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt;\r{{ end }}\r{{ end }}\r\u0026lt;h1\u0026gt;pages\u0026lt;/h1\u0026gt;\r{{ range .Data.Pages }}\r{{ if eq .Type \u0026quot;page\u0026quot; }}\r\u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt;\r{{ end }}\r{{ end }}\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r:wq\rGenerate the web site and verify the results. The home page has two sections, posts and pages, and each section has the right set of headings and links in it.\nBut, that about page still renders to about-time/index.html.\n$ find public -name '*.html' | xargs ls -l\r-rw-rw-r-- 1 mdhender staff 334 Sep 27 15:33 public/about-time/index.html\r-rw-rw-r-- 1 mdhender staff 645 Sep 27 15:33 public/index.html\r-rw-rw-r-- 1 mdhender staff 358 Sep 27 15:33 public/post/first-post/index.html\r-rw-rw-r-- 1 mdhender staff 0 Sep 27 15:33 public/post/index.html\r-rw-rw-r-- 1 mdhender staff 342 Sep 27 15:33 public/post/second-post/index.html\rKnowing that hugo is using the slug to generate the file name, the simplest solution is to change the slug. Let’s do it the hard way and change the permalink in the configuration file.\n$ vi config.toml\r[permalinks]\rpage = \u0026quot;/:title/\u0026quot;\rabout = \u0026quot;/:filename/\u0026quot;\rGenerate the web site and verify that this didn’t work. Hugo lets “slug” or “URL” override the permalinks setting in the configuration file. Go ahead and comment out the slug in content/about.md, then generate the web site to get it to be created in the right place.\nSharing Templates If you’ve been following along, you probably noticed that posts have titles in the browser and the home page doesn’t. That’s because we didn’t put the title in the home page’s template (layouts/index.html). That’s an easy thing to do, but let’s look at a different option.\nWe can put the common bits into a shared template that’s stored in the themes/zafta/layouts/partials/ directory.\nCreate the Header and Footer Partials In Hugo, a partial is a sugar-coated template. Normally a template reference has a path specified. Partials are different. Hugo searches for them along a TODO defined search path. This makes it easier for end-users to override the theme’s presentation.\n$ vi themes/zafta/layouts/partials/header.html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r:wq\r$ vi themes/zafta/layouts/partials/footer.html\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r:wq\rUpdate the Home Page Template to Use the Partials The most noticeable difference between a template call and a partials call is the lack of path:\n{{ template \u0026quot;theme/partials/header.html\u0026quot; . }}\rversus\n{{ partial \u0026quot;header.html\u0026quot; . }}\rBoth pass in the context.\nLet’s change the home page template to use these new partials.\n$ vi themes/zafta/layouts/index.html\r{{ partial \u0026quot;header.html\u0026quot; . }}\r\u0026lt;h1\u0026gt;posts\u0026lt;/h1\u0026gt;\r{{ range first 10 .Data.Pages }}\r{{ if eq .Type \u0026quot;post\u0026quot;}}\r\u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt;\r{{ end }}\r{{ end }}\r\u0026lt;h1\u0026gt;pages\u0026lt;/h1\u0026gt;\r{{ range .Data.Pages }}\r{{ if or (eq .Type \u0026quot;page\u0026quot;) (eq .Type \u0026quot;about\u0026quot;) }}\r\u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Type }} - {{ .Title }} - {{ .RelPermalink }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt;\r{{ end }}\r{{ end }}\r{{ partial \u0026quot;footer.html\u0026quot; . }}\r:wq\rGenerate the web site and verify the results. The title on the home page is now “your title here”, which comes from the “title” variable in the config.toml file.\nUpdate the Default Single Template to Use the Partials $ vi themes/zafta/layouts/_default/single.html\r{{ partial \u0026quot;header.html\u0026quot; . }}\r\u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt;\r{{ .Content }}\r{{ partial \u0026quot;footer.html\u0026quot; . }}\r:wq\rGenerate the web site and verify the results. The title on the posts and the about page should both reflect the value in the markdown file.\nAdd “Date Published” to Posts It’s common to have posts display the date that they were written or published, so let’s add that. The front matter of our posts has a variable named “date.” It’s usually the date the content was created, but let’s pretend that’s the value we want to display.\nAdd “Date Published” to the Template We’ll start by updating the template used to render the posts. The template code will look like:\n{{ .Date.Format \u0026quot;Mon, Jan 2, 2006\u0026quot; }}\rPosts use the default single template, so we’ll change that file.\n$ vi themes/zafta/layouts/_default/single.html\r{{ partial \u0026quot;header.html\u0026quot; . }}\r\u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt;\r\u0026lt;h2\u0026gt;{{ .Date.Format \u0026quot;Mon, Jan 2, 2006\u0026quot; }}\u0026lt;/h2\u0026gt;\r{{ .Content }}\r{{ partial \u0026quot;footer.html\u0026quot; . }}\r:wq\rGenerate the web site and verify the results. The posts now have the date displayed in them. There’s a problem, though. The “about” page also has the date displayed.\nAs usual, there are a couple of ways to make the date display only on posts. We could do an “if” statement like we did on the home page. Another way would be to create a separate template for posts.\nThe “if” solution works for sites that have just a couple of content types. It aligns with the principle of “code for today,” too.\nLet’s assume, though, that we’ve made our site so complex that we feel we have to create a new template type. In Hugo-speak, we’re going to create a section template.\nLet’s restore the default single template before we forget.\n$ mkdir themes/zafta/layouts/post\r$ vi themes/zafta/layouts/_default/single.html\r{{ partial \u0026quot;header.html\u0026quot; . }}\r\u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt;\r{{ .Content }}\r{{ partial \u0026quot;footer.html\u0026quot; . }}\r:wq\rNow we’ll update the post’s version of the single template. If you remember Hugo’s rules, the template engine will use this version over the default.\n$ vi themes/zafta/layouts/post/single.html\r{{ partial \u0026quot;header.html\u0026quot; . }}\r\u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt;\r\u0026lt;h2\u0026gt;{{ .Date.Format \u0026quot;Mon, Jan 2, 2006\u0026quot; }}\u0026lt;/h2\u0026gt;\r{{ .Content }}\r{{ partial \u0026quot;footer.html\u0026quot; . }}\r:wq\rNote that we removed the date logic from the default template and put it in the post template. Generate the web site and verify the results. Posts have dates and the about page doesn’t.\nDon’t Repeat Yourself DRY is a good design goal and Hugo does a great job supporting it. Part of the art of a good template is knowing when to add a new template and when to update an existing one. While you’re figuring that out, accept that you’ll be doing some refactoring. Hugo makes that easy and fast, so it’s okay to delay splitting up a template.\n","id":5,"section":"posts","summary":"\u003cp\u003eThis tutorial will show you how to create a simple theme in Hugo\u003c/p\u003e","tags":["tutorial","搬运","官方文档"],"title":"hugo创建主题","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/11/hugo%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/","year":"2019"},{"content":"Django后台跨域解决 首先安装corsheaders\npip install django-cors-headers\r配置跨域\n# ---settings.py---\r# 注册应用\rINSTALLED_APPS = {\r...\r\u0026#39;corsheaders\u0026#39;,\r...\r}\r# 中间层\rMIDDLEWARE = {\r...\r\u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, # 注意顺序\r\u0026#39;corsheaders.middleware.CorsMiddleware\u0026#39;,\r...\r}\r# 添加白名单\rCORS_ORIGIN_ALLOW_ALL = True\r 在MIDDLEWARE中添加corsheaders.middleware.CorsMiddleware，该middleware需要放在CommonMiddleware、WhiteNoiseMiddleware等能产生响应的middleware之前。如果另外使用了CORS_REPLACE_HTTPS_REFERER 则需要把它放django的CsrfViewMiddleware 之前\n  使用Ajax获取json数据时，存在跨域的限制。不过，在Web页面上调用js的script脚本文件时却不受跨域的影响，JSONP就是利用这个来实现跨域的传输。因此，我们需要将Ajax调用中的dataType从JSON改为JSONP（相应的API也需要支持JSONP）格式。 不过json-p只能解决get请求\n ","id":6,"section":"posts","summary":"Django后台跨域解决 首先安装corsheaders pip install django-cors-headers 配置跨域 # ---settings.py--- # 注册应用 INSTALLED_APPS = { ... \u0026#39;corsheaders\u0026#39;, ... } # 中间层 MIDDLEWARE = { ... \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, # 注意顺序 \u0026#39;corsheaders.middleware.CorsMiddleware\u0026#39;, ... } # 添加白名","tags":["django","cors"],"title":"Django后台跨域解决","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/10/django%E5%90%8E%E5%8F%B0%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/","year":"2019"},{"content":"第三方登陆之微博 获取第三方登陆平台开发应用的APP KEY 和 APP SECRET 码\nApp Key：2353060136\rApp Secret：624a8065fbc33c6f004ec7923278ae36\r设置回调地址，我这里设置的是 http://127.0.0.1:8000/callback/weibo/  ，上线后要写服务器地址\n将常量写到 settings.py 以方便调用\nWEIBO_APP_KEY = \u0026#39;2353060136\u0026#39;\rWEIBO_APP_SECRET = \u0026#39;624a8065fbc33c6f004ec7923278ae36\u0026#39;\rWEIBO_CALLBACK = \u0026#39;http://127.0.0.1:8000/callback/weibo/\u0026#39;\rstep1 请求授权\n用户点击微博登陆后调用此接口跳转微博登陆，用户授权登陆后，微博服务器通过我们提供的回调地址返回一个授权码\n授权地址： https://api.weibo.com/oauth2/authorize\nHTTP请求方式 : GET/POST\n发起请求必要的参数：\n​\t client_id : 申请应用时分配的AppKey\n​\tredirect_uri : 授权回调地址，站外应用需与设置的回调地址一致\n​\t详至 Oauth2/authorize\ndef weibo_login(request):\rreturn HttpResponseRedirect(f\u0026#39;https://api.weibo.com/oauth2/authorize?client_id={settings.WEIBO_APP_KEY}\u0026amp;redirect_uri={WEIBO_CALLBACK}\u0026#39;)\rstep2 获取token\n在上一步中获得了授权码后，进一步通过授权码向微博服务器获取token\n获取地址：https://api.weibo.com/oauth2/access_token \nHTTP请求方式 : POST\n发起请求必要的参数：\n​\tclient_id：申请应用时分配的AppKey\n​\tclient_secret : 申请应用时分配的AppSecret\n​\tgrant_type : authorization_code\n​\tcode : 调用authorize获得的code值\n​\tredirect_uri : 回调地址，需需与注册应用里的回调地址一致\n​\t详至 oauth2/access_token\ncode = request.GET.get(\u0026#39;code\u0026#39;, None)\rdef get_access_token(code):\rres = requests.post(\u0026#39;https://api.weibo.com/oauth2/access_token\u0026#39;, data={\r\u0026#39;client_id\u0026#39;: settings.WEIBO_APP_KEY,\r\u0026#39;client_secret\u0026#39;: settings.WEIBO_APP_SECRET,\r\u0026#39;grant_type\u0026#39;: \u0026#39;authorization_code\u0026#39;,\r\u0026#39;code\u0026#39;: code,\r\u0026#39;redirect_uri\u0026#39;: settings.WEIBO_CALLBACK\r})\rreturn json.loads(res.text)\rstep3 获取用户信息\n通过上一步中获取的token，再次访问微博服务器以获取用户基本信息\n获取地址：https://api.weibo.com/2/users/show.json\nHTTP请求方式 : GET\n发起请求必要的参数：\n​\taccess_token : 用户授权时生成的access_token\n​\tuid : 需要查询的用户ID ，access_token内获得\n返回字段说明:\ndef get_user_info(access_token):\rurl = f\u0026#39;https://api.weibo.com/2/users/show.json?access_token={access_token[\u0026#39;access_token\u0026#39;]}\u0026amp;uid={access_token[\u0026#39;uid\u0026#39;]}\u0026#39;\rres = requests.get(url)\rreturn json.loads(res.text)\r 接下来就可以判断用户是否第一次使用此三方登陆，继而进行入库操作或直接予以登陆跳转。\n","id":7,"section":"posts","summary":"第三方登陆之微博 获取第三方登陆平台开发应用的APP KEY 和 APP SECRET 码 App Key：2353060136 App Secret：624a8065fbc33c6f0","tags":["三方登陆","weibo"],"title":" 第三方登陆之微博","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/10/%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E9%99%86%E4%B9%8B%E5%BE%AE%E5%8D%9A/","year":"2019"},{"content":"linux下，修改 ~/.pip/pip.conf (没有就创建一个)， 修改 index-url至tuna，内容如下： [global]\rindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\r windows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini，内容如下  Tips 文件要用nodepad++这种可以直接写utf-8编码的编辑器打开，自带的文本文档默认gbk格式下编辑会乱码的\n [global]\rindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\r","id":8,"section":"posts","summary":"linux下，修改 ~/.pip/pip.conf (没有就创建一个)， 修改 index-url至tuna，内容如下： [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple windows下，直接在user目录中创建一个p","tags":["python","pip"],"title":"pip更换镜像源","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/10/pip%E6%9B%B4%E6%8D%A2%E6%B8%85%E5%8D%8E%E9%95%9C%E5%83%8F%E6%BA%90/","year":"2019"},{"content":"Django-redis 安装\npip install django-redis\r在settings.py 下配置\nCACHES = {\r\u0026#34;default\u0026#34;: {\r\u0026#34;BACKEND\u0026#34;: \u0026#34;django_redis.cache.RedisCache\u0026#34;,\r\u0026#34;LOCATION\u0026#34;: \u0026#34;redis://127.0.0.1:6379\u0026#34;,\r\u0026#34;OPTIONS\u0026#34;: {\r\u0026#34;CLIENT_CLASS\u0026#34;: \u0026#34;django_redis.client.DefaultClient\u0026#34;,\r\u0026#34;CONNECTION_POOL_KWARGS\u0026#34;: {\u0026#34;max_connections\u0026#34;: 100}\r# \u0026#34;PASSWORD\u0026#34;: \u0026#34;密码\u0026#34;,\r }\r}\r}\rdemo\n---views.py---\rfrom django.core.cache import cache\rdef get(request):\rcache.set(\u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;, timeout)\rdef post(request):\rtmp = cache.get(\u0026#39;key\u0026#39;)\r...\r","id":9,"section":"posts","summary":"","tags":["django","redis"],"title":"Django-redis配置","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/09/django-redis/","year":"2019"},{"content":"NoSQL 是什么 NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，用于超大规模数据的存储。\nWhy NoSQL 用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL 数据库的发展却能很好的处理这些大的数据。\nMongo 是什么 MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。\n在高负载的情况下，添加更多的节点，可以保证服务器性能。\nMongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。\nMongoDB 将数据存储为一个文档，数据结构由键值(key=\u0026gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。\nMongo 特点  MongoDB 是一个面向文档存储的数据库，操作起来比较简单和容易。 Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。 GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。 海量数据下，性能优越 如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。  ","id":10,"section":"posts","summary":"NoSQL 是什么 NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，用于超大规模数据的存储。 Why NoSQL 用户的个人信息，社交网络，","tags":["mongo"],"title":"MongoDB简介","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/09/mongo%E7%AE%80%E4%BB%8B/","year":"2019"},{"content":"# 更新conda\r conda update conda\r# 获取帮助\r conda --help\r# 创建虚拟环境\r conda create --name env_name [python=version]\r# 查看当前所有虚拟环境\r conda env list\r# 进入虚拟环境\r activate env_name\r# 退出虚拟环境\r deactivate\r# 删除环境\r conda remove --name env_name --all\r# 列举当前环境下的包\r conda list\r# 列举非当前环境下的包\r conda list --name env_name\r# 安装包到指定环境\r conda install --name env_name package_name\r 如果你想把你当前的环境配置与别人分享，这样他可以快速建立一个与你一模一样的环境（同一个版本的python及各种包）来共同开发/进行新的实验。一个分享环境的快速方法就是给他一个你的环境的 .yml 文件。\n首先通过 activate target_env 要分享的环境 target_env，然后输入下面的命令会在当前工作目录下生成一个 environment.yml文件\nconda env export \u0026gt; environment.yml\r小伙伴拿到 environment.yml文件后，将该文件放在工作目录下，可以通过以下命令从该文件创建环境\nconda env create -f environment.yml\r","id":11,"section":"posts","summary":"# 更新conda conda update conda # 获取帮助 conda --help # 创建虚拟环境 conda create --name env_name [python=version] # 查看当前所有虚拟环境 conda env list # 进入虚拟环境 activate env_name # 退出虚拟环境 deactivate # 删除环境 conda remove --name env_name","tags":["conda","python"],"title":"conda基本命令","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/09/conda%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/","year":"2019"},{"content":"1. 安装 MongoDB 社区版 Service Configuration 步骤中，使用默认的 Run service as Network Service user 即可。下方可以选择数据库和日志存储的地址，通用使用默认即可。\nInstall MongoDB Compass 步骤中，取消左下角勾选。MongoDB Compass 是Mongo自己的图形可视化工具，这里安装会默认到官网下载后安装，速度很慢。\n等待安装完成…\n配置环境变量 将 X:\\..\\MongoDB\\Server\\4.2\\bin 添加到path内\n2. 安装MongoDB Compass 3. 配置\u0026amp;启动服务  安装 Mongo 时已经配置过数据库和日志存储的地址，如果没有额外移动地址的需求，可以忽略配置这个步骤。\n ​\t在目标位置创建如下结构的文件夹及文件\n-data\r-db\r-logs\r-mongodb.log\r​\t编写配置文件\n---X:\\..\\MongoDB\\mongo.config---\r# 数据库路径\rdbpath=X:\\..\\data\\db\r# 日志输出文件路径\rlogpath=X:\\..\\data\\logs\\mongodb.log\r# 错误日志采用追加模式\rlogappend=true\r# 启用日志文件(默认启用)\rjournal=true\r# 过滤无用日志信息(若需要调试请关闭)\rquiet=true\r# 端口号\rport=27017\r​\t配置本地 mongoDB 服务 ​\t管理员启动命令行 / 跳转至 ..\\MongoDB\\bin 目录 ​\t输入一下命令来根据上面的配置文件安装mongo服务\n\u0026gt; mongod --config \u0026#34;X:\\..\\MongoDB\\mongo.config\u0026#34; --install --serviceName \u0026#34;MongoDB\u0026#34;\r​\t在 服务 中查看，出现 MongoDB 服务就证明成功了，通过命令行 net start MongoDB 就可以启动数据库了。一般设置了开机自启动后不再需要自己手动启动服务了。\n","id":12,"section":"posts","summary":"1. 安装 MongoDB 社区版 Service Configuration 步骤中，使用默认的 Run service as Network Service user 即可。下方可以选择数据库和日志存储的地址，通用使用默认即可。 Install MongoDB Compass 步骤中，取消左下角勾选。M","tags":["mongo","安装"],"title":"安装MongoDB","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/09/%E5%AE%89%E8%A3%85-mongodb/","year":"2019"},{"content":"Node.js 安装   安装到指定位置\n  改变原有环境变量\n 首先配置npm的全局模块的存放路径、cache的路径  npm config set prefix \u0026#34;F:\\nodejs\\node_global\u0026#34;\rnpm config set cache \u0026#34;F:\\nodejs\\node_cache\u0026#34;\r 在命令行输入命令来安装express\nnpm install express -g\r  安装cnpm\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\r  输入 cnpm -v 来检测是否安装成功\n    ","id":13,"section":"posts","summary":"Node.js 安装 安装到指定位置 改变原有环境变量 首先配置npm的全局模块的存放路径、cache的路径 npm config set prefix \u0026#34;F:\\nodejs\\node_global\u0026#34; npm config set cache \u0026#34;F:\\nodejs\\node_cache\u0026#34; 在命令行输入命令来安装expre","tags":["node.js"],"title":" Node.js 安装","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/09/node.js-%E5%AE%89%E8%A3%85/","year":"2019"},{"content":"一、安装思路  安装erlang 安装socat 安装rabbitmq 相关配置  二、具体步骤 1.安装erlang 下载:wget http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpm 安装: rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm\n2.安装socat 下载：wget http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpm 安装：rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm\n3.安装rabbitmq 下载：wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-3.6.5-1.noarch.rpm 安装：rpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm\n三个都安装成功后，如下图所示 三、启动rabbitmq服务 安装完成后, 还没启动服务, 先查看rabbitmq服务状态, 命令: service rabbitmq-server status, 提示：Error: unable to connect to node rabbit@wangzaiplus: nodedown OK, 启动rabbitmq服务, 命令: service rabbitmq-server start, 检查是否启动成功: ps -ef | grep rabbitmq\n四、启动后台管理插件 此时, 服务已经启动, 但通过浏览器访问http://localhost:15672或ip:15672还是不能访问管理界面, 因为还没启用插件, 启用命令: rabbitmq-plugins enable rabbitmq_management, 提示Applying plugin configuration to rabbit@wangzaiplus\u0026hellip; started 6 plugins.即表示启用成功\n浏览器远程访问http://服务器IP:15672, 出现登录界面\n注意: 如果服务器开启了防火墙, 则访问不了, 可以先关闭防火墙或者暴露端口 centos7查看防火墙状态: firewall-cmd \u0026ndash;state, 关闭后显示not running，开启后显示running 关闭防火墙: systemctl stop firewalld.service\n五、开启用户远程访问 rabbitmq从3.3.0开始, 默认用户guest只允许本机访问, 即: http://服务器IP:15672, 如果通过ip:port访问, 会发现Login failed, 为了让guest用户能够远程访问, 只需新建配置文件配置loopback_users即可(rabbitmq.config配置文件需手动创建), 步骤如下: cd /etc/rabbitmq 新建配置文件: touch rabbitmq.config vim rabbitmq.config 写入并保存: [{rabbit, [{loopback_users, []}]}]. 重启服务: service rabbitmq-server restart 重新以guest登录, OK，目前为止, rabbitmq服务已安装完毕\n六、常见错误 无法远程访问管理界面, rabbitmq服务安装成功并启动后, 浏览器访问http://192.168.1.123:15672发现访问不了, 有以下几个原因: 没有启用管理插件, 解决办法: rabbitmq-plugins enable rabbitmq_management\n服务器开启了防火墙且未开放5672、15672端口, 解决办法: 关闭防火墙或暴露端口, 关闭防火墙命令: systemctl stop firewalld.service\n很重要: 如果服务器使用的是第三方云服务(如腾讯云服务器), 设置了安全组策略, 入站规则没有开放5672、15672端口, 那么也会出现这个问题, 解决办法: 登录云服务器管控台, 配置安全组策略并关联实例即可, 具体配置自行百度\n","id":14,"section":"posts","summary":"一、安装思路 安装erlang 安装socat 安装rabbitmq 相关配置 二、具体步骤 1.安装erlang 下载:wget http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpm 安装: rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm 2.安装s","tags":["RabbitMQ","linux"],"title":"RabbitMQ安装","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/08/rabbitmq%E5%AE%89%E8%A3%85/","year":"2019"},{"content":"django中使用模板首先要新键一个模板文件夹 templates，然后在配置文件中设置模板文件的路径  'DIRS': [os.path.join(BASE_DIR, 'templates')] 视图函数中，使用render()代替 HttpResponse 渲染html页面，传输数据。其中第一个参数必须为 request ，即视图函数参数\ndef login(request):\rpattern = f\u0026#39;\\w{6,18}\u0026#39;\rd = {\r\u0026#39;msg\u0026#39;: \u0026#39;ok\u0026#39;\r}\rif request.method == \u0026#39;POST\u0026#39;:\rname = request.POST.get(\u0026#39;name\u0026#39;)\rpassword = request.POST.get(\u0026#39;password\u0026#39;)\rif not all([name, password]):\rd[\u0026#39;msg\u0026#39;] = \u0026#39;信息填写不完整\u0026#39;\rreturn render(request, \u0026#39;login.html\u0026#39;, d)\rif not re.match(pattern, password):\rd[\u0026#39;msg\u0026#39;] = \u0026#39;密码必须由6-18位的数字、字母、下划线组成\u0026#39;\rreturn render(request, \u0026#39;login.html\u0026#39;, d)\rreturn render(request, \u0026#39;login.html\u0026#39;)\r","id":15,"section":"posts","summary":"django中使用模板首先要新键一个模板文件夹 templates，然后在配置文件中设置模板文件的路径 'DIRS': [os.path.join(BASE_DIR, 'templates')] 视图函数中，使用render()代","tags":["django"],"title":"Django模板笔记","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/08/django%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/","year":"2019"},{"content":"修改配置文件   避免使用关键子来，创建py文件、文件夹，等等(admin, django,this, that, test)\n  注册子应用\nINSTALLED_APPS = [ \u0026#39;goods\u0026#39; # 子应用名字 ]   注释掉CSRF\nMIDDLEWARE = [ \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, # \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;, \u0026#39;django.contrib.messages.middleware.MessageMiddleware\u0026#39;, \u0026#39;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026#39;, ]   模板文件夹配置\nTEMPLATES = [ { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.template.backends.django.DjangoTemplates\u0026#39;, # 模板文件夹配置 \u0026#39;DIRS\u0026#39;: [os.path.join(BASE_DIR, \u0026#39;templates\u0026#39;)], \u0026#39;APP_DIRS\u0026#39;: True, \u0026#39;OPTIONS\u0026#39;: { \u0026#39;context_processors\u0026#39;: [ \u0026#39;django.template.context_processors.debug\u0026#39;, \u0026#39;django.template.context_processors.request\u0026#39;, \u0026#39;django.contrib.auth.context_processors.auth\u0026#39;, \u0026#39;django.contrib.messages.context_processors.messages\u0026#39;, ], }, }, ]   配置mysql数据库\nDATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.mysql\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, \u0026#39;PORT\u0026#39;: 3306, \u0026#39;USER\u0026#39;: \u0026#39;root\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;12345678\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;fuxi1903\u0026#39; } }   修改时区、语言\nLANGUAGE_CODE = \u0026#39;zh-Hans\u0026#39; TIME_ZONE = \u0026#39;Asia/Shanghai\u0026#39; USE_TZ = False   静态文件夹\nSTATICFILES_DIRS = [os.path.join(BASE_DIR, \u0026#39;static\u0026#39;)]   主应用的__init__.py中添加\nimport pymysql pymysql.install_as_MySQLdb()   重定向 from django.shortcuts import render,HttpResponse, redirect, reverse from django.views import View from django.http import JsonResponse,HttpResponse # Create your views here. class IndexView(View): def get(self, reqeust): name = \u0026#39;ZhangSan\u0026#39; return render(reqeust, \u0026#39;index.html\u0026#39;,context={\u0026#39;name\u0026#39;: name}) class LoginView(View): def get(self, request): # 登录操作，登录成功后，跳转到首页 print(\u0026#39;登录操作\u0026#39;) # 跳转方式：1 # return redirect(\u0026#39;http://127.0.0.1:8000/goods/index/\u0026#39;) # 跳转方式：2 # reverse功能等同于 flask:url_for # return redirect(reverse(\u0026#39;goods:index\u0026#39;)) # 跳转方式：3 带参数的跳转 # return redirect(\u0026#39;/goods/detail/123\u0026#39;) # 跳转方式：4 带参数的跳转 return redirect(reverse(\u0026#39;goods:detail\u0026#39;, kwargs={\u0026#39;id\u0026#39;: 456})) class GoodsDetailView(View): def get(self, request, id): print(\u0026#39;ID 为 %d\u0026#39; % id) return render(request, \u0026#39;detail.html\u0026#39;) 模板中的反向解析 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;登录页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; {# 方式1： 写入url路径 #} \u0026lt;a href=\u0026#34;/goods/detail/1314\u0026#34;\u0026gt;跳转到detail页\u0026lt;/a\u0026gt; {# 方式2： 反向解析（带参数） #} \u0026lt;br\u0026gt; \u0026lt;a href=\u0026#34;{% url \u0026#39;goods:detail\u0026#39; 520 %}\u0026#34;\u0026gt;反向解析跳转（有参数）\u0026lt;/a\u0026gt; \u0026lt;br\u0026gt; {# 方式3： 反向解析 （无参数） #} \u0026lt;a href=\u0026#34;{% url \u0026#39;goods:index\u0026#39; %}\u0026#34;\u0026gt;反向无参数\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Cookie  设置cookie  response.set_cookie(\u0026#34;username\u0026#34;,\u0026#34;jack\u0026#34;,expires=expires) # 设置过期时间为100秒 res.set_cookie(\u0026#39;user_id\u0026#39;, 7788250, expires=100)  获取  #定义变量获取cookies属性 cookies = request.COOKIES #从cookies通过key获取value username = cookies.get(\u0026#34;username\u0026#34;,\u0026#34;未拿到用户名\u0026#34;)  删除  #定义response对象 response = HttpResponse(\u0026#34;删除cookie成功\u0026#34;) #调用delete_cookie()方法来删除cookie response.delete_cookie(\u0026#34;username\u0026#34;) Session  设置  # 设置session request.session[\u0026#34;name\u0026#34;] = \u0026#34;root\u0026#34; # 设置session过期时间为60秒 request.session.set_expiry(10)  获取  # 获取session name = request.sessin[\u0026#34;name\u0026#34;] name = request.session.get(\u0026#34;name\u0026#34;)  删除  request.session.pop(\u0026#39;user_id\u0026#39;) 过滤器  safe，禁用转义，告诉模板这个变量是安全的，可以解释执行 length，长度，返回字符串包含字符的个数，或列表、元组、字典的元素个数。 default，默认值，如果变量不存在时则返回默认值。  模板内置变量   # 循环中使用，序号 \u0026lt;ul\u0026gt; {% for i in list %} \u0026lt;li\u0026gt; {{ forloop.counter }} - {{ i }} \u0026lt;/li\u0026gt; {% endfor %} \u0026lt;/ul\u0026gt;   ","id":16,"section":"posts","summary":"修改配置文件 避免使用关键子来，创建py文件、文件夹，等等(admin, django,this, that, test) 注册子应用 INSTALLED_APPS = [ \u0026#39;goods\u0026#39; # 子应用名字 ] 注释掉CSRF MIDDLEWARE = [ \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, # \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;,","tags":["django"],"title":"Django入门笔记","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/08/django%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":"django中的视图函数写在子项目中的 views.py 文件中，函数包含一个参数，接收页面请求头。HttpResponse 可以返回信息。Django的路由都写在urls.py文件中的urlpatterns列表中,在路由文件中注册当前视图后就能在网页访问了\n# ---views.py---\r from django.http import HttpResponse\rdef index(request):\rres = HttpResponse(\u0026#39;\u0026lt;h1\u0026gt;hello world\u0026lt;/h1\u0026gt;\u0026#39;)\rreturn res\r# ---urls.py---\r from user import views\rurlpatterns = [\r...\rpath(\u0026#39;index/\u0026#39;, views.index)\r]\r","id":17,"section":"posts","summary":"django中的视图函数写在子项目中的 views.py 文件中，函数包含一个参数，接收页面请求头。HttpResponse 可以返回信息。Django的路由都","tags":["django"],"title":"Django的Hello World","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/08/django%E7%9A%84helloworld/","year":"2019"},{"content":"安装   安装Django包\npip install django==2.1.4\r  检测是否安装以及查看Django版本\npython -m django --version\r  生成项目文件\ndjango-admin startproject 项目名\r# 命令执行后会在当前定位位置生成项目目录，且自动生成必要的文件\r----django_site\\\r |----db.sqlite3 # 内置数据库\r|----django_site\\\r | |----settings.py # 配置文件\r| |----urls.py # 路由文件\r| |----wsgi.py\r|----manage.py # 入口函数\r|----templates\\  # 模板\r| |----login.html\r| |----__init__.py\r|----user\\  # 子项目\r| |----admin.py # 管理员模块\r| |----apps.py\r| |----migrations\\  # 迁移\r| | |----__init__.py\r| |----models.py # 数据库模型\r| |----tests.py # 单元测试\r| |----views.py # 视图\r  生成django子项目\npython manage.py startapp 子项目名\r  启动服务\npython manage.py runserver\r   配置  settings.py # 可访问地址 \u0026#39;*\u0026#39; -\u0026gt; 所有ip\r ALLOWED_HOSTS = []\rINSTALLED_APPS = [\r...\r# 在此注册子应用\r \u0026#39;user\u0026#39;,\r]\r# 模板文件夹\r TEMPLATES = [\r{\r\u0026#39;BACKEND\u0026#39;: \u0026#39;django.template.backends.django.DjangoTemplates\u0026#39;,\r# 根路由 模板文件夹名\r \u0026#39;DIRS\u0026#39;: [os.path.join(BASE_DIR, \u0026#39;templates\u0026#39;)],\r...\r}\r# 语言 汉语：zh-Hans\r LANGUAGE_CODE = \u0026#39;zh-Hans\u0026#39;\r# 这里必须是 True，否则 LANGUAGE_CODE 会失效\r USE_I18N = True\r# 时区 国内时区:Asia/Shanghai\r TIME_ZONE = \u0026#39;Asia/Shanghai\u0026#39;\r# 修改时区 True -\u0026gt; False\r USE_TZ = False\r  ","id":18,"section":"posts","summary":"安装 安装Django包 pip install django==2.1.4 检测是否安装以及查看Django版本 python -m django --version 生成项目文件 django-admin startproject 项目名 # 命令执行后会在当前定位位置生成项目目录，且自","tags":["django"],"title":"Django的安装与配置","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/08/django%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","year":"2019"},{"content":" 去掉拼音检查 file–\u0026gt;setting–\u0026gt;editor–\u0026gt;Inspections–\u0026gt;Spelling–\u0026gt;Typo,取消勾选 去掉大小写检查 file–\u0026gt;setting–\u0026gt;editor–\u0026gt;Inspections–\u0026gt;Python PEP 8 naming convention violation 代码自动补全不区分大小写 File-\u0026gt;Settings，在Editor-\u0026gt;General-\u0026gt;Code Completion里把Case sensitive completion设置为None  ","id":19,"section":"posts","summary":"去掉拼音检查 file–\u0026gt;setting–\u0026gt;editor–\u0026gt;Inspections–\u0026gt;Spelling–\u0026gt;Typ","tags":["pycharm","python"],"title":"pycharm语法检测配置","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/08/pycharm%E6%A3%80%E6%B5%8B%E8%AE%BE%E7%BD%AE/","year":"2019"},{"content":"路由拦截器 route与router route：相当于当前正在跳转的路由对象。可以从里面获取name，path，params，query等。\n如取路由带来的参数：this.$route.params\nrouter：VueRouter的实例，相当于一个全局的路由器对象，里面含有很多属性和子对象，例如history对象\n经常用的跳转链接就可以用this.$router.push，和router-link跳转一样\n// 路由拦截器\r// to为向后走的路由对象，包括路由的完整信息\r// from为从哪跳来的路由对象\r// next()控制路由向下走，重新定义路由跳转的路由next(‘路由路径)\r\rrouter.beforeEach((to, from, next) =\u0026gt;{\rconsole.log(\u0026#39;hello\u0026#39;);\rlet isLogin = localStorage.getItem(\u0026#39;uid\u0026#39;);\rconsole.log(isLogin);\rif (to.path === \u0026#39;/login\u0026#39; || isLogin){\rnext()\r}\relse {\ralert(\u0026#39;登录信息已过期，请重新登陆\u0026#39;);\rnext(\u0026#39;/login\u0026#39;);\r}\r});\r请求拦截  安装 axios , 命令： npm install axios \u0026ndash;save-dev 在根目录的config目录下新建文件 axios.js ，内容如下：  import axios from \u0026#39;axios\u0026#39;\r// 配置默认的host,假如你的API host是：[http://api.some.xxx]\raxios.defaults.baseURL = \u0026#39;[http://api.some.xxx\u0026#39;]\r// 添加请求拦截器\raxios.interceptors.request.use(function (config) {\r// 在发送请求之前做些什么\r　return config\r}, function (error) {\r// 对请求错误做些什么\rreturn Promise.reject(error)\r});\r// 添加响应拦截器\raxios.interceptors.response.use(function (response) {\r// 对响应数据做点什么\r　return response\r}, function (error) {\r// 对响应错误做点什么\r　return Promise.reject(error)\r});\r","id":20,"section":"posts","summary":"路由拦截器 route与router route：相当于当前正在跳转的路由对象。可以从里面获取name，path，params，query等。 如","tags":["Vue","拦截器"],"title":"Vue拦截器","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/07/vue-%E6%8B%A6%E6%88%AA%E5%99%A8/","year":"2019"},{"content":"Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。\n简介 Redis 是什么 REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统。Redis 提供了一些丰富的数据结构，包括 lists、sets、ordered sets 以及 hashes ，当然还有和 Memcached 一样的 strings 结构。Redis 当然还包括了对这些数据结构的丰富操作。\nRedis 常被称作是一款数据结构服务器（data structure server）。Redis 的键值可以包括字符串（strings）类型，同时它还包括哈希（hashes）、列表（lists）、集合（sets）和 有序集合（sorted sets）等数据类型。\n对于这些数据类型，你可以执行原子操作。例如：对字符串进行附加操作（append）；递增哈希中的值；向列表中增加元素；计算集合的交集、并集与差集等。\nRedis 的优点  性能极高：Redis 能支持超过 100K+ 每秒的读写频率。 丰富的数据类型：Redis 支持二进制案例的 Strings，Lists，Hashes，Sets 及 Ordered Sets 数据类型操作。 原子：Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作全并后的原子性执行。 丰富的特性：Redis 还支持 publish/subscribe，通知，key 过期等等特性。  Redis的数据类型 strings 字符串是一种最基本、最常用的 Redis 值类型\nRedis 字符串是二进制安全的，这意味着一个 Redis 字符串能包含任意类型的数据，例如： 一张经过 base64 编码的图片或者一个序列化的 Ruby 对象。通过这样的方式，Redis 的字符串可以支持任意形式的数据，但是对于过大的文件不适合存入 redis，一方面系统内存有限，另外一方面字符串类型的值最多能存储 512M 字节的内容。\n如上例所示，可以使用 set 和 get 命令来创建和检索 strings。注意：set 命令将取代现有的任何已经存在的 key。set 命令还有一个提供附加参数的选项，我们能够让 set 命令只有在没有相同 key 的情况下成功，反之亦然，可以让 set 命令在有相同 key 值的情况下成功：\n\u0026gt; set mykey newval nx # 只有在没有相同 key 的情况下成功\r\u0026gt; set mykey newval xx # 有相同 key 值的情况下成功\r即使 string 是 Redis 的基本类型，也可以对其进行一些有趣的操作，例如加法器：\nincr 命令让 the value 成为一个整数，运行一次 incr 便加一。incrby 命令便是一个加法运算。类似的命令如减法运算为： decr 和 decrby\nRedis 可以运用 mset 和 mget 命令一次性完成多个 key-value 的对应关系，使用 mget 命令，Redis 返回一个 value 数组：\nLists Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边），lpush 命令插入一个新的元素到头部，而 rpush 命令插入一个新元素到尾部。当这两个操作中的任一操作在一个空的 Key 上执行时就会创建一个新的列表。相似的，如果一个列表操作清空一个列表，那么对应的 key 将被从 key 空间删除\n 一个列表最多可以包含 4294967295（2 的 32 次方减一）个元素，这意味着它可以容纳海量的信息，最终瓶颈一般都取决于服务器内存大小。\n事实上，在高级的企业架构当中，会把缓存服务器分离开来，因为数据库服务器和缓存服务器的特点各异，比如对于数据库服务器应该用更快、更大的硬盘，而缓存专用服务器则偏向内存性能，一般都是 64GB 起步\n  push 一类的命令的返回值为 list 的长度   lrange 需要两个索引，0 表示 list 开头第一个，-1 表示 list 的倒数第一个，即最后一个。-2 则是 list 的倒数第二个，以此类推  在 Redis 的命令操作中，还有一类重要的操作 pop，它可以弹出一个元素，简单的理解就是获取并删除第一个元素，和 push 类似的是它也支持双边的操作，可以从右边弹出一个元素也可以从左边弹出一个元素，对应的指令为 rpop 和 lpop\nList 阻塞操作 理解阻塞操作对一些请求操作有很大的帮助，关于阻塞操作的作用，这里举一个例子。\n假如你要去楼下买一个汉堡，一个汉堡需要花一定的时间才能做出来，非阻塞式的做法是去付完钱走人，过一段时间来看一下汉堡是否做好了，没好就先离开，过一会儿再来，而且要知道可能不止你一个人在买汉堡，在你离开的时候很可能别人会取走你的汉堡，这是很让人烦的事情。\n阻塞式就不一样了，付完钱一直在那儿等着，不拿到汉堡不走人，并且后面来的人统统排队。\nRedis 提供了阻塞式访问 brpop 和 blpop 命令。用户可以在获取数据不存在时阻塞请求队列，如果在时限内获得数据则立即返回，如果超时还没有数据则返回 nil。\n假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值\nHashes Redis Hashes 是字符串字段和字符串值之间的映射，因此它们是展现对象的完美数据类型。例如一个有名、姓、年龄等等属性的用户：一个带有一些字段的 hash 仅仅需要一块很小的空间存储，因此你可以存储数以百万计的对象在一个小的 Redis 实例中。哈希主要用来表现对象，它们有能力存储很多对象，因此你可以将哈希用于许多其它的任务。\nhmset 命令设置一个多域的 hash 表，hget 命令获取指定的单域，hgetall 命令获取指定 key 的所有信息。hmget 类似于 hget，只是返回一个 value 数组。\n无序Set Redis 集合（Set）是一个无序的字符串集合。你可以以 O(1) 的时间复杂度（无论集合中有多少元素时间复杂度都是常量）完成添加、删除以及测试元素是否存在。\nRedis 集合拥有令人满意的不允许包含相同成员的属性，多次添加相同的元素，最终在集合里只会有一个元素，这意味着它可以非常方便地对数据进行去重操作，一个 Redis 集合的非常有趣的事情是它支持一些服务端的命令从现有的集合出发去进行集合运算，因此你可以在非常短的时间内进行合并（unions），求交集（intersections），找出不同的元素（differences of sets）\nsadd 命令产生一个无序集合，返回集合的元素个数。smembers 用于查看集合\n有序Set Redis 有序集合与普通集合非常相似，是一个没有重复元素的字符串集合。不同之处是有序集合的每一个成员都关联了一个权值，这个权值被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是权值可以是重复的。\n使用有序集合你可以以非常快的速度 O(log(N)) 添加、删除和更新元素。因为元素是有序的，所以你也可以很快的根据权值（score）或者次序（position）来获取一个范围的元素。访问有序集合的中间元素也是非常快的，因此你能够使用有序集合作为一个没有重复成员的智能列表。在有序集合中，你可以很快捷的访问一切你需要的东西：有序的元素，快速的存在性测试，快速访问集合的中间元素！简而言之使用有序集合你可以完成许多对性能有极端要求的任务，而那些任务使用其它类型的数据库真的是很难完成的。\nzadd 与 sadd 类似，但是在元素之前多了一个参数，这个参数便是用于排序的。形成一个有序的集合。\nredis 全局 适合全体类型的常用命令  exists key [key1 key2]：判断 key 是否存在，存在返回 1(判断多个，存在几个返回几个)，否则返回 0  del key [key1 key2] : 删除某个 key，或是一系列 key，成功返回 1，失败返回 0（key 值不存在） type key：返回某个 key 元素的数据类型（none：不存在，string：字符，list：列表，set：元组，zset：有序集合，hash：哈希），key 不存在返回空   keys key—pattern：返回匹配的 key 列表\n  randomkey：随机获得一个已经存在的 key，如果当前数据库为空，则返回空字符串\n  rename oldname newname：更改 key 的名字，新键名如果存在将被覆盖\n  renamenx oldname newname：更改 key 的名字，新键名如果存在则更新失败\n  dbsize：返回当前数据库的 key 的总数\n  设置key的生成时间 这同样是一个无视数据类型的命令，对于临时存储很有用处。避免进行大量的 DEL 操作\nexpire：设置某个 key 的过期时间（秒），比如：expire bruce 1000 表示设置 bruce 这个 key 1000 秒后系统自动删除，注意：如果在还没有过期的时候，对值进行了改变，那么那个值会被清除\nttl：查找某个 key 还有多长时间过期，返回时间单位为秒\n大清扫 flushdb：清空当前数据库中的所有键\nflushall：清空所有数据库中的所有键\n查询信息 info [section]：查询 Redis 相关信息。\ninfo 命令可以查询 Redis 几乎所有的信息，其命令选项有如下：\n server: Redis server 的常规信息 clients: Client 的连接选项 memory: 存储占用相关信息 persistence: RDB and AOF 相关信息 stats: 常规统计 replication: Master/Slave 请求信息 cpu: CPU 占用信息统计 cluster: Redis 集群信息 keyspace: 数据库信息统计 all: 返回所有信息 default: 返回常规设置信息  若命令参数为空，info 命令返回所有信息\n高级应用 安全性 涉及到客户端连接是需要指定密码的（由于 redis 速度相当的快，一秒钟可以 150K 次的密码尝试，所以需要设置一个强度很大的密码）\n设置密码的方式有两种：\n 使用 config set 命令的 requirepass 参数，具体格式为 config set requirepass [password]\u0026quot; 在 redis.conf 文件中设置 requirepass 属性，后面为密码  输入认证的方式也有两种：\n 登录时可以使用 redis-cli -a password 登录后可以使用 auth password  主从复制 为了分担服务器压力，会在特定情况下部署多台服务器分别用于缓存的读和写操作，用于写操作的服务器称为主服务器，用于读操作的服务器称为从服务器。从服务器通过 psync 操作同步主服务器的写操作，并按照一定的时间间隔更新主服务器上新写入的内容。\nRedis 主从复制的过程\n Slave 与 Master 建立连接，发送 psync 同步命令 Master 会启动一个后台进程，将数据库快照保存到文件中，同时 Master 主进程会开始收集新的写命令并缓存 后台完成保存后，就将此文件发送给 Slave Slave 将此文件保存到磁盘上  Redis 主从复制特点\n 可以拥有多个 Slave 多个 Slave 可以连接同一个 Master 外，还可以连接到其它的 Slave。（当 Master 宕机后，相连的 Slave 转变为 Master） 主从复制不会阻塞 Master，在同步数据时， Master 可以继续处理 Client 请求 提高了系统的可伸缩性   从服务器的主要作用是响应客户端的数据请求，比如返回一篇博客信息。\n上面说到了主从复制是不会阻塞 Master 的，就是说 Slave 在从 Master 复制数据时，Master 的删改插入等操作继续进行不受影响。\n如果在同步过程中，主服务器修改了一篇博客，而同步到从服务器上的博客是修改前的。这时候就会出现时间差，即修改了博客过后，在访问网站的时候还是原来的数据，这是因为从服务器还未同步最新的更改，这也就意味着非阻塞式的同步只能应用于对读数据延迟接受度较高的场景。\n在以前的版本中（2.8 以前），你应该慎用 redis 的主从复制功能，因为它的同步机制效率低下，可以想象每一次短线重连都要复制主服务器上的全部数据，算上网络通讯所耗费的时间，反而可能达不到通过 redis 缓存来提升应用响应速度的效果。但是幸运的是，官方在 2.8 以后推出了解决方案，通过部分同步来解决大量的重复操作\n 事务 Redis 的事务处理比较简单。只能保证 client 发起的事务中的命令可以连续的执行，而且不会插入其它的 client 命令，当一个 client 在连接中发出 multi 命令时，这个连接就进入一个事务的上下文，该连接后续的命令不会执行，而是存放到一个队列中，当执行 exec 命令时，redis 会顺序的执行队列中的所有命令\n需要注意的是，redis 对于事务的处理方式比较特殊，它不会在事务过程中出错时恢复到之前的状态，这在实际应用中导致我们不能依赖 redis 的事务来保证数据一致性\n持久化 内存和磁盘的区别除了速度差别以外，还有就是内存中的数据会在重启之后消失，持久化的作用就是要将这些数据长久存到磁盘中以支持长久使用。\nRedis 是一个支持持久化的内存数据库，Redis 需要经常将内存中的数据同步到磁盘来保证持久化。\nRedis 支持两种持久化方式：\n snapshotting（快照）：将数据存放到文件里，默认方式。  是将内存中的数据以快照的方式写入到二进制文件中，默认文件 dump.rdb，可以通过配置设置自动做快照持久化的方式。可配置 Redis 在 n 秒内如果超过 m 个 key 被修改就自动保存快照。比如：\nsave 900 1：900 秒内如果超过 1 个 key 被修改，则发起快照保存。\nsave 300 10：300 秒内如果超过 10 个 key 被修改，则快照保存。\nAppend-only file（缩写为 aof）：将读写操作存放到文件中。  由于快照方式在一定间隔时间做一次，所以如果 Redis 意外 down 掉的话，就会丢失最后一次快照后的所有修改。\naof 比快照方式有更好的持久化性，是由于使用 aof 时，redis 会将每一个收到的写命令都通过 write 函数写入到文件中，当 redis 启动时会通过重新执行文件中保存的写命令来在内存中重新建立整个数据库的内容。\n由于 os 会在内核中缓存 write 做的修改，所以可能不是立即写到磁盘上，这样 aof 方式的持久化也还是有可能会丢失一部分数据。可以通过配置文件告诉 redis 我们想要通过 fsync 函数强制 os 写入到磁盘的时机。\n  appendfsync always ：收到写命令就立即写入磁盘，最慢，但是保证了数据的完整持久化\n  appendfsync everysec ：每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中\n  appendfsync no ：完全依赖 os，性能最好，持久化没有保证\n ","id":21,"section":"posts","summary":"\u003cp\u003eRedis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。\u003c/p\u003e","tags":["redis","菜鸡入门","数据类型"],"title":"Redis初体验","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/07/redis%E5%9F%BA%E7%A1%80/","year":"2019"},{"content":"CentOS 7 安装 python3  CentOS 7 自带的python为python2.7版本，yum等包依赖于python2，不可以直接卸载。需要下载python3的源码后自行编译安装。以下是安装步骤\n 1. 安装用于编译python源码的依赖包 yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc* make -y\r2. 安装下载源码的工具 pip install wget\r# 由于还没有python3，这里的wget是安装到了python2.7中\r3. 下载python源码 wget https://www.python.org/ftp/python/3.7.5/Python-3.7.5.tar.xz\r4. 编译 # 解压\rtar -xvJf Python-3.7.5.tar.xz\r# 进入解压后的目录，配置安装路径\r./configure prefix=/usr/local/python3\r# 编译安装\rmake \u0026amp;\u0026amp; make install\r5. 添加软链接 # 添加python3的软链接\rln -s /usr/local/python3/bin/python3 /usr/bin/python3\r# 添加pip3的软连接\rln -s /usr/local/python3/bin/pip3 /usr/bin/pip3\r#测试是否安装成功了\rpython3 -V\r python指向的是python2，python2指向的是python2.7，在装完python3后，将python指向python3，然后python2指向python2.7，那么两个版本的python就能共存了\n vi /usr/bin/yum\r把#! /usr/bin/python修改为#! /usr/bin/python2\rvi /usr/libexec/urlgrabber-ext-down\r把#! /usr/bin/python 修改为#! /usr/bin/python2\r","id":22,"section":"posts","summary":"CentOS 7 安装 python3 CentOS 7 自带的python为python2.7版本，yum等包依赖于python2，不可以直接卸载。需要下载python3的源码后自行","tags":["linux","python"],"title":" CentOS 7 安装 python3","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/07/centos-7-%E5%AE%89%E8%A3%85-python3/","year":"2019"},{"content":"axios axios 的配置 // 安装\rnpm install --save axios\r// 将axios改写为Vue的原型属性\r --- main.js ---\rimport axios from \u0026#39;axios\u0026#39;\rVue.prototype.axios = axios\r// 跨域代理配置\r --- config/index.js ---\rproxyTable: {\r\u0026#34;/api\u0026#34;: {\rtarget: \u0026#34;http://127.0.0.1:8000/\u0026#34;,\rchangeOrigin: true,\rpathRewrite: {\r\u0026#34;^/api\u0026#34;: \u0026#34;\u0026#34;\r}\r}\r}\raxios 使用 // get\rthis.axios.get(\u0026#39;/api/showView/\u0026#39;, {\rparams:{\rID: 123\r}\r}).then((res)=\u0026gt;{\rpass\r}).catch((err)=\u0026gt;{\rpass\r})\r// post\rthis.axios.post(\u0026#39;/api/showView/\u0026#39;, {\rfirstName: \u0026#39;Fred\u0026#39;,\rlastName: \u0026#39;Flintstone\u0026#39;\r}).then((res)=\u0026gt;{\rpass\r}).catch((err)=\u0026gt;{\rpass\r})\r// axios API\r// 发送 POST 请求\raxios({\rmethod: \u0026#39;post\u0026#39;,\rurl: \u0026#39;/user/12345\u0026#39;,\rdata: {\rfirstName: \u0026#39;Fred\u0026#39;,\rlastName: \u0026#39;Flintstone\u0026#39;\r}\r});\r// 获取远端图片\raxios({\rmethod:\u0026#39;get\u0026#39;,\rurl:\u0026#39;http://bit.ly/2mTM3nY\u0026#39;,\rresponseType:\u0026#39;stream\u0026#39;\r})\r.then(function(response) {\rresponse.data.pipe(fs.createWriteStream(\u0026#39;ada_lovelace.jpg\u0026#39;))\r});\r","id":23,"section":"posts","summary":"axios axios 的配置 // 安装 npm install --save axios // 将axios改写为Vue的原型属性 --- main.js --- import axios from \u0026#39;axios\u0026#39; Vue.prototype.axios = axios // 跨域代理配置 --- config/index.js --- proxyTable: { \u0026#34;/api\u0026#34;: { target: \u0026#34;http://127.0.0.1:8000/\u0026#34;, changeOrigin: true, pathRewrite: { \u0026#34;^/api\u0026#34;: \u0026#34;\u0026#34; } } } axios 使用 // get","tags":["axios","Vue"],"title":"axios简记","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/07/axios/","year":"2019"},{"content":"sha256加密，加盐 import random\rimport hashlib\rdef randow_salt(lenth=5):\rbase_str = \u0026#39;1234567890qwertyuioplkjhgfdsazxcvbnm\u0026#39;\rreturn \u0026#39;\u0026#39;.join([i for i in random.sample(base_str, lenth)])\rdef encryption_sha256(plaintext, salt):\rpre_enc = plaintext + salt\rreturn hashlib.sha256(pre_enc.encode()).hexdigest()\r","id":24,"section":"posts","summary":"sha256加密，加盐 import random import hashlib def randow_salt(lenth=5): base_str = \u0026#39;1234567890qwertyuioplkjhgfdsazxcvbnm\u0026#39; return \u0026#39;\u0026#39;.join([i for i in random.sample(base_str, lenth)]) def encryption_sha256(plaintext, salt): pre_enc = plaintext + salt return hashlib.sha256(pre_enc.encode()).hexdigest()","tags":["python","hash","加密"],"title":" sha256加密","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/06/sha256%E5%8A%A0%E5%AF%86%E5%8A%A0%E7%9B%90/","year":"2019"},{"content":"Django 分页器 初始化操作 class Paginator(object):\r\u0026#34;\u0026#34;\u0026#34;object_list:可以是列表，元组，查询集或其他含有 count() 或 len()方法的可切片对\t象。对于连续的分页，查询集应该有序，例如有order_by()项或默认ordering参数\rper_page:每一页中包含条目数目的最大值，不包括独立成页的那页\rorphans=0:当你使用此参数时说明你不希望最后一页只有很少的条目。如果最后一页的条目数\t少于等于orphans的值，则这些条目会被归并到上一页中（此时的上一页变为最后一页）\rallow_empty_first_page=True： 默认允许第一页为空\r\u0026#34;\u0026#34;\u0026#34;\rdef __init__(self, object_list, per_page, orphans=0, allow_empty_first_page=True)\r自定义分页器 ----views.py----\rfrom django.core.paginator import Paginator\rfrom models import Book\rdef mypaginator(request, dataset):\r# dataset = Book.objects.all() # 数据集\r paginate = Paginator(dataset, 5) # 实例化Paginator, 每页5条数据\r web_page = request.GET.get(\u0026#39;page\u0026#39;, 1) # 获取前端访问\r current_data = paginate.get_page(web_page) # 得到当前页数据\r # get_page()方法可以检查page是否合法，正确后返回到page()方法\r total_page = paginate.page_range # 得到全部页数的一个列表\r return current_data, total_page\r","id":25,"section":"posts","summary":"Django 分页器 初始化操作 class Paginator(object): \u0026#34;\u0026#34;\u0026#34;object_list:可以是列表，元组，查询集或其他含有 count() 或 len()方法的可切片对 象","tags":["django","paginator"],"title":"Django分页器","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/06/django-%E5%88%86%E9%A1%B5%E5%99%A8/","year":"2019"},{"content":"Serializer 和 ModelSerializer 一、概述 Serializer 类是比较底层的类，可定制程度高。当需要高度定制DRF的序列化器时再选择它。\n  更高一级的封装，更少的代码，但也更低的可定制性\n ModelSerializer 类可以根据model模型的定义，自动生成默认的字段；附带了序列化验证器；还实现了简单的.create() 和 .update() 方法\n二、create() 还是 update() ? 在编写序列化类时，类内 override 的 create 和 update 方法，是如何执行的呢？\n Django能自动判断你提交的请求是需要增加，判断的标准是基于ID，如果传入的数据里有ID的话，那么认为你是需要进行修改，没有ID则认为是需要进行创建\n 但在具体操作时，发现上面这段话似乎并不准确。我并没有“告诉”Django我修改的是哪一条记录，它应该没有办法帮我自动调用 update 方法。\n看了刘江大佬的博客，在update 接口中，仍然需要通过前台传递来的 id来查询具体记录，接着将这条查询的实例（instance），以及要修改的数据（validated_data）传入反序列化器的实例中去。\n在重写update方法时,代码如下：\ndef update(self, instance, validated_data):\rinstance.name = validated_data.get(\u0026#39;name\u0026#39;, validated_data.name)\rinstance.email = validated_data.get(\u0026#39;email\u0026#39;, instance.email)\r如果在传值时 ser = DepartmentSerializer(query_obj, data=res.data, partial=True) 没有填写partial参数，需要所有字段全部写一遍；而填写了partial参数，传值时可以只传要修改的字段，相应的，update方法中也只需要写要修改的字段。这里需要使用 patch 请求。\n 反序是不走read_only=True,required=False的;\npatch进行局部更新,put进行全部更新\n  更多DRF知识可以参考刘江的博文: [Django REST framework 序列化器]( http://www.liujiangblog.com/blog/43/ , \u0026ldquo;Django REST framework 序列化器\u0026rdquo;)\n参考内容\n","id":26,"section":"posts","summary":"Serializer 和 ModelSerializer 一、概述 Serializer 类是比较底层的类，可定制程度高。当需要高度定制DRF的序列化器时再选择它。 更高一级的封装，更少的代码，但也更低的可定制性 ModelSerializer 类","tags":["django","DRF","Serializer"],"title":"DRF简单入门","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/05/serializer-%E5%92%8C-modelserializer/","year":"2019"},{"content":"UUID码  UUID 是 通用唯一识别码（Universally Unique Identifier）的缩写，是一种软件建构的标准，亦为开放软件基金会组织在分布式计算环境领域的一部分。其目的，是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。如此一来，每个人都可以创建不与其它人冲突的UUID。在这样的情况下，就不需考虑数据库创建时的名称重复问题。\n 组成 UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和随机数。\nUUID由以下几部分的组合：\n（1）当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。\n（2）时钟序列。\n（3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。\nUUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。在ColdFusion中可以用CreateUUID()函数很简单地生成UUID，其格式为：xxxxxxxx-xxxx- xxxx-xxxxxxxxxxxxxxxx(8-4-4-16)，其中每个 x 是 0-9 或 a-f 范围内的一个十六进制的数字。而标准的UUID格式为：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)，可以从cflib 下载CreateGUID() UDF进行转换。\n python有一个模块叫做uuid，导入它就可以使用它的四个方法了。注意这四个方法依次是uuid1(),uuid3(),uuid4(),uuid5(),然而并没有uuid2()\n  基于时间戳 使用主机ID, 序列号, 和当前时间来生成UUID, 可保证全球范围的唯一性. 但由于使用该方法生成的UUID中包含有主机的网络地址, 因此可能危及隐私.\nuuid.uuid1(node=None, clock_seq=None)\r  In [1]: uuid.uuid1() Out[2]: UUID(\u0026lsquo;bd6a74ec-f8ae-11e9-bad5-f8a2d6d4d3ac\u0026rsquo;) ```\n---\r打断一下...\r在`uuid3()` 和 `uuid5()` 两个方法里涉及到了一个 `namespace` 的参数，python提供了四种生成namespace的方法。\r\u0026gt; `uuid.NAMESPACE_DNS` : 指定此命名空间时，名称字符串是完全限定的域名\r\u0026gt;\r\u0026gt; `uuid.NAMESPACE_URL`: 指定此命名空间时，名称字符串是URL\r\u0026gt;\r\u0026gt; `uuid.NAMESPACE_OID`: 指定此命名空间时，名称字符串是ISO OID\r\u0026gt;\r\u0026gt; `uuid.namespace_x500`: the *name* string is an X.500 DN in DER or a text output format (咱也不懂，也不敢问)\r  基于名字的MD5散列值\n通过计算命名空间和名字的MD5散列值来生成UUID, 可以保证同一命名空间中不同名字的唯一性和不同命名空间的唯一性, 但同一命名空间的同一名字生成的UUID相同\nuuid.uuid3(namespace, name)\rIn [9]: uuid.uuid3(uuid.NAMESPACE_URL,\u0026#39;python.org\u0026#39;)\rOut[9]: UUID(\u0026#39;22fe6191-c161-3d86-a432-a81f343eda08\u0026#39;)\r  基于随机数\n通过随机数来生成UUID. 使用的是伪随机数有一定的重复概率\n  In [10]: uuid.uuid4()\rOut[10]: UUID(\u0026#39;0faccaf9-d093-41c9-ac18-1cee7dcf4c72\u0026#39;)\r基于名字的SHA-1散列值  算法与 uuid3()\t 相同\nIn [11]: uuid.uuid5(uuid.NAMESPACE_URL,\u0026#39;python.org\u0026#39;)\rOut[11]: UUID(\u0026#39;7af94e2b-4dd9-50f0-9c9a-8a48519bdef0\u0026#39;)\r","id":27,"section":"posts","summary":"UUID码 UUID 是 通用唯一识别码（Universally Unique Identifier）的缩写，是一种软件建构的标准，亦为开放软件基金会组织在分布式计算","tags":["uuid","python"],"title":"UUID","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/05/uuid%E7%A0%81/","year":"2019"},{"content":"MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案\n基本概念 文档的逻辑联系 假设有两个文档：\n# user文档\r{\r\u0026quot;name\u0026quot;: \u0026quot;Tom Hanks\u0026quot;,\r\u0026quot;contact\u0026quot;: \u0026quot;987654321\u0026quot;,\r\u0026quot;dob\u0026quot;: \u0026quot;01-01-1991\u0026quot;\r}\r# address文档\r{\r\u0026quot;building\u0026quot;: \u0026quot;22 A, Indiana Apt\u0026quot;,\r\u0026quot;pincode\u0026quot;: 123456,\r\u0026quot;city\u0026quot;: \u0026quot;chengdu\u0026quot;,\r\u0026quot;state\u0026quot;: \u0026quot;sichuan\u0026quot;\r}\r关系 1：嵌入式关系：把 address 文档嵌入到 user 文档中\n# 这就是嵌入式的关系\r{\r\u0026quot;name\u0026quot;: \u0026quot;Tom Hanks\u0026quot;,\r\u0026quot;contact\u0026quot;: \u0026quot;987654321\u0026quot;,\r\u0026quot;dob\u0026quot;: \u0026quot;01-01-1991\u0026quot;,\r\u0026quot;address\u0026quot;:\r[{\r\u0026quot;building\u0026quot;: \u0026quot;22 A, Indiana Apt\u0026quot;,\r\u0026quot;pincode\u0026quot;: 123456,\r\u0026quot;city\u0026quot;: \u0026quot;chengdu\u0026quot;,\r\u0026quot;state\u0026quot;: \u0026quot;sichuan\u0026quot;\r},\r{\r\u0026quot;building\u0026quot;: \u0026quot;170 A, Acropolis Apt\u0026quot;,\r\u0026quot;pincode\u0026quot;: 456789,\r\u0026quot;city\u0026quot;: \u0026quot;beijing\u0026quot;,\r\u0026quot;state\u0026quot;: \u0026quot;beijing\u0026quot;\r}]\r}\r关系 2：引用式关系：将两个文档分开，通过引用文档的_id 字段来建立关系\n# 这就是引用式关系\r{\r\u0026quot;name\u0026quot;: \u0026quot;Tom Benzamin\u0026quot;,\r\u0026quot;contact\u0026quot;: \u0026quot;987654321\u0026quot;,\r\u0026quot;dob\u0026quot;: \u0026quot;01-01-1991\u0026quot;,\r\u0026quot;address_ids\u0026quot;: [\rObjectId(\u0026quot;52ffc4a5d85242602e000000\u0026quot;) #对应address文档的id字段\r]\r}\r在实际应用的时候，嵌入式关系比较适合一对一的关系，引用式关系比较适合一对多或者多对多的情况。\n创建数据库 启动服务后，进入 MongoDB 命令行操作界面：\nmongo\r使用 use 命令创建数据库：\nuse mydb\r查看当前连接的数据库：\ndb\r查看所有的数据库：\nshow dbs\r列出的所有数据库中看不到 mydb 或者显示 mydb(empty) ，因为 mydb 为空，里面没有任何东西，MongoDB 不显示或显示 mydb(empty)。\n销毁数据库 使用 db.dropDatabase() 销毁数据库：\n\u0026gt; use local\rswitched to db local\r\u0026gt; db.dropDatabase()\r创建集合 在数据库 mydb 中创建一个集合\n\u0026gt; use mydb\rswitched to db mydb\r\u0026gt; db.createCollection(\u0026#34;users\u0026#34;)\r查看创建的集合：\n\u0026gt; show collections\r删除集合 删除集合的方法如下：（删除 users 集合）\n\u0026gt; show collections\r\u0026gt; db.users.drop()\r向集合中插入数据 使用 insert() 插入数据时，如果 users 集合没有创建会自动创建。\n\u0026gt; use mydb\rswitched to db mydb\r\u0026gt; db.users.insert([\r... { name : \u0026#34;jam\u0026#34;,\r... email : \u0026#34;jam@qq.com\u0026#34;\r... },\r... { name : \u0026#34;tom\u0026#34;,\r... email : \u0026#34;tom@qq.com\u0026#34;\r... }\r... ])\r使用 save() 插入数据时，如果 users 集合没有创建会自动创建。\n\u0026gt; use mydb2\rswitched to db mydb2\r\u0026gt; db.users.save([\r... { name : \u0026#34;jam\u0026#34;,\r... email : \u0026#34;jam@qq.com\u0026#34;\r... },\r... { name : \u0026#34;tom\u0026#34;,\r... email : \u0026#34;tom@qq.com\u0026#34;\r... }\r... ])\r insert 和 save 的区别：为了方便记忆，可以先从字面上进行理解，insert 是插入，侧重于新增一个记录的含义；save 是保存，可以保存一个新的记录，也可以保存对一个记录的修改。因此，insert 不能插入一条已经存在的记录，如果已经有了一条记录(以主键为准)，insert 操作会报错，而使用 save 指令则会更新原记录。\n 更新集合中的数据 语法： db.COLLECTION_NAME.updatet(SELECTION_CRITERIA, UPDATED_DATA)\ndb.users.update(\r{\u0026#34;user_id\u0026#34;:2, \u0026#34;email\u0026#34;:\u0026#34;example@mail.com\u0026#34;},\r{$set:{\u0026#34;email\u0026#34;:\u0026#34;elmo@mail.com\u0026#34;}}\r)\r**注意：**默认的 update 函数只对一个文档更新，如果想作用所有文档，则需要加入 multi:true\ndb.users.update(\r{\u0026#34;user_id\u0026#34;:2, \u0026#34;email\u0026#34;:\u0026#34;example@mail.com\u0026#34;},\r{$set:{\u0026#34;email\u0026#34;:\u0026#34;elmo@mail.com\u0026#34;}},\r{multi:true}\r)\r删除集合中的数据 语法： db.COLLECTION_NAME.remove(DELECTION_CRITERIA)\n\u0026gt; db.users.remove({\u0026#34;name\u0026#34;:\u0026#34;Bob\u0026#34;})\rWriteResult({\u0026#34;nRemoved\u0026#34;:1})\r查询语句 find() 语句 find() 用法：db.COLLECTION_NAME.find()\n\u0026gt; use post\r\u0026gt; db.post.insert([\r{\rtitle: 'MongoDB Overview',\rdescription: 'MongoDB is no sql database',\rby: 'elmo',\rurl: 'http://www.fancyelmo.com',\rtags: ['mongodb', 'database', 'NoSQL'],\rlikes: 100\r},\r{\rtitle: 'NoSQL Database',\rdescription: \u0026quot;NoSQL database doesn't have tables\u0026quot;,\rby: 'elmo',\rurl: 'http://www.fancyelmo.com',\rtags: ['mongodb', 'database', 'NoSQL'],\rlikes: 20,\rcomments: [\r{\ruser:'user1',\rmessage: 'My first comment',\rdateCreated: new Date(2013,11,10,2,35),\rlike: 0\r}\r]\r}\r])\r查询数据，不加任何参数默认返回所有数据记录：\n\u0026gt; db.post.find()\r这条语句会返回 post 集合中的所有文档，实际应用中不常见，因为这样会导致大量的数据传输，造成服务器响应迟缓甚至失去响应。\npretty() 语句 pretty() 可以使查询输出的结果更美观。\n\u0026gt; db.post.find().pretty()\r例如:\n\u0026gt; db.users.find()\r{ \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5c35657e6ee1e0307e215fc8\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;elmo\u0026#34;, \u0026#34;age\u0026#34; : \u0026#34;21\u0026#34; }\r\u0026gt; db.users.find().pretty()\r{\r\u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5c35657e6ee1e0307e215fc8\u0026#34;),\r\u0026#34;name\u0026#34; : \u0026#34;elmo\u0026#34;,\r\u0026#34;age\u0026#34; : \u0026#34;21\u0026#34;\r}\r如果你想让 mongo shell 始终以 pretty 的方式显示返回数据，可以通过下面的指令实现：\necho \u0026#34;DBQuery.prototype._prettyShell = true\u0026#34; \u0026gt;\u0026gt; ~/.mongorc.js\r这样就把默认的显示方式设置为 pretty 了。\n\u0026gt; db.users.find()\r{\r\u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5c35657e6ee1e0307e215fc8\u0026#34;),\r\u0026#34;name\u0026#34; : \u0026#34;bage\u0026#34;,\r\u0026#34;age\u0026#34; : \u0026#34;21\u0026#34;\r}\rMongoDB 中的 AND MongoDB 不需要类似于其他数据库的 AND 运算符，当 find() 中传入多个键值对时，MongoDB 就会将其作为 AND 查询处理。\nOR MongoDB 中，OR 查询语句以 $or 作为关键词，用法如下：\n\u0026gt; db.post.find(\r{\r$or: [\r{key1: value1}, {key2:value2}\r]\r}\r).pretty()\r指定 AND 和 OR 条件 db.inventory.find( {\rstatus: \u0026#34;A\u0026#34;,\r$or: [ { qty: { $lt: 30 } }, { item: /^p/ } ]\r} )\r比较运算符    名称 描述     $eq 匹配等于指定值的值。   $gt 匹配大于指定值的值。   $gte 匹配大于或等于指定值的值。   $in 匹配数组中指定的任何值。   $lt 匹配小于指定值的值。   $lte 匹配小于或等于指定值的值。   $ne 匹配所有不等于指定值的值。   $nin 不匹配数组中指定的任何值。    模糊查询 MongoDB 的模糊查询可以用正则匹配的方式实现\n# 以 \u0026#39;start\u0026#39; 开头的匹配式：\r{\u0026#34;name\u0026#34;:/^start/}\r# 以 \u0026#39;tail\u0026#39; 结尾的匹配式：\r{\u0026#34;name\u0026#34;:/tail$/}\rtype    key subscribe     1 双精度型(Double)   2 字符串(String)   3 对象(Object)   4 数组(Array)   5 二进制数据(Binary data)   7 对象 ID(Object id)   8 布尔类型(Boolean)   9 日期(Date)   10 空(Null)   11 正则表达式(Regular Expression)   13 JS 代码(Javascript)   14 符号(Symbol)   15 有作用域的 JS 代码(JavaScript with scope)   16 32 位整型数(32-bit integer)   17 时间戳(Timestamp)   18 64 位整型数(64-bit integer)   -1 最小值(Min key)   127 最大值(Max key)    查找 name 是字符串的文档记录\n\u0026gt; db.shiyanlou.find({\u0026#34;name\u0026#34;:{$type:2}})\r# 或者\r\u0026gt; db.shiyanlou.find({\u0026#34;name\u0026#34;:{$type:\u0026#39;string\u0026#39;}})\rlimit() 和 skip() limit() 用来读取指定数量的数据记录。limit(1) 默认是排在最前面的那一条被读取\nskip() 用来在读取时跳过指定数量的记录。\n排序 sort() # 按时间升序查询\rdb.users.find().sort({\u0026#34;time\u0026#34;:1})\r# 按年龄降序查询\rdb.users.find().sort({\u0026#34;age\u0026#34;:-1})\r索引  索引通常能够极大的提高查询的效率，如果没有索引，MongoDB 在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可能要花费几十秒甚至几分钟，这无疑对网站的性能是非常致命的。\n索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库集合中一个文档或多个文档的值进行排序的一种结构。\n 语法：db.COLLECTION_NAME.ensureIndex({KEY:1|-1})\n同样 1 代表升序，-1 代表降序。\n范例：\n\u0026gt; db.users.ensureIndex({\u0026#34;name\u0026#34;:1})\rensureIndex() 的可选参数：\n   参数 类型 描述     background Boolean 建立索引要不要阻塞其他数据库操作，默认为 false   unique Boolean 建立的索引是否唯一，默认 false   name string 索引的名称，若未指定，系统自动生成   dropDups Boolean 建立唯一索引时，是否删除重复记录，默认 flase   sparse Boolean 对文档不存在的字段数据不启用索引，默认 false   expireAfterSeconds integer 设置集合的生存时间，单位为秒   v index version 索引的版本号   weights document 索引权重值，范围为 1 到 99999   default-language string 默认为英语   language_override string 默认值为 language    范例：\n\u0026gt; db.users.ensureIndex({\u0026#34;user_id\u0026#34;:1,\u0026#34;name\u0026#34;:1},{background:1})\r覆盖索引查询 所有的查询字段都是索引的一部分；所有的查询返回字段在同一个索引中。\n由于索引存在于 RAM 中，因而从索引中获取数据要比扫描文档更快。\n范例：\n创建如下 users 集合（使用前面所学的方法创建该集合）：\n{\r\u0026#34;contact\u0026#34;: \u0026#34;987654321\u0026#34;,\r\u0026#34;dob\u0026#34;: \u0026#34;01-01-1991\u0026#34;,\r\u0026#34;gender\u0026#34;: \u0026#34;M\u0026#34;,\r\u0026#34;name\u0026#34;: \u0026#34;Tom Benzamin\u0026#34;,\r\u0026#34;user_name\u0026#34;: \u0026#34;tombenzamin\u0026#34;\r}\r在 users 中创建一个联合索引:\n\u0026gt; db.users.ensureIndex({gender:1,user_name:1})\r该索引会覆盖下面的查询：\n\u0026gt; db.users.find({gender:\u0026#34;M\u0026#34;},{user_name:1,_id:0})\r对于上述查询，MongoDB 不会在数据库文件中查找，而会从索引中提取数据。因为索引中不包含 _id 字段，所以 _id 在查询中会默认返回，可以在查询结果中将其排除。而 db.users.find({gender:\u0026quot;M\u0026quot;},{user_name:1}) 就不会被索引覆盖。\n高级索引 创建如下 users 集合（使用前面所学的方法创建该集合）：\n{\r\u0026#34;address\u0026#34;: {\r\u0026#34;city\u0026#34;: \u0026#34;chengdu\u0026#34;,\r\u0026#34;province\u0026#34;: \u0026#34;sichuan\u0026#34;,\r\u0026#34;pincode\u0026#34;: \u0026#34;123\u0026#34;\r},\r\u0026#34;tags\u0026#34;: [\r\u0026#34;music\u0026#34;,\r\u0026#34;cricket\u0026#34;,\r\u0026#34;blogs\u0026#34;\r],\r\u0026#34;name\u0026#34;: \u0026#34;clound\u0026#34;\r}\r索引数组字段，在数组中创建索引，需要对数组中的每个字段依次建立索引。所以在我们为数组 tags 创建索引时，会为 music、cricket、blogs 三个值建立单独的索引。\n范例：\n\u0026gt; db.users.ensureIndex({\u0026#34;tags\u0026#34;:1})\r创建索引后，我们可以这样检索集合的 tags 字段：\n\u0026gt; db.users.find({tags:\u0026#34;cricket\u0026#34;})\r为了验证我们使用了索引，可以使用 explain 命令，explain() 操作提供了查询信息，使用索引及查询统计等。有利于我们对索引的优化：\n\u0026gt; db.users.find({tags:\u0026#34;cricket\u0026#34;}).explain()\r索引子文档字段 假设我们需要通过 city、province、pincode 字段来检索文档，由于这些字段是子文档的字段，所以我们需要对子文档建立索引。\n范例：\n为子文档的三个字段创建索引，命令如下：\n\u0026gt; db.users.ensureIndex({\u0026#34;address.city\u0026#34;:1,\u0026#34;address.province\u0026#34;:1,\u0026#34;address.pincode\u0026#34;:1})\r一旦创建索引，我们可以使用子文档的字段来检索数据：\n\u0026gt; db.users.find({\u0026#34;address.city\u0026#34;:\u0026#34;chengdu\u0026#34;})\r记住查询表达式必须遵循指定的索引的顺序。所以上面创建的索引将支持以下查询：\n\u0026gt; db.users.find({\u0026#34;address.city\u0026#34;:\u0026#34;chengdu\u0026#34;,\u0026#34;address.province\u0026#34;:\u0026#34;sichuan\u0026#34;})\r同样支持以下查询：\n\u0026gt; db.users.find({\r\u0026#34;address.city\u0026#34;:\u0026#34;chengdu\u0026#34;,\u0026#34;address.province\u0026#34;:\u0026#34;sichuan\u0026#34;,\u0026#34;address.pincode\u0026#34;:\u0026#34;123\u0026#34;\r})\r聚合 db.COLLECTION_NAME.aggregate({\r$match:{x:1},\r{limit:NUM},\r$group:{_id:$age}\r})\r这些参数都可选：\n $match：查询，跟 find 一样； $limit：限制显示结果数量； $skip：忽略结果数量； $sort：排序； $group：按照给定表达式组合结果。  范例：\n\u0026gt; db.users.aggregate([{$group:{_id:\u0026#34;$name\u0026#34;, user:{$sum:\u0026#34;$user_id\u0026#34;}}}])\r$name 意为取得 name 的值。\n聚合表达式    名称 描述     $sum 计算总和   $avg 计算平均值   min 和min和max 计算最小值和最大值   $push 在结果文档中插入值到一个数组   $addToSet 在结果文档中插入值到一个数组，但不创建副本   $first 根据资源文档的排序获取第一个文档数据   $last 根据资源文档的排序获取最后一个文档数据    管道 MongoDB 的聚合管道将 MongoDB 文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。\n表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。\n聚合框架中常用的几个操作：\n $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 $match：用于过滤数据，只输出符合条件的文档。$match 使用 MongoDB 的标准查询操作。 $limit：用来限制 MongoDB 聚合管道返回的文档数。 $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。 $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。 $group：将集合中的文档分组，可用于统计结果。 $sort：将输入文档排序后输出。 $geoNear：输出接近某一地理位置的有序文档。  范例：\n\u0026gt; db.shiyanlou.aggregate([{$match:{user_id:{$gt:0,$lte:2}}},{$group:{_id:\u0026#34;user\u0026#34;,count:{$sum:1}}}])\r{\u0026#34;_id\u0026#34;:\u0026#34;user\u0026#34;,\u0026#34;count\u0026#34;:2}\r","id":28,"section":"posts","summary":"\u003cp\u003eMongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案\u003c/p\u003e","tags":["mongo","database","nosql","菜鸡入门"],"title":"MongoDB入门","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/04/mongodb%E5%85%A5%E9%97%A8/","year":"2019"},{"content":"由本地仓库开始创建 git init 将当前目录变成Git可以管理的仓库\ngit add  添加文件至暂存区，注意，文件本身要存在于 init 过的目录下\ngit commit -m '描述信息'  提交所有暂存区文件至本地仓库\ngit remote add origin git@github.com:username/repofilename.git 将本地仓库关联远程仓库\ngit push -u origin master 将本地仓库的内容推送至远程仓库\n由远程仓库开始创建 创建新的远程仓库，勾选Initialize this repository with a README 可以自动创建一个README.md 文件\ngit clone git@github.com:username/reponame.git 克隆版本库\n分支  项目开发中公用分支包括master、dev\n分支master是默认分支，用于发布，当需要发布时将dev分支合并到master分支\n分支dev是用于开发的分支，开发完阶段性的代码后，需要合并到master分支\n git branch 查看当前分支\ngit checkout -b dev 创建并切换到名为dev的分支\ngit push -u origin dev 将分支推至远程仓库\ngit checkout master 切换至master分支\ngit merge dev 在master分支下合并dev分支至master分支\n","id":29,"section":"posts","summary":"由本地仓库开始创建 git init 将当前目录变成Git可以管理的仓库 git add 添加文件至暂存区，注意，文件本身要存在于 init 过的目录下 git commit -m '描述信息' 提交所有暂","tags":["git"],"title":"git命令(部分)","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/04/git%E5%91%BD%E4%BB%A4/","year":"2019"},{"content":"引擎简介  数据库使用数据存储引擎实现存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。\n　不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。MySql的核心就是插件式存储引擎。\n MySQL常见引擎对比 INnoDB  　InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，InnoDB是默认的MySQL引擎。  MyISAM  MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但不支持事务。  Memory  MEMORY存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。    InnoDB： 支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。\nMyISAM： 插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。\nMEMORY： 所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。\n ","id":30,"section":"posts","summary":"引擎简介 数据库使用数据存储引擎实现存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大","tags":["mysql"],"title":"MySQL存储引擎","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/04/database%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/","year":"2019"},{"content":"添加数据 单组添加\n-- 全列插入，按顺序在values中填入字段对应数据\r-- 注意数据类型要正确\rinsert into 表名 values();\r-- 如果存在自增数据，或者默认值数据，可在对应字段处填写 0、default、null 来简化数据的填写\r多组添加\ninsert into 表名 values(第一组),(第二组),(第三组);\r部分值添加\n-- 只有允许为空的值可以不写，不允许为空的值必须添加\rinsert into 表名(字段名1,...) values(值1,...);\r修改数据 修改全部数据\nupdate 表名 set 要修改的字段名 = 要修改的数据;\r带筛选的数据修改\nupdate 表名 set 要修改的字段名 = 要修改的数据 where 筛选语句;\r多个值的修改\nupdate 表名 set 要修改的字段名1 = 要修改的数据1,... where 筛选语句;\r数据的查询 查询表的全部数据\nselect * from 表名;\r查询表的部分数据\nselect 字段名1,... from 表名;\r改变字段名的查询\n-- as 可以为字段名取别名，表在显示时以别名显示\rselect 字段名1 as 别名,字段名2 ... from 表名;\r带筛选语句的查询\nselect 字段名1,... from 表名 where 筛选语句;\r数据的删除 删除特定数据 - 物理删除\ndelete from 表名 where 筛选语句;\r删除特定数据 - 逻辑删除\n-- 先为表添加逻辑删除标记字段\ralter table 表名 add is_delete bit default 0;\r查看添加后的表结构\n删除要逻辑删除的数据\n-- 实际上就是为is_delete字段更新数据\rupdate 表名 set is_delete = 1 where 筛选语句;\r","id":31,"section":"posts","summary":"添加数据 单组添加 -- 全列插入，按顺序在values中填入字段对应数据 -- 注意数据类型要正确 insert into 表名 values(); -- 如果存在自增数据，或者默认值数据，可在对应","tags":["mysql"],"title":"MySQL数据操作","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/04/database%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/","year":"2019"},{"content":"首先，根据上一篇安装 pymysql\n安装了pymysql后就可以在python中导入这个包来实现对接数据库的操作了。\n 在py文件中引入该模块 import pymysql  连接数据库 conn = pymysql.connect(host,port,database,user,password,charset)\r# host: 连接的mysql主机，如果本机是 \u0026#39;localhost\u0026#39;\r # port: 连接的mysql主机的端口，默认是 3306\r # database: 要连接的数据库的名称\r # user: 数据库用户名\r # password: 相对应的密码\r # charset: 通信采用的编码方式，推荐使用 utf8\r    创建游标 cs = conn.cursor()\r# 用于执行sql语句，使用频度最高的语句为select、insert、update、delete\r   sql操作 cs.execute(sql语句)\rconn.commit() -- 提交是由conn对象执行的，要注意！\r    查看查询结果\nret = cs.fetchall()\rprint(ret) # 结果是一个元组\r   关闭连接\ncs.close()\rconn.close()    拓展  通过execute方法得到的查询结果存储在一个元组中，这种数据形式并不利于后续的操作。我们可以在接收时将数据做进一步的处理，将其改变为形如 [{},{}...] 的JSON格式。\n...\r...\rdef tuple2json():\r# var = cs.excute(sql)\r alist = []\rfor i in var:\rdic = {}\rdic[\u0026#39;字段1\u0026#39;] = i[0]\rdic[\u0026#39;字段2\u0026#39;] = i[1]\r...\ralist.append(dic)\rprint(alist)\r...\r...\r","id":32,"section":"posts","summary":"首先，根据上一篇安装 pymysql 安装了pymysql后就可以在python中导入这个包来实现对接数据库的操作了。 在py文件中引入该模块 import pymysql 连接数据库 conn","tags":["mysql"],"title":"MySQL与python的连接","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/04/python%E4%B8%8Emysql%E7%9A%84%E4%BA%A4%E4%BA%92/","year":"2019"},{"content":"消除重复字段 distinct\nselect distinct 字段名 from 表名;\r比较运算符，例如\u0026gt; 、\u0026lt; 、\u0026gt;= 、\u0026lt;= 、= 、!= or \u0026lt;\u0026gt; ，逻辑运算符，例如and、or、not ，皆可参与筛选语句\n模糊查询like\nselect 字段 from 表名 where 匹配字段 like 匹配规则\r-- 模糊查询可以通过提供的关键字匹配所有符合的数据\r-- % :代替任意个字符\r-- _ :代替一个字符\r $\\color{blue}{以L开头的名字}$   $\\color{blue}{含有e的名字}$   $\\color{blue}{三个字的名字}$   $\\color{blue}{至少三个字的名字}$  范围查询 非连续范围  select * from students where age in (18, 34);\r-- 查询年龄为18或34岁的数据\r 连续范围  select * from students where age between 18 and 34;\r-- 查询年龄在18到34岁之间的数据\r空值查询is null\nselect * from students where height is null;\r-- 筛选身高值为空的数据\rselect * from students where height is not null;\r-- 筛选身高值不为空的数据\r 排序oder by\n查询结果默认以主键值的升序显示，如果想让查询结果按其他字段顺序排列，可以添加排序语句。其中排序默认升序 ASC，添加DESC按降序排列。\nselect 字段名 from 表名 order by 待排序字段名 [DESC];\r按身高升序查询\n按年龄降序查询 在排序过程中，会遇到值相同的记录，可以在order by后添加第二个字段名，意思是当排序过程中遇到值相同的情况时按第二个字段名排序。同时，每个字段名可以有自己的升序或降序选择。下图例子中是按照年龄降序排列，如果年龄相同则按身高升序排序\n 聚合函数聚合函数实际上就是SQL中内置的一些函数，例如计数函数 count、最值函数 max min、求和函数 sum、均值函数 avg 等。 要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是聚合函数名。通常我们会给聚合函数起一个别名，便于处理结果。\ncount(*) 表示所有记录个数\r注意，MAX() 和 MIN() 函数并不限于数值类型。\r如果是字符类型，MAX()和 MIN() 会返回排序最后和排序最前的字符。\r如果聚合查询的 WHERE 条件没有匹配到任何行，COUNT()会返回 0，而 SUM()、AVG()、MAX()和 MIN()会返回 NULL\r $\\color{blue}{例子}$\nCOUNT\nMAX MIN\nSUM\nAVG\n 均值得出的结果由于数据的不同，可能得到的位数不确定，为了固定浮点数的位数，可以使用 ROUND(M,N)来的到精确的位数。其中M为待精确浮点数，N为要保留的位数。  分组group by group by  可以按字段将查询结果分成若干组，相同字段的为一组，需要注意的是，分组的字段必须是要筛选字段的子集。筛选过程中可以添加count(*)` 来统计各分组的数据数量。\n我们对当前筛选出的数据并不满意 —— 我们仅能对要筛选的数据进行分组，却不能看到其他数据信息。例如我们想知道按性别分组后男性、女性都有哪些人，此时可以将group_concat(字段名) 添加到查询中来实现这种需求。\n 仍有一个小问题，在筛选语句中，要筛选的字段将会以表头的形式显示出来，而我们不希望表头出现例如 group_concat(name)`这类难以理解的代码出现，所以我们可以为它们起一个“好看”的别名。\n我们现在可以为数据分组了，但目前只能简单的将所有数据分成了几组，如果我们不仅要分组，还要对分组内的数据进一步的筛选呢，请观察下面的例子\n上面的例子筛选了平均身高在169cm以上的学生的年龄以及他们的名字，这里having语句为分组添加了筛选，having 作用和 where 一样，但 having 只能用于 group by\n 最后，我们还可以统计一下所有记录的总和。rollup 会在查询结果的最后添加一行来显示记录总和。\n 分页limit start, count 表中的数据如果变得很多，直接使用 select * from 表名 来查询全部数据是不明智的做法，这会让查询变得很慢。我们可以使用分页语句，只显示表中的一部分数据。分页语句的两个参数分别是：从start开始，获取count条数据。那么在每页显示 m 行数据时，第 n 页的数据可以如下表示：\nselect * from students where is_delete = 0 limit (n - 1) * m, m\r 连接join ... on 连接语句可以同时查询多张表内存在联系的数据。下面介绍三种常见的连接类型：\n  内连接 INNER JOIN查询的结果为两个表的交集   外连接-右 RIGHT [OUTER] JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。   外连接-左 LEFT [OUTER] JOIN返回左表都存在的行。如果某一行仅在左表存在，那么结果集就会以NULL填充剩下的字段。   外连接-全 FULL [OUTER] JOIN把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL。    目前我们已经建立了学生表和班级表，虽然学生表中只存储了班级ID，但使用join可以连接到班级表，通过各自对应的班级ID，我们可以得到每个学生的所属班级。\n$\\color{blue}{例子}$\n-- 内连接\rselect * from students s inner join classes c on s.cl_s = c.id\r-- 右连接\rselect * from students s right join classes c on s.cl_s = c.id\r -- 左连接\rselect * from students s left join classes c on s.cl_s = c.id\r 子查询将查询的结果当作当前查询的数据，这种操作称作子查询。子查询是嵌入到主查询中，是可以独立存在的语句,是一条完整的 select 语句。\n子查询有三种不同的类型：\n 标量子查询 子查询返回的结果是一个数据 -- 查询班级学生的平均身高\rselect * from students where age \u0026gt; (select avg(age) from students);\r 列子查询 子查询返回的结果是一列字段 -- 查询还有学生在班的所有班级名字\rselect name from classes where id in (select cls_id from students);\r 行子查询 子查询返回的结果是一行记录 -- 查找班级年龄最大,身高最高的学生\rselect * from students where (height,age) = (select max(height),max(age) from students);\r   自关联将表自身当作连接的对象，在为数据建表时可以节省不必要的开销。具体请看下面在实际会出现的一种情况：\n假设我们目前要建立一张行政地域信息表，最直观的想法是为省级和直辖市建立一张表，再建一张表来存市级信息。如果这个信息表刻度再小一些 —— 精确到乡镇。那么可能会多很多张表，并多很多的连接，一张连一张，非常复杂。 有没有更简便的方法来存数据呢？\n观察发现每张表都是存储ID、地名、与下一级连接用的ID组成，既然每张表的结构都是一样的，我们可以将它们都写进一张表中。表的结构如下，在表中，使用pid字段表示当前地域的父级地域的aid。例如省份、直辖市没有父级地域，则pid为NULL。\n接下来我们尝试连接自身，写个简单的查询语句 ","id":33,"section":"posts","summary":"消除重复字段 distinct select distinct 字段名 from 表名; 比较运算符，例如\u0026gt; 、\u0026lt; 、\u0026gt;= 、\u0026lt;= 、= 、!= or \u0026lt;\u0026gt; ，逻辑运算符，例如and、or、no","tags":["mysql"],"title":"MySQL查询进阶","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/04/database%E6%9F%A5%E8%AF%A2%E8%BF%9B%E9%98%B6/","year":"2019"},{"content":"视图  之前学习了子查询，可以将一组查询的结果当作当前查询的条件来使用。但当查询语句变得更加复杂，继续使用嵌套查询就会让语句臃肿不堪；再或者联表查询时，相关联的表因需求发生了改变，之前的查询语句如果不加修改就会出错。\n有一个解决上述问题的办法出现了，就是视图。通俗的讲，视图就是一条SELECT语句执行后返回的结果集，是对若干张基本表的引用，一张虚表，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）。\n视图的优点就是方便操作，特别是查询操作，减少复杂的SQL语句，增强可读性。\n接下来我们创建一个视图。\n-- create view v_视图名 as select语句\r-- 视图名要以 v_ 开头，以便识别\rcreate view v_order as select order_id, name from orders;\r 视图是一张虚表，是以创建视图时的select语句为映射的表，这张表是实实在在存在于库中的，所以使用show tables 语句查看库中所有表单时，也会看到视图。我们在命名时使用了_v开头，这时候就很好区分哪些是视图，哪些是表。\n我们拥有了视图，就可以用视图来进行查询了。视图替代了冗长的查询语句，同时因为视图时其原表的映射，所以原表修改后视图也会显示修改后的数据。\n如果不想保留当前视图，可以将视图删除。类似于表的删除，键入如下语句：\ndrop view 视图名;\r视图的作用 - 总结  提高了重用性，就像一个函数 对数据库重构，却不影响程序的运行 提高了安全性能，可以对不同的用户 让数据更加清晰   事务  数据操作有时候存在这样一种情况：几张表间的数据需要同时进行操作，若有某张表操作失败，则认定整个操作都是失败的。举个栗子\n A用户和B用户是银行的储户，现在A要给B转账500元，那么需要做以下几件事：\n 检查A的账户余额\u0026gt;500元； A 账户中扣除500元; B 账户中增加500元;   交♂易就是一种必须双方操作都成功才算成功的例子，没人希望自己的钱莫名消失。\n事务可以为我们“打包”一组操作，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。\n事务的特性  原子性 (Atomicity)    一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性\n   一致性 (Consistency)  在前面的例子中，一致性确保了，即使在执行第三、四条语句之间时系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中\n   隔离性 (Isolation)  通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的\n   持久性 (Durability)  一旦事务提交，则其所做的修改会永久保存到数据库\n    注意 表的引擎类型必须是 InnoDB 类型才可以使用事务，这是mysql表的默认引擎。 查看表的创建语句 show create table 表名 来查看当前表的引擎 事务流程 -- 开启事务\rbegin; 或 start transaction;\r-- 开启事务后执行修改命令，变更会维护到本地缓存中，而不维护到物理表中\r\r-- 执行操作\rselect balance from checking where customer_id = 10233276;\rupdate checking set balance = balance - 200.00 where customer_id = 10233276;\rupdate savings set balance = balance + 200.00 where customer_id = 10233276;\r-- 提交事务\rcommit; -- 将缓存中的数据变更维护到物理表中\r-- 在提交前是看不到修改的数据的\r\r-- 回滚\rrollback; -- 放弃缓存中变更的数据\r 索引  可以将索引理解为给字段添加了一个目录，之后查询此字段时因为有目录，查询速度会变得很快。\n但建立目录就会增大空间的开销，每次更新数据的同时也要更新目录，所以建立太多的索引，尤其在经常进行修改的字段上建立索引反而会降低速度。 索引的建立 create index 索引名 on 表名(字段名(长度)) -- 如果指定字段是字符串，需要指定长度，建议长度与定义字段时的长度一致\r-- 字段类型如果不是字符串，可以不填写长度部分\r 查询索引 show index from 表名;\r 删除索引 drop index 索引名称 on 表名;\r 索引的使用 和普通的查询并无差别，只是有了索引后，底层实现查询的方法发生了改变，所以才会变快。\n","id":34,"section":"posts","summary":"视图 之前学习了子查询，可以将一组查询的结果当作当前查询的条件来使用。但当查询语句变得更加复杂，继续使用嵌套查询就会让语句臃肿不堪；再或者联表","tags":["mysql","视图","索引"],"title":"MySQL视图、索引","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/04/database%E8%BF%9B%E9%98%B6/","year":"2019"},{"content":"数据表  查看当前数据库中所有表  show tables;\r2. 查看表内字段\ndesc 表名;\r建表示例   提示：多个字段的创建间，用逗号分隔  create table classes(\rid int unsigned auto_increment primary key not null,\rname varchar(30)\r);\rcreate table students(\rid int unsigned primary key auto_increment not null,\rname varchar(30) not null,\rage int unsigned not null,\rheight decimal(5,2),\rgender enum(\u0026#39;male\u0026#39;,\u0026#39;female\u0026#39;,\u0026#39;private\u0026#39;) default \u0026#39;private\u0026#39;,\rcls_id int unsigned\r);\r添加字段  alter table 表名 add 列名 类型;\r5. 修改字段-重命名\nalter table 表名 change 原名 新名 类型及约束;\r//注意：类型是必须写的，不可以直接写约束和默认值\r6. 修改字段-不重命名\nalter table 表名 modify 列名 类型及约束;\r//注意：类型是必须写的，不可以直接写约束和默认值\r删除字段  alter table 表名 drop 列名;\r查看创建表的语句  show create table 表名;\r删除表  drop table 表名;\r","id":35,"section":"posts","summary":"数据表 查看当前数据库中所有表 show tables; 2. 查看表内字段 desc 表名; 建表示例 提示：多个字段的创建间，用逗号分隔 create table classes( id int unsigned auto_increment primary key not null, name varchar(30) ); create table students( id int unsigned primary key","tags":["mysql"],"title":"MySQL表操作","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/04/database%E8%A1%A8%E6%93%8D%E4%BD%9C/","year":"2019"},{"content":"数据库安装  在Linux终端输入如下指令 sudo apt-get install mysql-server\rsudo apt-get install mysql-client\rsudo apt-get install libmysqlclient-dev\r 启动服务： sudo service myssql start 查看进程中的MySQL服务: ps ajx|grep mysql 停止服务： sudo service mysql stop 重启服务： sudo service mysql restart 查看数据库版本：select version() 查看当前时间：select now()  常见参数 配置文件路径 /etc/mysql/mysql.conf.d/mysql.cnf\n bind-address: 127.0.0.1-default port: 3306-default datadir(mysql存放路径): /var/lib/mysql  在终端操作数据库   连接   mysql -u 用户名 -p\r如果一切正确，就会连接到MySQL服务器，同时提示符变为 mysql\u0026gt;   退出   quit 或者 exit\r快捷键 crtl + d 也可以退出登录。注意，MySQL服务器仍在后台运行   修改数据库密码   sudo mysqladmin -u 用户名 -p password\rsudo service mysql restart\r   忘记密码   1. 进入/etc/mysql/目录，并用root权限打开debian.cnf文件\rcd /etc/mysql\rsudo gedit debian.cnf\r2. 进入mysql\rmysql -u 用户名 -p\r然后输入文件中的password值，即可进入mysql\r3. 选择mysql数据库（用户名和密码均存储在此数据库的user表中）\ruse mysql;\r4. 显示user表中的列\rshow fields from user;\rauthentication_string这列就是密码\r5. 修改密码\rupdate mysql.user set authentication_string=password(\u0026#39;123456\u0026#39;) where user=\u0026#39;root\u0026#39;\r6. 退出\rexit\r7. 重启mysql\rservice mysql restart\r   查看所有数据库   show databases;\r注意 数据库操作语句结尾要写分号   使用数据库   use 数据库名;\r  创建数据库   creat database 数据库名 charset=utf8;\r  删除数据库   drop database 数据库名;\r 卸载数据库 #sudo apt-get autoremove --purge mysql-server-5.7 sudo apt-get remove mysql-server #sudo apt-get autoremove mysql-server sudo apt-get remove mysql-common\rsudo rm -rf /etc/mysql/ /var/lib/mysql #很重要\r#清理残留数据\rdpkg -l |grep ^rc|awk \u0026#39;{print $2}\u0026#39; |sudo xargs dpkg -P sudo apt autoremove\rsudo apt autoreclean\r","id":36,"section":"posts","summary":"数据库安装 在Linux终端输入如下指令 sudo apt-get install mysql-server sudo apt-get install mysql-client sudo apt-get install libmysqlclient-dev 启动服务： sudo service myssql start 查看进程中的MySQL服务: ps ajx|grep mysql 停止服务： sudo service mysql stop 重启服务","tags":["mysql","安装"],"title":"MySQL安装","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/04/database%E5%AE%89%E8%A3%85%E5%BA%93%E6%93%8D%E4%BD%9C/","year":"2019"},{"content":"生成随机字符串 import os\rimport base64\rimport random\rimport time\rimport hashlib\r# 方法一\r tmp = os.urandom(44)\rsecret_key = base64.b64encode(tmp)\rprint(secret_key)\r# 方法二\r def get_random_secret_key(length=12, allowed_chars=None, secret_key=None):\r\u0026#34;\u0026#34;\u0026#34;生成随机字符串\r:param length: 随机字符串长度\r:param allowed_chars: 随机字符串字符取值范围\r:param secret_key: 生成随机字符串的随机字符串\r:return:\r\u0026#34;\u0026#34;\u0026#34;\rif secret_key is None:\rsecret_key = \u0026#34;n\u0026amp;^-9#k*-6pwzsjt-qsc@s3$l46k(7e%f80e7gx^f#vouf3yvz\u0026#34;\rif allowed_chars is None:\rallowed_chars = \u0026#39;abcdefghijklmnopqrstuvwxyz0123456789!@#$%^\u0026amp;*(-_=+)\u0026#39;\rrandom.seed(\rhashlib.sha256(\r(\u0026#34;%s%s%s\u0026#34; % (\rrandom.getstate(),\rtime.time(),\rsecret_key)).encode(\u0026#39;utf-8\u0026#39;)\r).digest())\rret = \u0026#39;\u0026#39;.join(random.choice(allowed_chars) for i in range(length))\rreturn ret\r","id":37,"section":"posts","summary":"生成随机字符串 import os import base64 import random import time import hashlib # 方法一 tmp = os.urandom(44) secret_key = base64.b64encode(tmp) print(secret_key) # 方法二 def get_random_secret_key(length=12, allowed_chars=None, secret_key=None): \u0026#34;\u0026#34;\u0026#34;生成随机字符串 :param length: 随机字符串长度 :param allowed_chars: 随","tags":["python","random"],"title":" 生成随机字符串","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/03/%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/","year":"2019"},{"content":"一、课程介绍 1. 内容简介 OAuth 2.0 是时下最流行的授权认证方式，其典型的应用有第三方账号登录，获取认证开发第三方应用等。本课程的前半段主要讲解 OAuth 2.0 授权的原理。后半段则会基于 Flask 与 Github 授权接口实现一个第三方留言本应用。\n2. 课程知识点 本课程项目完成过程中，我们将学习：\n OAuth 2.0 授权认证的流程 OAuth 2.0 授权代码的编写 基于 flask + mongodb 实现一个简单的第三方留言本应用  3. 效果图 清空缓存后尝试发布一条新留言：\n点击发表后跳转到授权页：\n授权页的图其实是应用的 logo，没有设置应用 logo 的话就会使用应用作者的头像。\n发表后：\n我用另一个账号发表了一条留言。\n二、实验环境 打开终端，进入 Code 目录，创建 oauth2.0 文件夹, 并将其作为我们的工作目录。\n三、OAuth 2.0 授权原理  什么是 OAuth 2.0  OAuth 2.0 目前广泛使用的授权认证协议，它使得第三方应用能够在不必得到用户账号密码的情况下通过申请授权（也就是取得用户和服务商的同意）来访问到用户的私人资源。当第三方应用申请授权成功时，它会得到一个访问资源用的 token（以下简称访问 token），之后便可使用访问 token 来获取资源了。\n OAuth 2.0 有四种授权类型：   授权码授权（适用于 Web 应用） 隐式授权 （适用于移动应用） 用户密码授权 （不推荐使用） 客户端授权 (适用于后端应用)  接下来从简单到复杂依次讲解这四种授权类型。\n3.1 客户端授权 客户端授权类型是四种授权类型里流程最简单的。因为这种类型的目的并不是为了获取用户的私人资源，而是客户端自身希望通过授权得到访问 token 来访问服务提供者提供的服务接口。\n认证流程如下图（参考：https://tools.ietf.org/html/rfc6749#section-4.4 ）：\n 客户端发送授权用的凭证给执行授权的服务器 授权服务器返回访问 token 给客户端  授权认证所需的凭证一般就是一个 client_id 和一个 client_key，你在服务提供者（各类开放平台）那里申请创建应用时就会得到，它提供给你的 id 和 key 也可能会叫 API Key，Secret Key 等，这就需要你阅读该平台的文档进行确认了。\n3.2 用户密码授权 用户密码授权类型需要用户提供账号密码给第三方应用。这种方式过于邪恶所以不推荐使用。\n认证流程如下图（参考：https://tools.ietf.org/html/rfc6749#section-4.3 ）：\n 客户端从用户那里得到用户名和用户密码 客户端发送授权用的凭证给授权服务器 授权服务器返回访问 token 给客户端  这种方式下的认证凭证就是用户名与用户密码。\n3.3 隐式授权 隐式授权可以理解为简化版的授权码授权，它通过浏览器将用户导向授权页面，用户授权后就会重定向到你指定的页面 URI。授权服务器会在重定向的 URI 的最后接上一个包含了访问 token 的 fragment，fragment 举个例子就是 http://www.example.org/foo.html#bar 里的 #bar，最后你通过重定向后的页面里的 js 脚本拿到这个 token 再传给应用客户端。\n认证流程如下图（参考：https://tools.ietf.org/html/rfc6749#section-4.2 ）：\n（User-Agent 大多指浏览器，Client 指应用客户端）\n（这里需要说明一下：一般我们说后台是服务器，浏览器是客户端。但是实际上应该这么理解：享受服务的那一方叫客户端，提供服务的那一方叫服务端）\n 应用客户端通过浏览器将用户导向授权页面 用户授权 授权服务器返回重定向 URI，并在 URI 上携带访问 token 浏览器访问重定向 URI（不包含访问 token，但实际上 token 已经保存在浏览器本地了） 通过页面的 js 脚本获取访问 token 将访问 token 传给应用客户端  3.4 授权码授权 授权码授权需要先获得授权码再获取访问 token。\n认证流程如下图（参考：https://tools.ietf.org/html/rfc6749#section-4.1 ）：\n 应用客户端通过浏览器将用户导向授权页面 用户授权 授权服务器返回授权码 应用客户端使用授权码作为授权凭证，重定向 URI 作为辅助验证向授权服务器请求访问 token 授权服务器返回访问 token （可能附带刷新 token）给应用客户端  访问 token 的使用一般都有时间限制，刷新 token 可用来获取新的访问 token（不需要用户再次授权）。\n到目前为止还没有提到认证过程中的那些 http 报文要如何构造。没有提是怕导致阅读时不连贯，容易打断思路。而且虽然协议是规定好的，但是各大网站对协议的实现都是有差异的，有兴趣的同学可以参考这篇博文：各大網站 OAuth 2.0 實作差異。所以具体还是要通过阅读别人家的文档才知道报文该如何构造。在实战部分，笔者会带大家阅读 Github 的 API 文档，通过这种方式来学习 OAuth 2.0 中报文的构造。\n四、项目实战  项目架构  因为本项目主要是为了新手快速上手 OAuth 2.0 授权用的，为了避免其它的学习成本，选用的都是简单易用的数据库和 Python 库，这些我都会给出文档地址。不过不阅读文档也不影响实验进行，因为它们的代码都属于你看一眼就知道是在做什么的。\n后台数据库用 Mongodb，不用手动创建数据库，NoSQL，操作 Mongodb 就跟操作词典一样简单。\n使用的 Python 库如下：\n  flask ：轻量级 Python 框架，如果没学过它，还是建议通过 Flask - 快速上手 快速入门一下。 flask_pymongo：flask 下操作 mongodb 数据库的库，官方文档 requests_oauthlib：一个对人类友好的 oauth 库，官方文档    项目环境  首先下载项目需要的资料包：\n$ wget http://labfile.oss.aliyuncs.com/courses/644/material.zip\r$ unzip material.zip\r$ rm -rf material.zip __MACOSX\r资料包的内容如下：\n.\r├── requirements.txt\r├── ssl.crt\r├── ssl.key\r├── static\r│ ├── css\r│ │ └── style.css\r│ └── image\r│ └── bg2.jpg\r└── templates\r└── index.html\r static 与 templates 是关于网页模板的文件，这里直接给出。 ssl.crt 与 ssl.key 是为了使用 https 协议所需要的文件，你也可以自己生成。参考这个网址： http://werkzeug.pocoo.org requrements.txt 包含了所需要安装的库。  安装 mongodb：\n$ sudo apt-get install mongodb\r项目代码是 python2 与 python3 通用的，同学可以根据自己的喜好来搭建环境：\nPython2：\n$ sudo pip install virtualenv\r$ virtualenv venv\r$ source venv/bin/activate\r$ pip install -r requirements.txt\rPython3：\n$ sudo pip3 install virtualenv\r$ virtualenv -p python3 venv3\r$ source venv3/bin/activate\r$ pip3 install -r requirements.txt\r4.1 Github Oauth 2.0 接口 下面我们通过实现一个 web 应用来加深对 OAuth 2.0 协议的理解，授权方式为授权码授权。\n首先在 Github 上申请一个新的应用，地址：https://github.com/settings/applications/new\n注意主页 URL 和 Callback URL 需指明使用 https 协议，因为 Oauth2 是工作在 SSL 层上的，这样才能保证传输的安全性。当然直接使用 http 协议也是可以的，这里我们还是用 https。\n查看客户端 id 与 secret, 这里的 Client ID 和 Client Secret 在 4.2 节会用到。\n接着阅读这部分文档：Authorizing OAuth Apps\n下面对文档稍作翻译。\n4.1.1 重定向用户到 Github 授权页面 对授权页面做出的请求如下：\nGET https://github.com/login/oauth/authorize\r列出参数：\n client_id（必选）：客户端 ID，可在 应用页面 访问查看 redirect_uri：重定向 url，该地址必须在 callback_url 的子目录下 scope：scope 用来指定你要获取哪些权限。如果为空则只能读取用户的一些公开信息，详见 Scopes state：防止 CSRF 攻击用的随机字符串 allow_signup：认证过程中允许用户注册 Github，默认为 true  其中只有 client_id 是必选的。\n根据以上的信息构造的 GET 请求的访问地址可能长这个样子：\nhttps://github.com/login/oauth/authorize?\rclient_id=...\u0026amp;\rscope=user%20public_repo\r获取的权限是读写用户信息与读写公开仓库的能力。\n4.1.2 重定向回你的网页 当授权页面重定向回你的应用页面时，重定向的 URL 后面会接上授权码参数，大概长这样：\nhttps:// 你的重定向 url?code = 你的一串授权码 \u0026amp; state = 防止 CSRF 攻击的随机字串\r有了授权码就能够申请获取 访问 token 了。\n对 访问 token 发放页面做出请求：\nPOST https://github.com/login/oauth/access_token\r列出参数：\n client_id（必选）：客户端 id，可在 应用页面 访问查看 client_secret（必选）：客户端 secret，可在 应用页面 访问查看 code（必选）：授权码 redirect_uri：需与之前的重定向 url 一致 state：防止 CSRF 攻击用的随机字符串  响应默认是以下形式：\naccess_token=e72e16c7e42f292c6912e7710c838347ae178b4a\u0026amp;scope=user%2Cgist\u0026amp;token_type=bearer\r你也可以在报文头部指定想要的响应形式：\nAccept: application/json\r{\u0026quot;access_token\u0026quot;:\u0026quot;e72e16c7e42f292c6912e7710c838347ae178b4a\u0026quot;, \u0026quot;scope\u0026quot;:\u0026quot;repo,gist\u0026quot;, \u0026quot;token_type\u0026quot;:\u0026quot;bearer\u0026quot;}\rAccept: application/xml\r\u0026lt;OAuth\u0026gt;\r\u0026lt;token_type\u0026gt;bearer\u0026lt;/token_type\u0026gt;\r\u0026lt;scope\u0026gt;repo,gist\u0026lt;/scope\u0026gt;\r\u0026lt;access_token\u0026gt;e72e16c7e42f292c6912e7710c838347ae178b4a\u0026lt;/access_token\u0026gt;\r\u0026lt;/OAuth\u0026gt;\r4.1.3 使用访问 token 访问 API 你可以将访问 token 用在 URL 参数上：\nGET https://api.github.com/user?access_token=...\r不过更推荐你在报文头部存放 token：\nAuthorization: 访问 token OAUTH-TOKEN\r4.2 项目实现 在工作目录下创建 app.py 文件，我会先给出它的代码再一一讲解。（事实上，这部分就是项目的全部代码了）\n#-*- coding:utf-8 -*-\r from flask import Flask, request, session, redirect, url_for, render_template\rfrom flask_pymongo import PyMongo\rfrom requests_oauthlib import OAuth2Session\rimport datetime, time\rimport os\rapp = Flask(__name__)\rmongo = PyMongo(app)\rapp.config[\u0026#34;MONGO_HOST\u0026#34;] = \u0026#34;127.0.0.1\u0026#34;\rapp.config[\u0026#34;MONGO_PORT\u0026#34;] = 27017\rapp.config[\u0026#34;MONGO_DBNAME\u0026#34;] = \u0026#34;github_cafe\u0026#34;\rclient_id = \u0026#34;替换成在 4.1 节中你申请的应用的 Client ID\u0026#34;\rclient_secret = \u0026#34;替换成在 4.1 节中你申请的应用的 Client Secret\u0026#34;\rauthorization_base_url = \u0026#34;https://github.com/login/oauth/authorize\u0026#34;\rtoken_url = \u0026#34;https://github.com/login/oauth/access_token\u0026#34;\r@app.route(\u0026#39;/\u0026#39;, methods=[\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;])\r@app.route(\u0026#39;/page/\u0026lt;int:page\u0026gt;\u0026#39;, methods=[\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;])\rdef index(page = 1):\rif request.method == \u0026#34;POST\u0026#34;:\rsession[\u0026#34;geek_wisdom\u0026#34;] = request.form[\u0026#34;geek_wisdom\u0026#34;]\rtry:\rgithuber_say()\rexcept:\rgithub = OAuth2Session(client_id)\rauthorization_url, state = github.authorization_url(authorization_base_url)\rsession[\u0026#34;oauth_state\u0026#34;] = state\rreturn redirect(authorization_url)\rwisdom_list = get_githuber_wisdom(page=page)\rreturn render_template(\u0026#34;index.html\u0026#34;, wisdom_list=wisdom_list, page=page, page_count=get_page_count())\r@app.route(\u0026#39;/callback\u0026#39;, methods=[\u0026#34;GET\u0026#34;])\rdef callback():\rgithub = OAuth2Session(client_id, state=session[\u0026#39;oauth_state\u0026#39;])\rtoken = github.fetch_token(token_url, client_secret=client_secret,\rauthorization_response=request.url)\rsession[\u0026#39;oauth_token\u0026#39;] = token\rgithuber_say()\rreturn redirect(url_for(\u0026#34;index\u0026#34;))\rdef githuber_say():\rgithub = OAuth2Session(client_id, token=session[\u0026#39;oauth_token\u0026#39;])\rprofile = github.get(\u0026#39;https://api.github.com/user\u0026#39;).json()\rwisdom_dict = {\r\u0026#34;username\u0026#34;: profile[\u0026#34;name\u0026#34;],\r\u0026#34;avatar_url\u0026#34;: profile[\u0026#34;avatar_url\u0026#34;],\r\u0026#34;html_url\u0026#34;: profile[\u0026#34;html_url\u0026#34;],\r\u0026#34;geek_wisdom\u0026#34;: session[\u0026#34;geek_wisdom\u0026#34;],\r\u0026#34;datetime\u0026#34; : datetime.datetime.today().strftime(\u0026#34;%Y/%-m/%d%H:%M\u0026#34;),\r\u0026#34;timestamp\u0026#34; : time.time()\r}\rdel session[\u0026#34;geek_wisdom\u0026#34;]\rmongo.db.wisdom.insert(wisdom_dict)\rdef get_githuber_wisdom(count=10, page=1):\rreturn mongo.db.wisdom.find({}).sort([(\u0026#39;timestamp\u0026#39;, -1)]).skip(count * (page-1)).limit(count)\rdef get_page_count(count=10):\r# python2 请将 // 改成 /\r return mongo.db.wisdom.find({}).count() // count + 1\rif __name__ == \u0026#39;__main__\u0026#39;:\rapp.secret_key = os.urandom(24)\rapp.run(debug=True, ssl_context=(\u0026#34;ssl.crt\u0026#34;, \u0026#34;ssl.key\u0026#34;), threaded=True)\r flask 应用的配置和一些常量信息：  app = Flask(__name__)\rmongo = PyMongo(app)\r# mongodb 做完这些配置即可，不用手动连接\r app.config[\u0026#34;MONGO_HOST\u0026#34;] = \u0026#34;127.0.0.1\u0026#34;\rapp.config[\u0026#34;MONGO_PORT\u0026#34;] = 27017\r# 数据库名可随意取，它会自动创建\r app.config[\u0026#34;MONGO_DBNAME\u0026#34;] = \u0026#34;github_cafe\u0026#34;\rclient_id = \u0026#34;替换成在 4.1 节中你申请的应用的 Client ID\u0026#34;\rclient_secret = \u0026#34;替换成在 4.1 节中你申请的应用的 Client Secret\u0026#34;\r# 授权页面的地址\r authorization_base_url = \u0026#34;https://github.com/login/oauth/authorize\u0026#34;\r# 分发访问 token 的地址\r token_url = \u0026#34;https://github.com/login/oauth/access_token\u0026#34;\r 首页的表单如图所示，输入框的 name 值是 geek_wisdom ：   首页的代码逻辑：  @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;])\r@app.route(\u0026#39;/page/\u0026lt;int:page\u0026gt;\u0026#39;, methods=[\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;])\rdef index(page = 1):\rif request.method == \u0026#34;POST\u0026#34;:\r# 获取表单数据，这里由于之后要重定向，先在 session 里暂存一下。\r session[\u0026#34;geek_wisdom\u0026#34;] = request.form[\u0026#34;geek_wisdom\u0026#34;]\rtry:\r# 这一步会尝试直接获取授权资源完成留言提交，如果失败就进入授权步骤\r githuber_say()\rexcept:\r# ... 构造带了参数的授权页面地址 ...\r # ... 这部分在之后说 ...\r return redirect(authorization_url)\r# 从数据库取得 githuber 的留言\r wisdom_list = get_githuber_wisdom(page=page)\rreturn render_template(\u0026#34;index.html\u0026#34;, wisdom_list=wisdom_list, page=page, page_count=get_page_count())\r 构造带了参数的授权页面地址：  github = OAuth2Session(client_id)\rauthorization_url, state = github.authorization_url(authorization_base_url)\rsession[\u0026#34;oauth_state\u0026#34;] = state\r从之前阅读文档我们知道这步只有 client_id 是必选项，我们的留言本应用只需要读用户的基本信息即可，因此用不到 scope，如果需要，在 OAuth2Session 里带上 scope 参数就可以了。\nauthorization_url 函数会帮我们构造带了参数的 url，同时会带上 state 参数，保存该参数用于防止 CSRF 攻击。\n 回调页面的逻辑：  @app.route(\u0026#39;/callback\u0026#39;, methods=[\u0026#34;GET\u0026#34;])\rdef callback():\rgithub = OAuth2Session(client_id, state=session[\u0026#39;oauth_state\u0026#39;])\r# 得到访问 token\r token = github.fetch_token(token_url, client_secret=client_secret,\rauthorization_response=request.url)\rsession[\u0026#39;oauth_token\u0026#39;] = token\r# 访问授权资源，完成一次留言的提交\r githuber_say()\r# 重定向回主页\r return redirect(url_for(\u0026#34;index\u0026#34;))\r授权码就在重定向的地址之中。\n获取访问 token 的这一步只需要 client_id，client_secret，state 和 授权码信息即可。requests_oauthlib 默认返回的响应格式是 json 格式，不过它都帮我们封装好了，我们直接就能拿到访问 token。\n githuber_say() 的实现  def githuber_say():\rgithub = OAuth2Session(client_id, token=session[\u0026#39;oauth_token\u0026#39;])\r# 获取用户个人信息\r profile = github.get(\u0026#39;https://api.github.com/user\u0026#39;).json()\r# 一条留言所需要的信息数据\r wisdom_dict = {\r\u0026#34;username\u0026#34;: profile[\u0026#34;name\u0026#34;],\r\u0026#34;avatar_url\u0026#34;: profile[\u0026#34;avatar_url\u0026#34;],\r\u0026#34;html_url\u0026#34;: profile[\u0026#34;html_url\u0026#34;],\r\u0026#34;geek_wisdom\u0026#34;: session[\u0026#34;geek_wisdom\u0026#34;],\r\u0026#34;datetime\u0026#34; : datetime.datetime.today().strftime(\u0026#34;%Y/%-m/%d%H:%M\u0026#34;),\r\u0026#34;timestamp\u0026#34; : time.time()\r}\rdel session[\u0026#34;geek_wisdom\u0026#34;]\r# 数据库插入一条留言数据\r mongo.db.wisdom.insert(wisdom_dict)\r关于有哪些接口可使用，都是什么功能，参考：https://developer.github.com/v3/users/ 右边一列。\nmongo.db 是配置的数据库，mongo.db.wisdom 是数据库下的一个集合（很像 SQL 数据库里的表），集合的名字任取（在这里是 wisdom ），当你对集合做插入操作时会自动在数据库中创建该集合。\n最后应用运行的参数需指定 ssl_context，这样应用就能 ssl 层上通信了。\nif __name__ == \u0026#39;__main__\u0026#39;:\rapp.secret_key = os.urandom(24)\rapp.run(debug=True, ssl_context=(\u0026#34;ssl.crt\u0026#34;, \u0026#34;ssl.key\u0026#34;), threaded=True)\r4.3 运行结果 新开一个标签页启动 mongodb：\n$ mkdir db\r$ mongod --dbpath ./db\r运行 flask 应用（请确保在 virtualenv 的虚拟环境下）：\n(venv)$ python app.py\r此时可以用浏览器访问 https://127.0.0.1:5000 （一定要加上 https 协议头）, 显示连接不安全，这时只要添加例外即可：\n应用首页：\n清空缓存后尝试发布一条新留言：\n点击发表后跳转到授权页：\n授权页的图其实是应用的 logo，没有设置应用 logo 的话就会使用应用作者的头像。\n发表后：\n我用另一个账号发表了一条留言。\n五、总结 在本课程中，我们学习了 OAuth 2.0 的四种授权流程，实现了一个简单的第三方应用，但还是有部分内容没有讲到，比如刷新 token 的使用，这一部分可参考 协议 或是 requests-oauthlib 官方文档中的内容 。\n在实际操作中，如何授权还是以服务提供者提供的文档为准。\n","id":38,"section":"posts","summary":"一、课程介绍 1. 内容简介 OAuth 2.0 是时下最流行的授权认证方式，其典型的应用有第三方账号登录，获取认证开发第三方应用等。本课程的前半段主要讲解 OAuth 2.0 授权","tags":["OAuth","flask"],"title":"OAuth 2.0 授权原理","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/03/oauth-2.0-%E6%8E%88%E6%9D%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/","year":"2019"},{"content":"Django模型中字段属性choice使用 choice接收一个元组（保证值不可变），同理每一个选项也是由一个元组（value,display_name）构成。显而易见，display_name就是要在页面中展示的\nfrom django.db import models\rclass Person(models.Model):\rSHIRT_SIZES = (\r(\u0026#39;S\u0026#39;, \u0026#39;Small\u0026#39;),\r(\u0026#39;M\u0026#39;, \u0026#39;Medium\u0026#39;),\r(\u0026#39;L\u0026#39;, \u0026#39;Large\u0026#39;),\r)\rname = models.CharField(max_length=60)\rshirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES) // 和SHIRT_SIZES元组的第一个元素的类型一致\r\u0026gt;\u0026gt;\u0026gt; p = Person(name=\u0026#34;Fred Flintstone\u0026#34;, shirt_size=\u0026#34;L\u0026#34;)\r\u0026gt;\u0026gt;\u0026gt; p.save()\r\u0026gt;\u0026gt;\u0026gt; p.shirt_size\r\u0026#39;L\u0026#39;\r\u0026gt;\u0026gt;\u0026gt; p.get_shirt_size_display()\r\u0026#39;Large\u0026#39;\r","id":39,"section":"posts","summary":"Django模型中字段属性choice使用 choice接收一个元组（保证值不可变），同理每一个选项也是由一个元组（value,display","tags":["django"],"title":"Django模型中字段属性choice使用","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/01/django%E6%A8%A1%E5%9E%8B%E4%B8%AD%E5%AD%97%E6%AE%B5%E5%B1%9E%E6%80%A7choice%E4%BD%BF%E7%94%A8/","year":"2019"},{"content":"字段 AutoField(Field)\r- int自增列，必须填入参数 primary_key=True\rBigAutoField(AutoField)\r- bigint自增列，必须填入参数 primary_key=True\r注：当model中如果没有自增列，则自动会创建一个列名为id的列\rfrom django.db import models\rclass UserInfo(models.Model):\r# 自动创建一个列名为id的且为自增的整数列\r username = models.CharField(max_length=32)\rclass Group(models.Model):\r# 自定义自增列\r nid = models.AutoField(primary_key=True)\rname = models.CharField(max_length=32)\rSmallIntegerField(IntegerField):\r- 小整数 -32768 ～ 32767\rPositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField)\r- 正小整数 0 ～ 32767\rIntegerField(Field)\r- 整数列(有符号的) -2147483648 ～ 2147483647\rPositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField)\r- 正整数 0 ～ 2147483647\rBigIntegerField(IntegerField):\r- 长整型(有符号的) -9223372036854775808 ～ 9223372036854775807\rBooleanField(Field)\r- 布尔值类型\rNullBooleanField(Field):\r- 可以为空的布尔值\rCharField(Field)\r- 字符类型\r- 必须提供max_length参数， max_length表示字符长度\rTextField(Field)\r- 文本类型\rEmailField(CharField)：\r- 字符串类型，Django Admin以及ModelForm中提供验证机制\rIPAddressField(Field)\r- 字符串类型，Django Admin以及ModelForm中提供验证 IPV4 机制\rGenericIPAddressField(Field)\r- 字符串类型，Django Admin以及ModelForm中提供验证 Ipv4和Ipv6\r- 参数：\rprotocol，用于指定Ipv4或Ipv6， \u0026#39;both\u0026#39;,\u0026#34;ipv4\u0026#34;,\u0026#34;ipv6\u0026#34;\runpack_ipv4， 如果指定为True，则输入::ffff:192.0.2.1时候，可解析为192.0.2.1，开启此功能，需要protocol=\u0026#34;both\u0026#34;\rURLField(CharField)\r- 字符串类型，Django Admin以及ModelForm中提供验证 URL\rSlugField(CharField)\r- 字符串类型，Django Admin以及ModelForm中提供验证支持 字母、数字、下划线、连接符（减号）\rCommaSeparatedIntegerField(CharField)\r- 字符串类型，格式必须为逗号分割的数字\rUUIDField(Field)\r- 字符串类型，Django Admin以及ModelForm中提供对UUID格式的验证\rFilePathField(Field)\r- 字符串，Django Admin以及ModelForm中提供读取文件夹下文件的功能\r- 参数：\rpath, 文件夹路径\rmatch=None, 正则匹配\rrecursive=False, 递归下面的文件夹\rallow_files=True, 允许文件\rallow_folders=False, 允许文件夹\rFileField(Field)\r- 字符串，路径保存在数据库，文件上传到指定目录\r- 参数：\rupload_to = \u0026#34;\u0026#34; 上传文件的保存路径\rstorage = None 存储组件，默认django.core.files.storage.FileSystemStorage\rImageField(FileField)\r- 字符串，路径保存在数据库，文件上传到指定目录\r- 参数：\rupload_to = \u0026#34;\u0026#34; 上传文件的保存路径\rstorage = None 存储组件，默认django.core.files.storage.FileSystemStorage\rwidth_field=None, 上传图片的高度保存的数据库字段名（字符串）\rheight_field=None 上传图片的宽度保存的数据库字段名（字符串）\rDateTimeField(DateField)\r- 日期+时间格式 YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]\rDateField(DateTimeCheckMixin, Field)\r- 日期格式 YYYY-MM-DD\rTimeField(DateTimeCheckMixin, Field)\r- 时间格式 HH:MM[:ss[.uuuuuu]]\rDurationField(Field)\r- 长整数，时间间隔，数据库中按照bigint存储，ORM中获取的值为datetime.timedelta类型\rFloatField(Field)\r- 浮点型\rDecimalField(Field)\r- 10进制小数\r- 参数：\rmax_digits，小数总长度\rdecimal_places，小数位长度\rBinaryField(Field)\r- 二进制类型\r自定义字段 class UnsignedIntegerField(models.IntegerField):\rdef db_type(self, connection):\rreturn \u0026#39;integer UNSIGNED\u0026#39;\rPS: 返回值为字段在数据库中的属性，Django字段默认的值为：\r\u0026#39;AutoField\u0026#39;: \u0026#39;integer AUTO_INCREMENT\u0026#39;,\r\u0026#39;BigAutoField\u0026#39;: \u0026#39;bigint AUTO_INCREMENT\u0026#39;,\r\u0026#39;BinaryField\u0026#39;: \u0026#39;longblob\u0026#39;,\r\u0026#39;BooleanField\u0026#39;: \u0026#39;bool\u0026#39;,\r\u0026#39;CharField\u0026#39;: \u0026#39;varchar(%(max_length)s)\u0026#39;,\r\u0026#39;CommaSeparatedIntegerField\u0026#39;: \u0026#39;varchar(%(max_length)s)\u0026#39;,\r\u0026#39;DateField\u0026#39;: \u0026#39;date\u0026#39;,\r\u0026#39;DateTimeField\u0026#39;: \u0026#39;datetime\u0026#39;,\r\u0026#39;DecimalField\u0026#39;: \u0026#39;numeric(%(max_digits)s, %(decimal_places)s)\u0026#39;,\r\u0026#39;DurationField\u0026#39;: \u0026#39;bigint\u0026#39;,\r\u0026#39;FileField\u0026#39;: \u0026#39;varchar(%(max_length)s)\u0026#39;,\r\u0026#39;FilePathField\u0026#39;: \u0026#39;varchar(%(max_length)s)\u0026#39;,\r\u0026#39;FloatField\u0026#39;: \u0026#39;double precision\u0026#39;,\r\u0026#39;IntegerField\u0026#39;: \u0026#39;integer\u0026#39;,\r\u0026#39;BigIntegerField\u0026#39;: \u0026#39;bigint\u0026#39;,\r\u0026#39;IPAddressField\u0026#39;: \u0026#39;char(15)\u0026#39;,\r\u0026#39;GenericIPAddressField\u0026#39;: \u0026#39;char(39)\u0026#39;,\r\u0026#39;NullBooleanField\u0026#39;: \u0026#39;bool\u0026#39;,\r\u0026#39;OneToOneField\u0026#39;: \u0026#39;integer\u0026#39;,\r\u0026#39;PositiveIntegerField\u0026#39;: \u0026#39;integer UNSIGNED\u0026#39;,\r\u0026#39;PositiveSmallIntegerField\u0026#39;: \u0026#39;smallint UNSIGNED\u0026#39;,\r\u0026#39;SlugField\u0026#39;: \u0026#39;varchar(%(max_length)s)\u0026#39;,\r\u0026#39;SmallIntegerField\u0026#39;: \u0026#39;smallint\u0026#39;,\r\u0026#39;TextField\u0026#39;: \u0026#39;longtext\u0026#39;,\r\u0026#39;TimeField\u0026#39;: \u0026#39;time\u0026#39;,\r\u0026#39;UUIDField\u0026#39;: \u0026#39;char(32)\u0026#39;,\r栗子\nfrom django.db import models\r# Create your models here.\r class CustomeCharField(models.Field):\rdef __init__(self,max_length,*args,**kwargs):\rself.max_length = max_length\rsuper(CustomeCharField,self).__init__(max_length=max_length,*args,**kwargs)\rdef db_type(self,connection):\rreturn \u0026#39;char(%s)\u0026#39;%self.max_length\rclass MyClass(models.Model):\rid = models.AutoField(primary_key=True)\rtitle = models.CharField(max_length=32)\rcname = CustomeCharField(max_length=32)\r字段参数 null 数据库中字段是否可以为空\rdb_column 数据库中字段的列名\rdefault 数据库中字段的默认值\rprimary_key 数据库中字段是否为主键\rdb_index 数据库中字段是否可以建立索引\runique 数据库中字段是否可以建立唯一索引\runique_for_date 数据库中字段【日期】部分是否可以建立唯一索引\runique_for_month 数据库中字段【月】部分是否可以建立唯一索引\runique_for_year 数据库中字段【年】部分是否可以建立唯一索引\rverbose_name Admin中显示的字段名称\rblank Admin中是否允许用户输入为空\reditable Admin中是否可以编辑\rhelp_text Admin中该字段的提示信息\rchoices Admin中显示选择框的内容，用不变动的数据放在内存中从而避免跨表操作\r如：gf = models.IntegerField(choices=[(0, \u0026#39;何穗\u0026#39;),(1, \u0026#39;大表姐\u0026#39;),],default=1)\rerror_messages 自定义错误信息（字典类型），从而定制想要显示的错误信息；\r字典健：null, blank, invalid, invalid_choice, unique,unique_for_date\r如：{\u0026#39;null\u0026#39;: \u0026#34;不能为空.\u0026#34;, \u0026#39;invalid\u0026#39;: \u0026#39;格式错误\u0026#39;}\rvalidators 自定义错误验证（列表类型），从而定制想要的验证规则\r栗子：\rfrom django.core.validators import RegexValidator\rfrom django.core.validators import EmailValidator,URLValidator,DecimalValidator,\\\rMaxLengthValidator,MinLengthValidator,MaxValueValidator,MinValueValidator\r如：\rtest = models.CharField(\rmax_length=32,\rerror_messages={\r\u0026#39;c1\u0026#39;: \u0026#39;优先错信息1\u0026#39;,\r\u0026#39;c2\u0026#39;: \u0026#39;优先错信息2\u0026#39;,\r\u0026#39;c3\u0026#39;: \u0026#39;优先错信息3\u0026#39;,\r},\rvalidators=[\rRegexValidator(regex=\u0026#39;root_\\d+\u0026#39;, message=\u0026#39;错误了\u0026#39;, code=\u0026#39;c1\u0026#39;),\rRegexValidator(regex=\u0026#39;root_112233\\d+\u0026#39;, message=\u0026#39;又错误了\u0026#39;, code=\u0026#39;c2\u0026#39;),\rEmailValidator(message=\u0026#39;又错误了\u0026#39;, code=\u0026#39;c3\u0026#39;), ]\r)\r元信息 class UserInfo(models.Model):\rnid = models.AutoField(primary_key=True)\rusername = models.CharField(max_length=32)\rclass Meta:\r# 数据库中生成的表名称 默认 app名称 + 下划线 + 类名\r db_table = \u0026#34;table_name\u0026#34;\r# 联合索引\r index_together = [\r(\u0026#34;pub_date\u0026#34;, \u0026#34;deadline\u0026#34;),\r]\r# 联合唯一索引\r unique_together = ((\u0026#34;driver\u0026#34;, \u0026#34;restaurant\u0026#34;),)\r# admin中显示的表名称\r verbose_name\r# verbose_name加s\r verbose_name_plural\r多表关系和参数 ForeignKey(ForeignObject) # ForeignObject(RelatedField) to, # 要进行关联的表名 to_field=None, # 要关联的表中的字段名称 on_delete=None, # 当删除关联表中的数据时，当前表与其关联的行的行为 - models.CASCADE，删除关联数据，与之关联也删除 - models.DO_NOTHING，删除关联数据，引发错误IntegrityError - models.PROTECT，删除关联数据，引发错误ProtectedError - models.SET_NULL，删除关联数据，与之关联的值设置为null（前提FK字段需要设置为可空） - models.SET_DEFAULT，删除关联数据，与之关联的值设置为默认值（前提FK字段需要设置默认值） - models.SET，删除关联数据， a. 与之关联的值设置为指定值，设置：models.SET(值) b. 与之关联的值设置为可执行对象的返回值，设置：models.SET(可执行对象)\n def func():\rreturn 10\rclass MyModel(models.Model):\ruser = models.ForeignKey(\rto=\u0026quot;User\u0026quot;,\rto_field=\u0026quot;id\u0026quot;\ron_delete=models.SET(func),)\rrelated_name=None, # 反向操作时，使用的字段名，用于代替 【表名_set】 如： obj.表名_set.all()\rrelated_query_name=None, # 反向操作时，使用的连接前缀，用于替换【表名】 如： models.UserGroup.objects.filter(表名__字段名=1).values('表名__字段名')\rlimit_choices_to=None, # 在Admin或ModelForm中显示关联数据时，提供的条件：\r# 如：\r- limit_choices_to={'nid__gt': 5}\r- limit_choices_to=lambda : {'nid__gt': 5}\rfrom django.db.models import Q\r- limit_choices_to=Q(nid__gt=10)\r- limit_choices_to=Q(nid=8) | Q(nid__gt=10)\r- limit_choices_to=lambda : Q(Q(nid=8) | Q(nid__gt=10)) \u0026amp; Q(caption='root')\rdb_constraint=True # 是否在数据库中创建外键约束\rparent_link=False # 在Admin中是否显示关联数据\rOneToOneField(ForeignKey)\rto, # 要进行关联的表名\rto_field=None # 要关联的表中的字段名称\ron_delete=None, # 当删除关联表中的数据时，当前表与其关联的行的行为\r###### 对于一对一 ######\r# 1. 一对一其实就是 一对多 + 唯一索引\r# 2.当两个类之间有继承关系时，默认会创建一个一对一字段\r# 如下会在A表中额外增加一个c_ptr_id列且唯一：\rclass C(models.Model):\rnid = models.AutoField(primary_key=True)\rpart = models.CharField(max_length=12)\rclass A(C):\rid = models.AutoField(primary_key=True)\rcode = models.CharField(max_length=1)\rManyToManyField(RelatedField)\rto, # 要进行关联的表名\rrelated_name=None, # 反向操作时，使用的字段名，用于代替 【表名_set】 如： obj.表名_set.all()\rrelated_query_name=None, # 反向操作时，使用的连接前缀，用于替换【表名】 如： models.UserGroup.objects.filter(表名__字段名=1).values('表名__字段名')\rlimit_choices_to=None, # 在Admin或ModelForm中显示关联数据时，提供的条件：\r# 如：\r- limit_choices_to={'nid__gt': 5}\r- limit_choices_to=lambda : {'nid__gt': 5}\rfrom django.db.models import Q\r- limit_choices_to=Q(nid__gt=10)\r- limit_choices_to=Q(nid=8) | Q(nid__gt=10)\r- limit_choices_to=lambda : Q(Q(nid=8) | Q(nid__gt=10)) \u0026amp; Q(caption='root')\rsymmetrical=None, # 仅用于多对多自关联时，symmetrical用于指定内部是否创建反向操作的字段\r# 做如下操作时，不同的symmetrical会有不同的可选字段\rmodels.BB.objects.filter(...)\r# 可选字段有：code, id, m1\rclass BB(models.Model):\rcode = models.CharField(max_length=12)\rm1 = models.ManyToManyField('self',symmetrical=True)\r# 可选字段有: bb, code, id, m1\rclass BB(models.Model):\rcode = models.CharField(max_length=12)\rm1 = models.ManyToManyField('self',symmetrical=False)\rthrough=None, # 自定义第三张表时，使用字段用于指定关系表\rthrough_fields=None, # 自定义第三张表时，使用字段用于指定关系表中那些字段做多对多关系表\rfrom django.db import models\rclass Person(models.Model):\rname = models.CharField(max_length=50)\rclass Group(models.Model):\rname = models.CharField(max_length=128)\rmembers = models.ManyToManyField(\rPerson,\rthrough='Membership',\rthrough_fields=('group', 'person'),\r)\rclass Membership(models.Model):\rgroup = models.ForeignKey(Group, on_delete=models.CASCADE)\rperson = models.ForeignKey(Person, on_delete=models.CASCADE)\rinviter = models.ForeignKey(\rPerson,\ron_delete=models.CASCADE,\rrelated_name=\u0026quot;membership_invites\u0026quot;,\r)\rinvite_reason = models.CharField(max_length=64)\rdb_constraint=True, # 是否在数据库中创建外键约束\rdb_table=None, # 默认创建第三张表时，数据库中表的名称\r https://blog.csdn.net/u013210620/article/details/79182870\n","id":40,"section":"posts","summary":"字段 AutoField(Field) - int自增列，必须填入参数 primary_key=True BigAutoField(AutoField) - bigint自增列，必须填入参数 primary_key=True 注：当model中如果没有自增列，则自动会创建一个列名为id的列 from","tags":["django","orm"],"title":"Django ORM","uri":"https://fancyelmo.github.io/elmo-wonderland/2019/01/django-orm/","year":"2019"},{"content":"Django 文件上传 添加上传路径\n----settings.py-----\rUPLOAD_ROOT = os.path.join(BASE_DIR, \u0026#39;upload\u0026#39;).replace(\u0026#39;\\\\\u0026#39;, \u0026#39;/\u0026#39;)\rUPLOAD_URL = \u0026#39;/upload/\u0026#39;\r将文件夹注册到路由\n----urls.py----\rfrom django.conf import settings\rfrom django.conf.urls.static import static\rurlpatterns=[...]\rurlpatterns += static(settings.UPLOAD_URL, document_root=settings.UPLOAD_ROOT)\r","id":41,"section":"posts","summary":"","tags":["django"],"title":"Django 文件上传","uri":"https://fancyelmo.github.io/elmo-wonderland/2018/11/django-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","year":"2018"}],"tags":[{"title":"axios","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/axios/"},{"title":"conda","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/conda/"},{"title":"cors","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/cors/"},{"title":"database","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/database/"},{"title":"django","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/django/"},{"title":"docker","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/docker/"},{"title":"DRF","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/drf/"},{"title":"flask","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/flask/"},{"title":"git","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/git/"},{"title":"hash","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/hash/"},{"title":"linux","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/linux/"},{"title":"MessageQueue","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/messagequeue/"},{"title":"mongo","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/mongo/"},{"title":"mysql","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/mysql/"},{"title":"node.js","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/node.js/"},{"title":"nosql","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/nosql/"},{"title":"OAuth","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/oauth/"},{"title":"orm","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/orm/"},{"title":"paginator","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/paginator/"},{"title":"pip","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/pip/"},{"title":"pycharm","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/pycharm/"},{"title":"pygame","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/pygame/"},{"title":"python","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/python/"},{"title":"RabbitMQ","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/rabbitmq/"},{"title":"random","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/random/"},{"title":"redis","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/redis/"},{"title":"Serializer","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/serializer/"},{"title":"ssr","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/ssr/"},{"title":"tutorial","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/tutorial/"},{"title":"uuid","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/uuid/"},{"title":"Vue","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/vue/"},{"title":"weibo","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/weibo/"},{"title":"三方登陆","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/%E4%B8%89%E6%96%B9%E7%99%BB%E9%99%86/"},{"title":"加密","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/%E5%8A%A0%E5%AF%86/"},{"title":"安装","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/%E5%AE%89%E8%A3%85/"},{"title":"官方文档","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"},{"title":"拦截器","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"title":"搬运","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/%E6%90%AC%E8%BF%90/"},{"title":"数据类型","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"科学上网","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"title":"索引","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/%E7%B4%A2%E5%BC%95/"},{"title":"菜鸡入门","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/%E8%8F%9C%E9%B8%A1%E5%85%A5%E9%97%A8/"},{"title":"视图","uri":"https://fancyelmo.github.io/elmo-wonderland/tags/%E8%A7%86%E5%9B%BE/"}]}